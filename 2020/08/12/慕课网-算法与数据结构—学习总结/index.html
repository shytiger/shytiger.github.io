<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="慕课网-算法与数据结构-学习总结     第一章 引言课程源码play-with-Algorithms 第二章 排序基础 排序的稳定性  排序后是否改变原序列键值相同的序列的先后关系 内排序与外排序  外排序： 由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行 。外部排序最常用的算法是多路归并排序 影响排序的三个方面   时间性能 比较 移动   辅助">
<meta property="og:type" content="article">
<meta property="og:title" content="慕课网-算法与数据结构—学习总结">
<meta property="og:url" content="http://yoursite.com/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="shytiger Blog">
<meta property="og:description" content="慕课网-算法与数据结构-学习总结     第一章 引言课程源码play-with-Algorithms 第二章 排序基础 排序的稳定性  排序后是否改变原序列键值相同的序列的先后关系 内排序与外排序  外排序： 由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行 。外部排序最常用的算法是多路归并排序 影响排序的三个方面   时间性能 比较 移动   辅助">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9TZWxlY3Rpb24tU29ydC1BbmltYXRpb24uZ2lm">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTAxNjU5NC0xNTBiNmM0NjJlM2VkODA5LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7779232-d19c19b7153b27b2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjIyOTk3LWIxYmIwNDg4NDlhMjI3YmUucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8wMy9zb3J0LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://img-blog.csdn.net/2018101109461342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pocTExODY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="http://yoursite.com/source/pictures/%E5%B9%B3%E8%A1%A1%E8%B0%83%E6%95%B4%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B.bmp">
<meta property="article:published_time" content="2020-08-12T08:21:41.000Z">
<meta property="article:modified_time" content="2020-08-13T12:11:03.752Z">
<meta property="article:author" content="yan">
<meta property="article:tag" content="LearnNotes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9TZWxlY3Rpb24tU29ydC1BbmltYXRpb24uZ2lm">


<link rel="canonical" href="http://yoursite.com/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>慕课网-算法与数据结构—学习总结 | shytiger Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="shytiger Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">shytiger Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">第一章 引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8E%92%E5%BA%8F%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">第二章 排序基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">交换排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B"><span class="nav-number">2.3.</span> <span class="nav-text">插入排序及其改进</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">第三章 高级排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">归并排序及其优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%A1%8D%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">归并排序和快速排序衍生的问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">第四章 堆和堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%AE%A4%E8%AF%86"><span class="nav-number">4.1.</span> <span class="nav-text">基本概念认识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AD%98%E5%82%A8"><span class="nav-number">4.2.</span> <span class="nav-text">堆的基本存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heapfy%E8%BF%87%E7%A8%8B%EF%BC%88%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%89"><span class="nav-number">4.2.1.</span> <span class="nav-text">heapfy过程（堆的建立）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ShiftUp-%E8%8A%82%E7%82%B9%E4%B8%8A%E7%A7%BB%E6%AF%94%E8%BE%83"><span class="nav-number">4.3.</span> <span class="nav-text">ShiftUp(节点上移比较)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ShiftDown%EF%BC%88%E8%8A%82%E7%82%B9%E4%B8%8B%E7%A7%BB%E6%AF%94%E8%BE%83%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">ShiftDown（节点下移比较）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96"><span class="nav-number">4.5.</span> <span class="nav-text">堆排序及其优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A0%86"><span class="nav-number">4.6.</span> <span class="nav-text">索引堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%89%E5%8F%8A%E5%A0%86-%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">4.7.</span> <span class="nav-text">涉及堆 的相关问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.8.</span> <span class="nav-text">桶排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="nav-number">4.9.</span> <span class="nav-text">排序总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">第五章 二分搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">5-1 二分查找法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">5.2.</span> <span class="nav-text">5-2 二分搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">5.3.</span> <span class="nav-text">5-3 二分搜索树的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">5.4.</span> <span class="nav-text">二叉平衡树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AVL-%E6%A0%91"><span class="nav-number">5.5.</span> <span class="nav-text">AVL 树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">5.6.</span> <span class="nav-text">5-5 多路查找树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E6%A0%91%E5%BD%A2%E9%97%AE%E9%A2%98%E5%92%8C%E6%9B%B4%E5%A4%9A%E6%A0%91%E3%80%82"><span class="nav-number">5.7.</span> <span class="nav-text">5-6 树形问题和更多树。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">6.</span> <span class="nav-text">第六章:并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9F%BA%E7%A1%80"><span class="nav-number">6.1.</span> <span class="nav-text">6-1 并查集基础</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9B%BE"><span class="nav-number">7.</span> <span class="nav-text">第七章: 图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">7.1.</span> <span class="nav-text">7-1 图论基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E7%9B%B8%E9%82%BB%E7%82%B9%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">7.2.</span> <span class="nav-text">7-2 相邻点迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-number">7.3.</span> <span class="nav-text">7-4 图的算法框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">7.4.</span> <span class="nav-text">7-5 深度优先遍历和联通分量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">7.5.</span> <span class="nav-text">7-7 广度优先遍历和最短路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-%E6%9B%B4%E5%A4%9A%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">7.6.</span> <span class="nav-text">7-8 更多无权图的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">第八章：最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E5%92%8C%E5%88%87%E5%88%86%E5%AE%9A%E7%90%86"><span class="nav-number">8.1.</span> <span class="nav-text">8-1 最小生成树问题和切分定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-Prim%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96"><span class="nav-number">8.2.</span> <span class="nav-text">8-2 Prim算法及其优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-Krusk%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.</span> <span class="nav-text">8-3 Krusk算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">8.4.</span> <span class="nav-text">8-6 最小生成树算法的思考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">9.</span> <span class="nav-text">第九章：最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%92%8C%E6%9D%BE%E5%BC%9B%E6%93%8D%E4%BD%9C"><span class="nav-number">9.1.</span> <span class="nav-text">9-1 最短路径问题和松弛操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-Dijkstra%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3"><span class="nav-number">9.2.</span> <span class="nav-text">9-2 Dijkstra算法的思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-%E5%AE%9E%E7%8E%B0Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">9.3.</span> <span class="nav-text">9-3 实现Dijkstra算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-%E8%B4%9F%E6%9D%83%E8%BE%B9%E5%92%8CBellman-Ford%E7%AE%97%E6%B3%95"><span class="nav-number">9.4.</span> <span class="nav-text">9-4 负权边和Bellman-Ford算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-%E5%AE%9E%E7%8E%B0Bellman-Ford%E7%AE%97%E6%B3%95"><span class="nav-number">9.5.</span> <span class="nav-text">9-5 实现Bellman-Ford算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-%E6%9B%B4%E5%A4%9A%E5%92%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">9.6.</span> <span class="nav-text">9-6 更多和最短路径相关的思考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="nav-number">10.</span> <span class="nav-text">第十章：结束语</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shytiger Blog">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          慕课网-算法与数据结构—学习总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-12 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-12T16:21:41+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-13 20:11:03" itemprop="dateModified" datetime="2020-08-13T20:11:03+08:00">2020-08-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p><strong>慕课网-算法与数据结构-学习总结</strong>  </p>
</blockquote>
<hr>
<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p><a target="_blank" rel="noopener" href="https://github.com/liuyubobobo/Play-with-Algorithms">课程源码play-with-Algorithms</a></p>
<h1 id="第二章-排序基础"><a href="#第二章-排序基础" class="headerlink" title="第二章 排序基础"></a>第二章 排序基础</h1><ul>
<li><strong>排序的稳定性</strong><br>  排序后是否改变原序列键值相同的序列的先后关系</li>
<li><strong>内排序与外排序</strong><br>  外排序： 由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行 。外部排序最常用的算法是多路归并排序</li>
<li><strong>影响排序的三个方面</strong>  <ul>
<li>时间性能<ul>
<li>比较</li>
<li>移动</li>
</ul>
</li>
<li>辅助空间</li>
<li>算法复杂度  <h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2></li>
</ul>
</li>
</ul>
<ul>
<li><p>冒泡排序</p>
<ul>
<li>基本思想：两两交换，将最大（或最小）的交换至队列前  <h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2></li>
</ul>
</li>
<li><p>简单选择排序  </p>
<ul>
<li>基本思想：在未排序的序列种找到最小（或最大）的元素放到前面  </li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9TZWxlY3Rpb24tU29ydC1BbmltYXRpb24uZ2lm" alt="动画演示">  </li>
</ul>
</li>
<li><p>参考实现代码（cpp）</p>
<pre><code>    template&lt;typename T&gt;
    void selectionSort(T arr[], int n)&amp;#123;

        for(int i = 0 ; i &lt; n ; i ++)&amp;#123;

            int minIndex = i;
            for( int j = i + 1 ; j &lt; n ; j ++ )
                if( arr[j] &lt; arr[minIndex] )
                    minIndex = j;

            swap( arr[i] , arr[minIndex] );
        &amp;#125;
    &amp;#125;</code></pre>
</li>
<li><p>直接选择排序  </p>
</li>
<li><p>树型选择排序</p>
</li>
</ul>
<h2 id="插入排序及其改进"><a href="#插入排序及其改进" class="headerlink" title="插入排序及其改进"></a>插入排序及其改进</h2><ul>
<li><p>直接插入排序  </p>
<ul>
<li><p>基本思想: 将未排序的元素插入到已经排好序的队列种对应的位置</p>
</li>
<li><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTAxNjU5NC0xNTBiNmM0NjJlM2VkODA5LnBuZw?x-oss-process=image/format,png" alt="示意图">  </p>
</li>
<li><p>代码</p>
<pre><code>template&lt;typename T&gt;
void insertionSort(T arr[], int n)&amp;#123;
    for( int i = 1 ; i &lt; n ; i ++ ) &amp;#123;

    // 寻找元素arr[i]合适的插入位置
    // 写法1
    //        for( int j = i ; j &gt; 0 ; j-- )
    //            if( arr[j] &lt; arr[j-1] )
    //                swap( arr[j] , arr[j-1] );
    //            else
    //                break;

    // 写法2
    //        for( int j = i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )
    //            swap( arr[j] , arr[j-1] );

    // 写法3
                T e = arr[i];
                int j; // j保存元素e应该插入的位置
                for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; e; j--)
                    arr[j] = arr[j-1];
                arr[j] = e;
    &amp;#125;
    return;
&amp;#125;</code></pre>
</li>
<li><p>改进：   </p>
<ul>
<li><p><strong>折半插入排序：</strong> 找到已排好序种对应位置时 用 折半查找   </p>
</li>
<li><p><strong>希尔排序</strong>:</p>
<ul>
<li><p>基本思想：交换不相邻的元素以对数组的<strong>局部</strong>进行排序</p>
</li>
<li><p><img src="https://upload-images.jianshu.io/upload_images/7779232-d19c19b7153b27b2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp"></p>
</li>
<li><p>第一个O(n log n)的排序算法</p>
</li>
<li><p>参考代码</p>
<pre><code>template&lt;typename T&gt;
void shellSort(T arr[], int n)&amp;#123;

    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...
    int h = 1;
    while( h &lt; n/3 )
        h = 3 * h + 1;

    while( h &gt;= 1 )&amp;#123;

        // h-sort the array
        for( int i = h ; i &lt; n ; i ++ )&amp;#123;

            // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序
            T e = arr[i];
            int j;
            for( j = i ; j &gt;= h &amp;&amp; e &lt; arr[j-h] ; j -= h )
                arr[j] = arr[j-h];
            arr[j] = e;
        &amp;#125;

        h /= 3;
    &amp;#125;
&amp;#125;</code></pre>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/642b19f8a69c">希尔排序及其优化</a>  </p>
</li>
</ul>
</li>
<li><p>其他： 路插入排序,表插入排序等。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第三章-高级排序问题"><a href="#第三章-高级排序问题" class="headerlink" title="第三章 高级排序问题"></a>第三章 高级排序问题</h1><h2 id="归并排序及其优化"><a href="#归并排序及其优化" class="headerlink" title="归并排序及其优化"></a>归并排序及其优化</h2><ul>
<li><p>基本思想： (分治)将排序序列差分成 两个等长的子序列，对子序列进行排序后再归并</p>
</li>
<li><p>参考核心代码(cpp)</p>
<pre><code>    // 使用优化的归并排序算法, 对arr[l...r]的范围进行排序
    template&lt;typename T&gt;
    void __mergeSort2(T arr[], int l, int r)&amp;#123;

        // 优化2: 对于小规模数组, 使用插入排序
        if( r - l &lt;= 15 )&amp;#123;
            insertionSort(arr, l, r);
            return;
        &amp;#125;

        int mid = (l+r)/2;
        __mergeSort2(arr, l, mid);
        __mergeSort2(arr, mid+1, r);

        // 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge
        // 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失
        if( arr[mid] &gt; arr[mid+1] )
            __merge(arr, l, mid, r);
    &amp;#125;</code></pre>
</li>
<li><p>优化点：    </p>
<pre><code>- 当排序的元素少于一定（16）时，直接调用 插入排序  
- 如果第一个序列的最大值小于第二个序列的最小值，则不用比较，直接合并  </code></pre>
<ul>
<li><p>归并排序的自底向上写法（迭代）  </p>
</li>
<li><p><strong>核心代码参考</strong>    </p>
<pre><code>  ```        

  // 使用自底向上的归并排序算法
  template &lt;typename T&gt;
  void mergeSortBU(T arr[], int n)&amp;#123;
      // Merge Sort Bottom Up 优化
      // 对于小数组, 使用插入排序优化
      for( int i = 0 ; i &lt; n ; i += 16 )
          insertionSort(arr,i,min(i+15,n-1));

      for( int sz = 16; sz &lt; n ; sz += sz )
          for( int i = 0 ; i &lt; n - sz ; i += sz+sz )
              // 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge
              if( arr[i+sz-1] &gt; arr[i+sz] )
                  __merge(arr, i, i+sz-1, min(i+sz+sz-1,n-1) );
      // Merge Sort BU 也是一个O(nlogn)复杂度的算法，虽然只使用两重for循环
      // 所以，Merge Sort BU也可以在1秒之内轻松处理100万数量级的数据
      // 注意：不要轻易根据循环层数来判断算法的复杂度，Merge Sort BU就是一个反例
      // 关于这部分陷阱，推荐看（liubobo老师）的《玩转算法面试》课程，第二章：《面试中的复杂度分析》：）
  &amp;#125;
  ```</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></li>
</ul>
</li>
<li><p>基本思想： （分治） 将选定的元素放到合适的位置，然后 递归 排序 被该元素分开的 前 后 两个子序列。(分出来的两个子序列可能不等长，相差很大，会影响性能)</p>
</li>
<li><p>核心代码参考  </p>
<pre><code>```
// 对arr[l...r]部分进行partition操作
// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]
template &lt;typename T&gt;
int _partition(T arr[], int l, int r)&amp;#123;

    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    swap( arr[l] , arr[rand()%(r-l+1)+l] );

    T v = arr[l];
    int j = l;
    for( int i = l + 1 ; i &lt;= r ; i ++ )
        if( arr[i] &lt; v )&amp;#123;
            j ++;
            swap( arr[j] , arr[i] );
        &amp;#125;

    swap( arr[l] , arr[j]);

    return j;
&amp;#125;

// 对arr[l...r]部分进行快速排序
template &lt;typename T&gt;
void _quickSort(T arr[], int l, int r)&amp;#123;

    // 对于小规模数组, 使用插入排序进行优化
    if( r - l &lt;= 15 )&amp;#123;
        insertionSort(arr,l,r);
        return;
    &amp;#125;

    int p = _partition(arr, l, r);
    _quickSort(arr, l, p-1 );
    _quickSort(arr, p+1, r);
&amp;#125;
```</code></pre>
</li>
<li><p>优化：  </p>
<pre><code>1. 标定点 随机选（针对基本有序的序列，如果固定选最前面的元素，则分治的两个子问题不平衡，退化为O(n^2)的复杂度）  
2. 小规模排序，使用插入排序</code></pre>
</li>
<li><p>双路快排  </p>
<ul>
<li><p>基本思想：针对键值重复过多时，分治的两个子序列不等长，导致分治不平衡</p>
</li>
<li><p>核心代码参考</p>
<pre><code>// 双路快速排序的partition
// 返回p, 使得arr[l...p-1] &lt;= arr[p] ; arr[p+1...r] &gt;= arr[p]
// 双路快排处理的元素正好等于arr[p]的时候要注意，详见下面的注释：）
template &lt;typename T&gt;
int _partition2(T arr[], int l, int r)&amp;#123;

    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    swap( arr[l] , arr[rand()%(r-l+1)+l] );
    T v = arr[l];

    // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v
    int i = l+1, j = r;
    while( true )&amp;#123;
        // 注意这里的边界, arr[i] &lt; v, 不能是arr[i] &lt;= v
        // 思考一下为什么?
        while( i &lt;= r &amp;&amp; arr[i] &lt; v )
            i ++;

        // 注意这里的边界, arr[j] &gt; v, 不能是arr[j] &gt;= v
        // 思考一下为什么?
        while( j &gt;= l+1 &amp;&amp; arr[j] &gt; v )
            j --;

        // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)
        // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html

        if( i &gt; j )
            break;

        swap( arr[i] , arr[j] );
        i ++;
        j --;
    &amp;#125;

    swap( arr[l] , arr[j]);

    return j;
&amp;#125;

// 对arr[l...r]部分进行快速排序
template &lt;typename T&gt;
void _quickSort(T arr[], int l, int r)&amp;#123;

    // 对于小规模数组, 使用插入排序进行优化
    if( r - l &lt;= 15 )&amp;#123;
        insertionSort(arr,l,r);
        return;
    &amp;#125;

    // 调用双路快速排序的partition
    int p = _partition2(arr, l, r);
    _quickSort(arr, l, p-1 );
    _quickSort(arr, p+1, r);
&amp;#125;</code></pre>
</li>
</ul>
</li>
<li><p>三路快排 </p>
<ul>
<li><p>基本思想： 针对2路快排的加强，进一步解决键值重复过多的问题（增加一个等值区域）</p>
</li>
<li><p>核心代码参考</p>
<pre><code>// 递归的三路快速排序算法
template &lt;typename T&gt;
void __quickSort3Ways(T arr[], int l, int r)&amp;#123;

    // 对于小规模数组, 使用插入排序进行优化
    if( r - l &lt;= 15 )&amp;#123;
        insertionSort(arr,l,r);
        return;
    &amp;#125;

    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    swap( arr[l], arr[rand()%(r-l+1)+l ] );

    T v = arr[l];

    int lt = l;     // arr[l+1...lt] &lt; v
    int gt = r + 1; // arr[gt...r] &gt; v
    int i = l+1;    // arr[lt+1...i) == v
    while( i &lt; gt )&amp;#123;
        if( arr[i] &lt; v )&amp;#123;
            swap( arr[i], arr[lt+1]);
            i ++;
            lt ++;
        &amp;#125;
        else if( arr[i] &gt; v )&amp;#123;
            swap( arr[i], arr[gt-1]);
            gt --;
        &amp;#125;
        else&amp;#123; // arr[i] == v
            i ++;
        &amp;#125;
    &amp;#125;

    swap( arr[l] , arr[lt] );

    __quickSort3Ways(arr, l, lt-1);
    __quickSort3Ways(arr, gt, r);
&amp;#125;

template &lt;typename T&gt;
void quickSort3Ways(T arr[], int n)&amp;#123;

    srand(time(NULL));
    __quickSort3Ways( arr, 0, n-1);
&amp;#125;
// 比较Merge Sort和双路快速排序和三路快排三种排序算法的性能效率
// 对于包含有大量重复数据的数组, 三路快排有巨大的优势
// 对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围里
// 因此, 在一些语言中, 三路快排是默认的语言库函数中使用的排序算法。比如Java:)</code></pre>
<h2 id="归并排序和快速排序衍生的问题"><a href="#归并排序和快速排序衍生的问题" class="headerlink" title="归并排序和快速排序衍生的问题"></a>归并排序和快速排序衍生的问题</h2></li>
</ul>
<ul>
<li>求逆序对（归并排序）</li>
<li>求数组中的第N大元素</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第四章-堆和堆排序"><a href="#第四章-堆和堆排序" class="headerlink" title="第四章 堆和堆排序"></a>第四章 堆和堆排序</h1><h2 id="基本概念认识"><a href="#基本概念认识" class="headerlink" title="基本概念认识"></a>基本概念认识</h2><ul>
<li>队列<ul>
<li>普通队列：先进先出</li>
<li>优先队列：根据优先级出队  </li>
</ul>
</li>
<li><strong>优先队列应用</strong>  对动态的数据排序  </li>
<li>优先队列的三种实现方式  <table>
<thead>
<tr>
<th align="left">实现方式</th>
<th align="left">入队</th>
<th align="left">出队</th>
</tr>
</thead>
<tbody><tr>
<td align="left">普通数组</td>
<td align="left">O(1)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">顺序数组(元素有序)</td>
<td align="left">O(n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">堆</td>
<td align="left">O(log n)</td>
<td align="left">O(log n)</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="堆的基本存储"><a href="#堆的基本存储" class="headerlink" title="堆的基本存储"></a>堆的基本存储</h2><pre><code>* 用数组存储二叉堆
* 数组的索引次序 对应 二叉堆中 层序遍历次序
* 对于完全二叉树,对第i个元素，其与其父，其子的关系
    * 根节点索引从0开始
        * parent(i) = （i-1）/2
        * left child (i) = 2*i +1
        * right child (i) = 2*i + 2
    * 根节点索引从1开始
        * parent(i) = i/2
        * left child (i) = 2*i 
        * right child (i) = 2*i + 1</code></pre>
<h3 id="heapfy过程（堆的建立）"><a href="#heapfy过程（堆的建立）" class="headerlink" title="heapfy过程（堆的建立）"></a>heapfy过程（堆的建立）</h3><pre><code>- 基本思想：从最后一个非叶子节点（索引为count/2，在根节点索引从1开始的情况下）开始，shiftdown()，自底向上实现堆
- 将n个元素逐个插入空堆中，算法复杂度为O(n log n),而heapfy过程算法复杂度O(n)  
- 代码
```
    // 构造函数, 通过一个给定数组创建一个最大堆
    // 该构造堆的过程, 时间复杂度为O(n)
    MaxHeap(Item arr[], int n)&amp;#123;
        data = new Item[n+1];
        capacity = n;

        for( int i = 0 ; i &lt; n ; i ++ )
            data[i+1] = arr[i];
        count = n;

        for( int i = count/2 ; i &gt;= 1 ; i -- )
            shiftDown(i);
    &amp;#125;
```</code></pre>
<h2 id="ShiftUp-节点上移比较"><a href="#ShiftUp-节点上移比较" class="headerlink" title="ShiftUp(节点上移比较)"></a>ShiftUp(节点上移比较)</h2><pre><code>- 代码
    ```
        void shiftUp(int k)&amp;#123;
        while( k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] )&amp;#123;
            swap( data[k/2], data[k] );
            k /= 2;
        &amp;#125;
        &amp;#125;
    ``` </code></pre>
<h2 id="ShiftDown（节点下移比较）"><a href="#ShiftDown（节点下移比较）" class="headerlink" title="ShiftDown（节点下移比较）"></a>ShiftDown（节点下移比较）</h2><pre><code>- 代码
```
    void shiftDown(int k)&#123;
    while( 2*k &lt;= count )&#123;
        int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置
        if( j+1 &lt;= count &amp;&amp; data[j+1] &gt; data[j] )
            j ++;
        // data[j] 是 data[2*k]和data[2*k+1]中的最大值

        if( data[k] &gt;= data[j] ) break;
        swap( data[k] , data[j] );
        k = j;
    &#125;
    &#125;
```</code></pre>
<h2 id="堆排序及其优化"><a href="#堆排序及其优化" class="headerlink" title="堆排序及其优化"></a>堆排序及其优化</h2><pre><code>* 堆排序算法：
    * 创建堆： 一种通过不断insert()创建O(nlogn)，一种传入数组用heapfy创建O(n)
    * 堆顶出堆： 将堆顶与堆尾互换，堆的size-1,并将新的堆顶（原堆尾）shiftDown()
    * 重复第二步  
* 堆排序的实现
    1. 借助insert()创建堆
    ```
    // heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序
    // 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)
    // 整个堆排序的整体时间复杂度为O(nlogn)
    template&lt;typename T&gt;
    void heapSort1(T arr[], int n)&#123;

        MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);
        for( int i = 0 ; i &lt; n ; i ++ )
            maxheap.insert(arr[i]);

        for( int i = n-1 ; i &gt;= 0 ; i-- )
            arr[i] = maxheap.extractMax();

    &#125;

    2. 借助heapfy() 创建堆
    // heapSort2, 借助我们的heapify过程创建堆
    // 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 实践复杂度为O(nlogn)
    // 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优
    template&lt;typename T&gt;
    void heapSort2(T arr[], int n)&#123;

        MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(arr,n);
        for( int i = n-1 ; i &gt;= 0 ; i-- )
            arr[i] = maxheap.extractMax();

    &#125;
    ```
* 堆的实现细节
    *ShiftUp和ShiftDown种使用复制操作替换swap操作*  </code></pre>
<h2 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h2><ul>
<li><p>基本思想： 分索引数组和数据数组，数据数组存数据元素。索引数组按堆的次序（比较的是实际元素的键值）存对应节点的索引（地址）。ShiftUP和ShiftDown中比较(实际元素的值)，交换对应的索引（存储地址），而不交换实际的元素。</p>
</li>
<li><p>一点理解： 维护了一个数组，既能有堆的特性（取最值），又能保持原有数组的存储次序（数据数组的索引是原数组的+1）。</p>
</li>
<li><p>ShfitUp()</p>
<pre><code>    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引
    void shiftUp( int k )&#123;
    while( k &gt; 1 &amp;&amp; data[indexes[k/2]] &lt; data[indexes[k]] )&#123;
        swap( indexes[k/2] , indexes[k] );
        k /= 2;
    &#125;
&#125;</code></pre>
</li>
<li><p>ShiftDown()</p>
<pre><code>    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引
    void shiftDown( int k )&#123;
        while( 2*k &lt;= count )&#123;
            int j = 2*k;
            if( j + 1 &lt;= count &amp;&amp; data[indexes[j+1]] &gt; data[indexes[j]] )
                j += 1;
            if( data[indexes[k]] &gt;= data[indexes[j]] )
                break;
            swap( indexes[k] , indexes[j] );
            k = j;
        &#125;
    &#125;</code></pre>
</li>
<li><p>增删实现 (<strong>插入操作 不是很理解</strong>)</p>
<pre><code>    // 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item
// 传入的i对用户而言,是从0索引的
void insert(int i, Item item)&#123;
    assert( count + 1 &lt;= capacity );
    assert( i + 1 &gt;= 1 &amp;&amp; i + 1 &lt;= capacity );
    i += 1;
    data[i] = item;
    indexes[count+1] = i;
    count++;
    shiftUp(count);
&#125;

// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据
Item extractMax()&#123;
    assert( count &gt; 0 );

    Item ret = data[indexes[1]];
    swap( indexes[1] , indexes[count] );
    count--;
    shiftDown(1);
    return ret;
&#125;</code></pre>
</li>
<li><p>应用： 最小生成树Prim算法中，用来维护 每个节点对应的最小横切面的权重【同时能输出当前所有节点最小横切面中的最小横切面】</p>
<h2 id="涉及堆-的相关问题"><a href="#涉及堆-的相关问题" class="headerlink" title="涉及堆 的相关问题"></a>涉及堆 的相关问题</h2><ul>
<li>多路归并排序 多个元素同时比较的时候用，最小（大）堆</li>
<li>d叉堆 d-ary heap  </li>
<li>最大最小队列 （最大堆和最小堆同时维护？？）</li>
<li>二项堆</li>
<li>斐波那契堆</li>
</ul>
</li>
</ul>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><pre><code>基本思想： 分配 + 收集 （先排序低位再排序高位）</code></pre>
<h2 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h2><table>
<thead>
<tr>
<th align="left">排序</th>
<th align="left">平均时间复杂度</th>
<th align="left">原地排序</th>
<th align="left">额外空间</th>
<th align="left">稳定排序</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入排序（Insertion Sort）</td>
<td align="left">O(n^2)</td>
<td align="left">是</td>
<td align="left">O(1)</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">归并排序(Merge Sort)</td>
<td align="left">O（nlogn）</td>
<td align="left">否</td>
<td align="left">O(n)</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">快速排序（Quick Sort）</td>
<td align="left">O(nlogn)</td>
<td align="left">是</td>
<td align="left"><strong>O（logn）</strong></td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">堆排序（Heap Sort)</td>
<td align="left">O(nlogn)</td>
<td align="left">是</td>
<td align="left">O(1)</td>
<td align="left">否</td>
</tr>
</tbody></table>
<ul>
<li><strong>不同排序算法的选择</strong>  <ul>
<li>n较小：直接插入排序或直接选择排序</li>
<li>基本有序序列，直接插入，冒泡，随机的快速排序</li>
<li>n较大，应选复杂度好的：快速排序，归并排序， 堆排序。<ul>
<li>快速排序性能平均最好，堆排序更少的辅助空间，归并排序是稳定的排序。（当排序数少于一定时如16，<strong>调用直接插入排序</strong>）  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>其他参考</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjIyOTk3LWIxYmIwNDg4NDlhMjI3YmUucG5n?x-oss-process=image/format,png" alt="排序算法总结"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8wMy9zb3J0LnBuZw?x-oss-process=image/format,png" alt="排序对比"><br><img src="https://img-blog.csdn.net/2018101109461342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pocTExODY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/liu17234050/article/details/104217658">C语言中的14种排序</a><br> <a target="_blank" rel="noopener" href="https://v.qq.com/x/page/e0523qakza6.html">14中排序动画演示</a>   </p>
<hr>
<h1 id="第五章-二分搜索树"><a href="#第五章-二分搜索树" class="headerlink" title="第五章 二分搜索树"></a>第五章 二分搜索树</h1><h2 id="5-1-二分查找法"><a href="#5-1-二分查找法" class="headerlink" title="5-1 二分查找法"></a>5-1 二分查找法</h2><ul>
<li><p>基本思想： （递归分治）对有序序列，不需要逐一比较，只要比较中间值，然后确定目标值的可能区域，再在可能区域递归二分查找。</p>
</li>
<li><p>细节： </p>
<ol>
<li>计算中间值时， 注意防止越界（基本类型的范围）。<ul>
<li>合理写法： int mid = left + (right-left)/2 ，</li>
<li>危险写法： int mid = (left + right)/2</li>
</ul>
</li>
<li>二分查找返回的只有一个索引，而序列中可能存在重复值。如何返回所有重复值？<ul>
<li>练习：对于存在重复值的序列，返回目标值索引的floor(第一个索引)和ceil（最后一个索引）</li>
</ul>
</li>
</ol>
</li>
<li><p>改进：（选不同的分割点）</p>
<ul>
<li>插值查找 （按比值分割） <ul>
<li>mid = left + (right-left)*&#123;(key-a[left])/(a[right]-a[left])&#125;</li>
</ul>
</li>
<li>斐波那契查找<ul>
<li>mid = left + F_block - 1 (黄金分割)<h2 id="5-2-二分搜索树"><a href="#5-2-二分搜索树" class="headerlink" title="5-2 二分搜索树"></a>5-2 二分搜索树</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>二分搜索树的定义：</p>
<ul>
<li>左子树&gt;(&lt;) 根 &gt;(&lt;) 右子树 [一般不考虑键值重复的问题]</li>
</ul>
</li>
<li><p>二分搜索树的优势</p>
<ul>
<li>高效(（O(nlogn))的维护数据的有序性：min,max,floor,ceil,rank,select</li>
</ul>
</li>
<li><p>二分搜索树的节点插入</p>
<ul>
<li><p>实现方式： </p>
<ol>
<li><p>递归(返回子树根节点)[从根节点开始搜索，找到key值则替换，未找到则根据比较关系递归子树]</p>
<pre><code class="Cpp"> // 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法
 // 返回插入新节点后的二分搜索树的根
 private Node insert(Node node, Key key, Value value)\&amp;#123;

     if( node == null )&amp;#123;
         count ++;
         return new Node(key, value);
     &amp;#125;

     if( key.compareTo(node.key) == 0 )
         node.value = value;
     else if( key.compareTo(node.key) &lt; 0 )
         node.left = insert( node.left , key, value);
     else    // key &gt; node-&gt;key
         node.right = insert( node.right, key, value);

     return node;
 &amp;#125;</code></pre>
</li>
<li><p>迭代</p>
<ul>
<li>当作练习</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>二分搜索书的查找  </p>
<ul>
<li>基本思想: 二分查找</li>
</ul>
</li>
<li><p>二分搜索树的遍历</p>
<ul>
<li>（深度优先遍历）  <ul>
<li>前序遍历，中序遍历，后序遍历</li>
</ul>
</li>
<li>（广度优先遍历）<ul>
<li>层序遍历</li>
</ul>
</li>
</ul>
</li>
<li><p>删除最大值，最小值  </p>
<ul>
<li>实现：<ul>
<li>递归：（不断递归(左/右)子树，直到节点没有（左/右）子树，删除该节点，返回其的（右/左）子树赋值给上一节点的（左/右）子树）</li>
</ul>
</li>
</ul>
</li>
<li><p>删除Key对应的节点</p>
<ul>
<li>实现： <ul>
<li>递归<ul>
<li>从根节点开始递归搜索<ul>
<li>如果目标值在根节点则删除根节点，选新的中间值上位（左子树最右（大/小）的节点，右子树最左（小/大）的节点）</li>
<li>否则根据比较次序，选择（左/右）子树递归搜索，根节点的（左/右）子树 = 返回删除最值后的子树的根节点<h2 id="5-3-二分搜索树的特性"><a href="#5-3-二分搜索树的特性" class="headerlink" title="5-3 二分搜索树的特性"></a>5-3 二分搜索树的特性</h2></li>
<li>顺序性</li>
<li>minimum/maximum</li>
<li>successor/predecessor 后继/前继</li>
<li>floor/ceil （存在键值重复时，索引的范围）</li>
<li>rank/select 已知key获取排名/已知排名获取key,value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>局限性：(不平衡) 依照顺序或逆序插入元素，二分搜索树退化为链表（跟节点为第一个元素，在最左，或最右）。</p>
</li>
<li><p>支持重复键值的二分搜索树</p>
<ul>
<li>思路一： 让键值重复节点的右子树或左子树包含键值重复的节点。</li>
<li>思路二： 每个节点增加一个区域（链表或数组），存键值相等的元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><pre><code>- 平衡二叉树：
    - 左右子树高度差不超过1的二叉搜索树，即平衡二叉树所有结点的平衡因子绝对值不超过1（平衡因子 = 结点左子树的高度 - 结点右子树的高度）。
- 实现方式：
    - AVL树
    - 红黑树
    - 2-3树
    - Splay树</code></pre>
<h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><ul>
<li>基本思想，每插入一个节点，自底向上维护树的平衡，以及每个节点的平衡因子</li>
<li>平衡调整的四种类型：<ul>
<li>LL型 右旋调整 调整后涉及到的节点的平衡因子（bf）均为0</li>
<li>RR型 左旋调整 调整后涉及到的节点的平衡因子(bf)均为0</li>
<li>LR型 先左旋调整至LL型， 然后右旋调整 bf的维护如下： </li>
<li>RL型 先右旋调整至RR型， 然后左旋调整<br><img src="/source/pictures/%E5%B9%B3%E8%A1%A1%E8%B0%83%E6%95%B4%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B.bmp"></li>
</ul>
</li>
</ul>
<ul>
<li><p>插入操作思路整理：</p>
<ul>
<li>考虑当前节点的子树是否添加了新节点<ul>
<li>没有 则不用维护，直接返回</li>
<li>左子树添加了新节点 <strong>&gt;&gt;&gt;</strong> 当前节点的平衡因子要加一($bf= bf+1$)<ul>
<li>若$bf&gt;1$(需要平衡调整) <strong>&gt;&gt;&gt;</strong> 进行左平衡调整</li>
</ul>
</li>
<li>右子树添加了新节点 <strong>&gt;&gt;&gt;</strong> 当前节点的平衡因子要减一($bf = bf -1$)<ul>
<li>若$bf&lt;-1$，需要平衡调整 **&gt;&gt;&gt;** 进行右平衡调整</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>左平衡调整(cur.bf &gt; 1)</p>
<ul>
<li>看cur的左子节点L 的平衡因子 L.bf<ul>
<li>L.bf == 1 <strong>&gt;&gt;&gt;</strong> LL型 <strong>&gt;&gt;&gt;</strong> 右旋操作</li>
<li>L.bf == -1 <strong>&gt;&gt;&gt;</strong> LR型 <strong>&gt;&gt;&gt;</strong> 先左旋调整至LL型，然后右旋调整</li>
</ul>
</li>
</ul>
</li>
<li><p>右平衡调整(cur.bf &lt; -1)</p>
<ul>
<li>看cur节点的右孩子节点R 的平衡因子R.bf<ul>
<li>R.bf == -1 <strong>&gt;&gt;&gt;</strong> RR型 <strong>&gt;&gt;&gt;</strong> 左旋操作</li>
<li>R.bf == 1 <strong>&gt;&gt;&gt;</strong> RL型 <strong>&gt;&gt;&gt;</strong> 先右旋调整至RR型，然后左旋调整</li>
</ul>
</li>
</ul>
</li>
<li><p>插入操作代码</p>
<pre><code class="Java">  //插入操作
  void insert(K key,V value) &amp;#123;
      taller = false; //增加了新的一层？？
      root = __insert(root,key,value);
  &amp;#125;

  //返回插入新节点后的根节点
  private AVLNode __insert(AVLNode curNode,K key,V value) &amp;#123;
      if(curNode==null) &amp;#123;
          curNode = new AVLNode(key,value);
          taller = true; //增加了新节点
          return curNode;//
      &amp;#125;
      else &amp;#123;
          if(key.compareTo(curNode.key)==0) &amp;#123;
              return curNode;//节点已经存在，返回（不覆盖旧值）
          &amp;#125;
          else if(key.compareTo(curNode.key)&lt;0) &amp;#123;
              curNode.left = __insert(curNode.left,key,value); //往左子树新增节点
              if(taller) &amp;#123;//增加了新节点
                  switch(curNode.bf) &amp;#123;
                      case 0: //新增节点没有打破平衡，但bf+1
                          curNode.bf = 1;//左边新加一个点
                          taller = true;//此处很重要，自底 向上传递平衡信息
                          break;
                      case 1:  //本来左子树多一个结点，然后taller为true,左子树又增加了一个结点
                          curNode = leftBalance(curNode); //左平衡时必须保证 curNode具有左孩子
                          taller = false; //左平衡后 达到平衡
                          break;
                      case -1: //新增节点使得curNode左右平衡
                          curNode.bf = 0;
                          taller = false;
                          break;
                  &amp;#125;
              &amp;#125;
              return curNode;
          &amp;#125;
          else &amp;#123; //往当前节点的右子树增添节点
              curNode.right = __insert(curNode.right,key,value);//往右子树增加节点
              if(taller) &amp;#123;
                  switch(curNode.bf) &amp;#123;
                      case 0:
                          curNode.bf = -1;
                          taller = true;
                          break;
                      case 1:
                           curNode.bf = 0;
                           taller = false;
                           break;
                      case -1:
                          curNode = rightBalance(curNode);
                          taller = false;
                          break;        
                  &amp;#125;
              &amp;#125;
              return curNode;
          &amp;#125;
      &amp;#125;
  &amp;#125;</code></pre>
</li>
<li><p>左平衡调整代码</p>
<pre><code class="Java">  /*
   * 左平衡操作
   */
  //[当前curNode的bf&gt;0，又再左子树增加节点时需要左平衡操作]
  AVLNode leftBalance(AVLNode curNode) &amp;#123;
      AVLNode L = curNode.left;
      if(L.bf==1) &amp;#123; //LL型需要左旋
          curNode.bf = 0;//右旋平衡
          L.bf = 0;//右旋平衡
          return rightRotate(curNode);
      &amp;#125;
      else if(L.bf==-1) &amp;#123;//LR型需要 先左旋  后右旋
          AVLNode LR = L.right; //左孩子的右孩子
          //以下代码不是很理解,,,画一下实际例子可以明白，，但为啥子LR.bf不会一直被维护为0？（因为LR不一定是新增节点?）
          switch(LR.bf) &amp;#123;
              case 1:
                  curNode.bf = -1;
                  L.bf = 0;
                  break;
              case 0:
                  curNode.bf = 0;
                  L.bf = 0;
                  break;
              case -1:
                  curNode.bf = 0;
                  L.bf = 1;
                  break;
          &amp;#125;
          LR.bf = 0;
          curNode.left = leftRotate(curNode.left);
          return rightRotate(curNode);
      &amp;#125;
      else &amp;#123;//不需要左平衡处理
          return curNode;
      &amp;#125;
  &amp;#125;</code></pre>
</li>
<li><p>右平衡调整代码</p>
<pre><code class="Java">  //右平衡操作
  /*
   * curNode bf本已经-1的基础上，在右方又新增节点
   */
  AVLNode rightBalance(AVLNode curNode) &amp;#123;
      AVLNode R = curNode.right;
      if(R.bf==-1) &amp;#123; //RR型 
          curNode.bf = 0;
          R.bf = 0;
          return leftRotate(curNode);
      &amp;#125;
      else if(R.bf==1) &amp;#123;//RL型
          AVLNode RL = R.left;
          switch(RL.bf) &amp;#123;
              case 0:
                  curNode.bf = 0;
                  R.bf = 0;
                  break;
              case 1:
                  R.bf =-1;
                  curNode.bf = 0;
                  break;
              case -1:
                  curNode.bf = 1;
                  R.bf = 0;
                  break;
          &amp;#125;
          RL.bf = 0;
          curNode.right = rightRotate(R);
          return leftRotate(curNode);

      &amp;#125;
      else &amp;#123;
          return curNode;
      &amp;#125;
  &amp;#125;</code></pre>
</li>
<li><p>左旋操作</p>
<pre><code class="Java">  //左旋操作
  AVLNode leftRotate(AVLNode curNode) &amp;#123;
      AVLNode subRoot = curNode.right;
      curNode.right = subRoot.left;
      subRoot.left = curNode;
      return subRoot;
  &amp;#125;</code></pre>
</li>
<li><p>右旋操作</p>
<pre><code class="Java">  //右旋操作
  AVLNode rightRotate(AVLNode curNode) &amp;#123;
      AVLNode subRoot = curNode.left;//左孩子上位
      curNode.left = subRoot.right;//把你的右孩子给我，作为我的左孩子(保证排序性)
      subRoot.right = curNode;//你上位后我成为你的有孩子
      return subRoot;
  &amp;#125;</code></pre>
</li>
<li><p>其他操作实现：</p>
<ul>
<li>可参考&lt;&lt;数据结构从应用到时间（Java版）&gt;&gt;<h2 id="5-5-多路查找树"><a href="#5-5-多路查找树" class="headerlink" title="5-5 多路查找树"></a>5-5 多路查找树</h2></li>
</ul>
</li>
<li><p>多路查找树的意义</p>
<blockquote>
<p>对于树来说，一个结点只能存储一个元素，那么在元素非常多的时候，就会使得要么树的度非常大（结点拥有子树的个数的最大值），要么树的高度非常大，甚至两者都必须足够大才行，这就使得内存存取外存次数非常多，这显然成了时间效率上的瓶颈，这迫使我们要打破每一个结点只存储一个元素的限制，为此引入了多路查找树的概念</p>
</blockquote>
</li>
<li><p>2-3 树 </p>
<ul>
<li>每个结点都具有两个孩子（我们称它为 2 结点）或三个孩子（我们称它为 3 结点）的树</li>
<li>特性  <pre><code>      一个 2 结点 包含一个元素和两个孩子（或没有孩子），且左子树数据元素小于该元素右子树数据元素大于该元素
    一个 3 结点 包含一小一大两个元素和三个孩子（或没有孩子）
    如果有 3 个孩子的话
    左子树包含小于较小元素的元素
    右子树包含大于较大元素的元素
    中间子树包含介于两元素之间的元素</code></pre>
</li>
</ul>
</li>
<li><p>2-3-4 树</p>
</li>
<li><p>B 树</p>
<h2 id="5-6-树形问题和更多树。"><a href="#5-6-树形问题和更多树。" class="headerlink" title="5-6 树形问题和更多树。"></a>5-6 树形问题和更多树。</h2><ul>
<li>平衡二叉树和堆的结合Treap</li>
<li>trie ：查找效率与单词长度有关，与单词中的单词数量无关</li>
<li>其他树形(递归)问题：<ul>
<li>一条龙游戏</li>
<li>8 数码问题</li>
<li>8 皇后问题</li>
<li>数独</li>
<li>搬运工</li>
</ul>
</li>
<li>更多树的结构<ul>
<li>KD树</li>
<li>区间树</li>
<li>哈夫曼树</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第六章-并查集"><a href="#第六章-并查集" class="headerlink" title="第六章:并查集"></a>第六章:并查集</h1><h2 id="6-1-并查集基础"><a href="#6-1-并查集基础" class="headerlink" title="6-1 并查集基础"></a>6-1 并查集基础</h2><ul>
<li><p>解决的问题： </p>
<ul>
<li>连接问题， 数学中集合类的实现，</li>
<li>路径问题</li>
</ul>
</li>
<li><p>并查集的基本方法</p>
<ul>
<li>union(p,q) 将p与q 联合 （同属一个集合（连通分支））</li>
<li>find(p) 查找p所在集合序号</li>
<li>isConnect(p,q) </li>
</ul>
</li>
<li><p>并查集的实现</p>
<ul>
<li><p>数组实现（QuickFind） （数组索引为元素键值，数组值为对应的集合号）</p>
<ul>
<li>union(p,q) 需要遍历更新所有元素的集合号，时间复杂度O(n)</li>
<li>find(p) 直接数组下标查找，O(1) </li>
<li>isConnect()  复杂度O(1)</li>
</ul>
</li>
<li><p>树形实现（数组索引为元素键值，数组值为该节点的父节点的索引）</p>
<ul>
<li><p>union(p,q) 时间复杂度O(h)，h为树的高度 </p>
</li>
<li><p>find(p) 需要回溯到(所在分支的)跟节点，O(h)，h为树的高度 </p>
</li>
<li><p>isConnect()  复杂度O(h，h为树的高度 </p>
</li>
<li><p>树形实现中 union() 的三种实现方式（不断改进（降低）树的高度h）</p>
<ul>
<li>随机合并</li>
<li>基于size的优化 <ul>
<li>维护一个size数组，存每个分支的元素多少</li>
<li>将元素较少的树合并到元素较多的的树 新的分支size = size1 + size2</li>
</ul>
</li>
<li>基于rank的优化 <ul>
<li>维护一个rank数组，存每个分支对应树的高度</li>
<li>将高度小的和平到高度大的</li>
</ul>
</li>
</ul>
</li>
<li><p>find() 过程中的 路径压缩（降低树的高度）</p>
<ul>
<li><p>基本思想： 基于树形实现的并查集，在find()时，需要回溯到分支树的根节点，在回溯的过程，可以将树的高度进行调整。</p>
</li>
<li><p>具体实现思路： 回溯过程中，将当前节点的父节点不断向上更新</p>
</li>
<li><p>代码</p>
<pre><code class="cpp">// 查找过程, 查找元素p所对应的集合编号
// O(h)复杂度, h为树的高度
private int find(int p)&amp;#123;
  assert( p &gt;= 0 &amp;&amp; p &lt; count );

  // path compression 1
  while( p != parent[p] )&amp;#123;
      parent[p] = parent[parent[p]]; //指向父节点的父节点
      p = parent[p];
  &amp;#125;
  return p;

  // path compression 2, 递归算法
//            if( p != parent[p] )
//                parent[p] = find( parent[p] );
//            return parent[p];
&amp;#125;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>并查集的应用</p>
<ul>
<li>题目<ul>
<li>leetcode130_<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第七章-图"><a href="#第七章-图" class="headerlink" title="第七章: 图"></a>第七章: 图</h1><h2 id="7-1-图论基础"><a href="#7-1-图论基础" class="headerlink" title="7-1 图论基础"></a>7-1 图论基础</h2><ul>
<li>图的应用<ul>
<li>通信网路</li>
<li>社交网络</li>
<li>状态机等</li>
</ul>
</li>
<li>图的分类<ul>
<li>无权图与有权图</li>
<li>有向图与无向图</li>
</ul>
</li>
<li>图的表示<ul>
<li>（n,m） n个顶点，m条边</li>
<li>邻接矩阵 $n * n$矩阵 适合稠密图</li>
<li>邻接表  适合稀疏图</li>
<li>其他<h2 id="7-2-相邻点迭代器"><a href="#7-2-相邻点迭代器" class="headerlink" title="7-2 相邻点迭代器"></a>7-2 相邻点迭代器</h2></li>
</ul>
</li>
<li>图遍历过程中，避不开的便是遍历当前节点的相邻节点</li>
<li>迭代器的思想： 对外提供访问数据的功能，同时避免内部数据直接暴露在外</li>
<li>复杂度分析<ul>
<li>邻接矩阵 O(n) </li>
<li>邻接表 O(m)<h2 id="7-4-图的算法框架"><a href="#7-4-图的算法框架" class="headerlink" title="7-4 图的算法框架"></a>7-4 图的算法框架</h2></li>
</ul>
</li>
<li>读图方式（仅限本课程）<ul>
<li>不断添加边（需要知道顶点数）</li>
</ul>
</li>
</ul>
<h2 id="7-5-深度优先遍历和联通分量"><a href="#7-5-深度优先遍历和联通分量" class="headerlink" title="7-5 深度优先遍历和联通分量"></a>7-5 深度优先遍历和联通分量</h2><ul>
<li>深度优先遍历（DFS)<ul>
<li>基本思想 递归</li>
<li>复杂分析<ul>
<li>邻接表O（V+E）</li>
<li>邻接矩阵O(V^2)</li>
</ul>
</li>
</ul>
</li>
<li>求连通分支<ul>
<li>维护一个size为顶点数的vis数组 （可以存每个节点是否被访问，也可以每个节点存属于哪个分支）</li>
<li>对每一个没有被访问的节点进行深度优先遍历</li>
</ul>
</li>
<li>寻路<ul>
<li>维护一个from 数组 ，from[i]存第i个节点在dfs(s)过程中的上一个节点</li>
<li>从$s$ 节点开始 dfs()</li>
<li>从目的点d 开始，根据from数组回溯，得到s到d的路径<h2 id="7-7-广度优先遍历和最短路径"><a href="#7-7-广度优先遍历和最短路径" class="headerlink" title="7-7 广度优先遍历和最短路径"></a>7-7 广度优先遍历和最短路径</h2></li>
</ul>
</li>
<li>广度优先遍历<ul>
<li>基本思想 迭代</li>
<li>实现细节<ul>
<li><strong>处理环</strong>： 相对于树来说 图存在环的可能，所以遍历的时候是<strong>将加入队列的元素标记为已访问</strong>，而不是访问结点时才标记。</li>
</ul>
</li>
<li>复杂度分析<ul>
<li>邻接表O（V+E）</li>
<li>邻接矩阵O(V^2)</li>
</ul>
</li>
<li>求 无权图的 <strong>最短路径</strong><ul>
<li>维护一个from（回溯）数组，from[i]存第i个节点到dfs(s)过程中的上一个节点</li>
<li>维护一个order数组， order[i] 存 第i个节点在从s开始的bfs过程中的第几层（最短距离）</li>
<li>从$s$ 节点开始 bfs()</li>
<li>从 d 开始，根据from数组回溯<h2 id="7-8-更多无权图的应用"><a href="#7-8-更多无权图的应用" class="headerlink" title="7-8 更多无权图的应用"></a>7-8 更多无权图的应用</h2></li>
</ul>
</li>
</ul>
</li>
<li>迷宫生成，ps抠图等 </li>
</ul>
<hr>
<h1 id="第八章：最小生成树"><a href="#第八章：最小生成树" class="headerlink" title="第八章：最小生成树"></a>第八章：最小生成树</h1><h2 id="8-1-最小生成树问题和切分定理"><a href="#8-1-最小生成树问题和切分定理" class="headerlink" title="8-1 最小生成树问题和切分定理"></a>8-1 最小生成树问题和切分定理</h2><ul>
<li>最小生成树的应用<ul>
<li>电缆布线设计，网络设计，电路设计等。</li>
</ul>
</li>
<li>最小生成树的适用范围<ul>
<li>主要针对 带权 无向 连通图</li>
</ul>
</li>
<li>切分定理<ul>
<li>相关概念<ul>
<li>切分</li>
<li>横切边</li>
</ul>
</li>
<li><strong>切分定理</strong>： 给定任意切分，横切边中权值最小的边必然属于最小生成树<h2 id="8-2-Prim算法及其优化"><a href="#8-2-Prim算法及其优化" class="headerlink" title="8-2 Prim算法及其优化"></a>8-2 Prim算法及其优化</h2></li>
</ul>
</li>
<li>Lazy Prim 算法<ul>
<li>基本思想： 迭代/递归 贪心（每次根据切分定理得到局部最优） 动态规划？</li>
<li>算法流程<ul>
<li>递归/迭代遍历节点</li>
<li>将节点集合 分为  已经<strong>被访问过的节点</strong>和<strong>未被访问过的节点</strong>，并将切分这两个集合的<strong>横切边</strong>存入最小堆中 </li>
<li>每次选择最小堆中的横切边 出堆<ul>
<li>若 该横切边的两个端点均 已经被访问 ， 丢弃该边， 不做操作</li>
<li>否则， 将该边加入最小生成树中，继续<strong>遍历 该边中未被访问的点</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>lazy体现在（局限性）: <ul>
<li>最小堆中，维护的横切边中，有很多不再时横切边的 没有及时丢弃。</li>
<li>复杂度 O(ElogE)</li>
</ul>
</li>
</ul>
</li>
<li>Prim算法的优化<ul>
<li>用<strong>索引堆</strong> (pq)来维护 <ul>
<li>每个已经被访问的点对应的最小横切边 的权重。pq.get（i） 表示第i个节点关联的当前最小横切边权重</li>
<li>上述横切边集合中 的 最小横切边的权重 （最小中的最小） （及堆顶）</li>
<li>用 edgeTo 辅助维护 边的信息（起始点）</li>
</ul>
</li>
<li>用 vis 数组来维护 节点是否已被访问</li>
<li>Prim 算法流程<ul>
<li>初始化： 将起始点的横切边 的权值加入索引堆<strong>pq</strong>中，起始点标记为 已经被访问</li>
<li>循环：<ul>
<li>选<strong>pq</strong>中 最小权值的横切边<strong>e</strong> 加入到最小生成树的 边集合</li>
<li><strong>递归</strong> 选出来边<strong>e</strong>的两个端点中 未被访问的节点v：<ul>
<li>端点v 标记为 已经被访问</li>
<li>遍历端点v 的 邻接边<strong>adjEdge</strong>，邻接边的另一个端点<strong>w</strong><ul>
<li>保证**pq[w]**小（(与w节点关联的当前最小横切边的权重）<ul>
<li>若<strong>pq[w]</strong>) 为空，则将 <strong>adjEdge</strong> 的权重 更新至 <strong>pq[w]</strong></li>
<li>或者若<strong>adjEdge</strong>的权重小于 <strong>pq[w]</strong>  则将 <strong>adjEdge</strong> 的权重更新至<strong>pq[w]</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>复杂度分析 O(ElogV)</li>
</ul>
</li>
</ul>
<h2 id="8-3-Krusk算法"><a href="#8-3-Krusk算法" class="headerlink" title="8-3 Krusk算法"></a>8-3 Krusk算法</h2><ul>
<li>基本思想： 贪心 不断将<strong>不与已添加的边构成圈的最小边</strong> 加入到生成树边集合种</li>
<li>数据结构<ul>
<li>用最小堆，维护边集合，保证每次能取出剩余边中的最小边</li>
<li>用并查集，维护节点在当前生成树边集合下的连通度，判断新增边是否构成环</li>
</ul>
</li>
<li>算法流程<ul>
<li>对边进行排序(复杂度O(ElogE))，用最最小堆来维护边集合。</li>
<li>将最小边出堆，并加入生成树的集合。</li>
<li>循环开始：<ul>
<li>将 剩余边集合中 最小边 出堆<ul>
<li>判断改边与 生成树边集合中的边是否 构成环 （用并查集判断）<ul>
<li>若成环 抛弃， 继续找下一个边</li>
<li>将改边加入生成树的边集合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>复杂度分析 O(ElogE)<h2 id="8-6-最小生成树算法的思考"><a href="#8-6-最小生成树算法的思考" class="headerlink" title="8-6 最小生成树算法的思考"></a>8-6 最小生成树算法的思考</h2></li>
</ul>
</li>
<li>其他最小生成树的算法<ul>
<li>Vyssotsky’s Algorithm 将边逐渐添加到生成树中，一旦形成环，删除环中权值最大的边</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第九章：最短路径"><a href="#第九章：最短路径" class="headerlink" title="第九章：最短路径"></a>第九章：最短路径</h1><h2 id="9-1-最短路径问题和松弛操作"><a href="#9-1-最短路径问题和松弛操作" class="headerlink" title="9-1 最短路径问题和松弛操作"></a>9-1 最短路径问题和松弛操作</h2><h2 id="9-2-Dijkstra算法的思想"><a href="#9-2-Dijkstra算法的思想" class="headerlink" title="9-2 Dijkstra算法的思想"></a>9-2 Dijkstra算法的思想</h2><h2 id="9-3-实现Dijkstra算法"><a href="#9-3-实现Dijkstra算法" class="headerlink" title="9-3 实现Dijkstra算法"></a>9-3 实现Dijkstra算法</h2><h2 id="9-4-负权边和Bellman-Ford算法"><a href="#9-4-负权边和Bellman-Ford算法" class="headerlink" title="9-4 负权边和Bellman-Ford算法"></a>9-4 负权边和Bellman-Ford算法</h2><h2 id="9-5-实现Bellman-Ford算法"><a href="#9-5-实现Bellman-Ford算法" class="headerlink" title="9-5 实现Bellman-Ford算法"></a>9-5 实现Bellman-Ford算法</h2><h2 id="9-6-更多和最短路径相关的思考"><a href="#9-6-更多和最短路径相关的思考" class="headerlink" title="9-6 更多和最短路径相关的思考"></a>9-6 更多和最短路径相关的思考</h2><hr>
<h1 id="第十章：结束语"><a href="#第十章：结束语" class="headerlink" title="第十章：结束语"></a>第十章：结束语</h1>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LearnNotes/" rel="tag"># LearnNotes</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/12/markdown%E5%9F%BA%E7%A1%80/" rel="prev" title="markdown基础">
                  <i class="fa fa-chevron-left"></i> markdown基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/08/13/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

      








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  

  

</body>
</html>
