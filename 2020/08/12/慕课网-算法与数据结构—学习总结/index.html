<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="慕课网-算法与数据结构-学习总结     第一章 引言课程源码play-with-Algorithms 第二章 排序基础 排序的稳定性  排序后是否改变原序列键值相同的序列的先后关系 内排序与外排序  外排序： 由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行 。外部排序最常用的算法是多路归并排序 影响排序的三个方面   时间性能 比较 移动   辅助">
<meta property="og:type" content="article">
<meta property="og:title" content="慕课网-算法与数据结构—学习总结">
<meta property="og:url" content="http://yoursite.com/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="shytiger Blog">
<meta property="og:description" content="慕课网-算法与数据结构-学习总结     第一章 引言课程源码play-with-Algorithms 第二章 排序基础 排序的稳定性  排序后是否改变原序列键值相同的序列的先后关系 内排序与外排序  外排序： 由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行 。外部排序最常用的算法是多路归并排序 影响排序的三个方面   时间性能 比较 移动   辅助">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9TZWxlY3Rpb24tU29ydC1BbmltYXRpb24uZ2lm">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTAxNjU5NC0xNTBiNmM0NjJlM2VkODA5LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7779232-d19c19b7153b27b2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjIyOTk3LWIxYmIwNDg4NDlhMjI3YmUucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8wMy9zb3J0LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://img-blog.csdn.net/2018101109461342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pocTExODY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="article:published_time" content="2020-08-12T08:21:41.000Z">
<meta property="article:modified_time" content="2020-08-12T12:59:15.921Z">
<meta property="article:author" content="yan">
<meta property="article:tag" content="LearnNotes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9TZWxlY3Rpb24tU29ydC1BbmltYXRpb24uZ2lm">


<link rel="canonical" href="http://yoursite.com/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>慕课网-算法与数据结构—学习总结 | shytiger Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="shytiger Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">shytiger Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">第一章 引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8E%92%E5%BA%8F%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">第二章 排序基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">交换排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E6%94%B9%E8%BF%9B"><span class="nav-number">2.3.</span> <span class="nav-text">插入排序及其改进</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">第三章 高级排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">归并排序及其优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">3.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%A1%8D%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">归并排序和快速排序衍生的问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">第四章 堆和堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%AE%A4%E8%AF%86"><span class="nav-number">4.1.</span> <span class="nav-text">基本概念认识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AD%98%E5%82%A8"><span class="nav-number">4.2.</span> <span class="nav-text">堆的基本存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heapfy%E8%BF%87%E7%A8%8B%EF%BC%88%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%89"><span class="nav-number">4.2.1.</span> <span class="nav-text">heapfy过程（堆的建立）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ShiftUp"><span class="nav-number">4.3.</span> <span class="nav-text">ShiftUp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ShiftDown"><span class="nav-number">4.4.</span> <span class="nav-text">ShiftDown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96"><span class="nav-number">4.5.</span> <span class="nav-text">堆排序及其优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A0%86"><span class="nav-number">4.6.</span> <span class="nav-text">索引堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%89%E5%8F%8A%E5%A0%86-%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">4.7.</span> <span class="nav-text">涉及堆 的相关问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">4.8.</span> <span class="nav-text">桶排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="nav-number">4.9.</span> <span class="nav-text">排序总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">第五章 二分搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">5-1 二分查找法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E5%9F%BA%E7%A1%80"><span class="nav-number">5.2.</span> <span class="nav-text">5-2 二分搜索树基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5"><span class="nav-number">5.3.</span> <span class="nav-text">5-3 二分搜索树的节点插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E4%B9%A6%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">5.4.</span> <span class="nav-text">5-4 二分搜索书的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%89"><span class="nav-number">5.5.</span> <span class="nav-text">5-5 二分搜索树的遍历（深度优先遍历）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%89"><span class="nav-number">5.6.</span> <span class="nav-text">5-6 层序遍历（广度优先遍历）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">5.7.</span> <span class="nav-text">5-7 删除最大值，最小值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">5.8.</span> <span class="nav-text">5-8 二分搜索树的删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="nav-number">5.9.</span> <span class="nav-text">5-9 二分搜索树的顺序性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-10-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">5.10.</span> <span class="nav-text">5-10 二分搜索树的局限性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-11-%E6%A0%91%E5%BD%A2%E9%97%AE%E9%A2%98%E5%92%8C%E6%9B%B4%E5%A4%9A%E6%A0%91%E3%80%82"><span class="nav-number">5.11.</span> <span class="nav-text">5-11 树形问题和更多树。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">6.</span> <span class="nav-text">第六章:并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9F%BA%E7%A1%80"><span class="nav-number">6.1.</span> <span class="nav-text">6-1 并查集基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Qucik-Find"><span class="nav-number">6.2.</span> <span class="nav-text">6-2 Qucik Find</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-Quick-Union"><span class="nav-number">6.3.</span> <span class="nav-text">6-3 Quick Union</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%9F%BA%E4%BA%8Esize%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">6.4.</span> <span class="nav-text">6-4 基于size的优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E5%9F%BA%E4%BA%8Erank%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">6.5.</span> <span class="nav-text">6-5 基于rank的优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="nav-number">6.6.</span> <span class="nav-text">6-6 路径压缩</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0"><span class="nav-number">7.</span> <span class="nav-text">第七章:</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">7.1.</span> <span class="nav-text">7-1 图论基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">7.2.</span> <span class="nav-text">7-2 图的表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E7%9B%B8%E9%82%BB%E7%82%B9%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">7.3.</span> <span class="nav-text">7-3 相邻点迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E5%9B%BE%E7%9A%84%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="nav-number">7.4.</span> <span class="nav-text">7-4 图的算法框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">7.5.</span> <span class="nav-text">7-5 深度优先遍历和联通分量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-%E5%AF%BB%E8%B7%AF"><span class="nav-number">7.6.</span> <span class="nav-text">7-6 寻路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">7.7.</span> <span class="nav-text">7-7 广度优先遍历和最短路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-%E8%BF%B7%E5%AE%AB%E7%94%9F%E6%88%90%EF%BC%8Cps%E6%8A%A0%E5%9B%BE%E2%80%93%E6%9B%B4%E5%A4%9A%E6%97%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">7.8.</span> <span class="nav-text">7-8 迷宫生成，ps抠图–更多无权图的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">第八章：最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-%E6%9C%89%E6%9D%83%E5%9B%BE"><span class="nav-number">8.1.</span> <span class="nav-text">8-1 有权图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E5%92%8C%E5%88%87%E5%88%86%E5%AE%9A%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">8-2 最小生成树问题和切分定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-Prim%E7%AE%97%E6%B3%95%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.</span> <span class="nav-text">8-3 Prim算法的第一个实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-Prim%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">8.4.</span> <span class="nav-text">8-4 Prim算法的优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84Prim%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.5.</span> <span class="nav-text">8-5 优化后的Prim算法的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-Krusk%E7%AE%97%E6%B3%95"><span class="nav-number">8.6.</span> <span class="nav-text">8-6 Krusk算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">8.7.</span> <span class="nav-text">8-7 最小生成树算法的思考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">9.</span> <span class="nav-text">第九章：最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%92%8C%E6%9D%BE%E5%BC%9B%E6%93%8D%E4%BD%9C"><span class="nav-number">9.1.</span> <span class="nav-text">9-1 最短路径问题和松弛操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-Dijkstra%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3"><span class="nav-number">9.2.</span> <span class="nav-text">9-2 Dijkstra算法的思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-%E5%AE%9E%E7%8E%B0Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">9.3.</span> <span class="nav-text">9-3 实现Dijkstra算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-%E8%B4%9F%E6%9D%83%E8%BE%B9%E5%92%8CBellman-Ford%E7%AE%97%E6%B3%95"><span class="nav-number">9.4.</span> <span class="nav-text">9-4 负权边和Bellman-Ford算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-%E5%AE%9E%E7%8E%B0Bellman-Ford%E7%AE%97%E6%B3%95"><span class="nav-number">9.5.</span> <span class="nav-text">9-5 实现Bellman-Ford算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-%E6%9B%B4%E5%A4%9A%E5%92%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">9.6.</span> <span class="nav-text">9-6 更多和最短路径相关的思考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="nav-number">10.</span> <span class="nav-text">第十章：结束语</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shytiger Blog">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          慕课网-算法与数据结构—学习总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-12 16:21:41 / Modified: 20:59:15" itemprop="dateCreated datePublished" datetime="2020-08-12T16:21:41+08:00">2020-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p><strong>慕课网-算法与数据结构-学习总结</strong>  </p>
</blockquote>
<hr>
<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p><a target="_blank" rel="noopener" href="https://github.com/liuyubobobo/Play-with-Algorithms">课程源码play-with-Algorithms</a></p>
<h1 id="第二章-排序基础"><a href="#第二章-排序基础" class="headerlink" title="第二章 排序基础"></a>第二章 排序基础</h1><ul>
<li><strong>排序的稳定性</strong><br>  排序后是否改变原序列键值相同的序列的先后关系</li>
<li><strong>内排序与外排序</strong><br>  外排序： 由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行 。外部排序最常用的算法是多路归并排序</li>
<li><strong>影响排序的三个方面</strong>  <ul>
<li>时间性能<ul>
<li>比较</li>
<li>移动</li>
</ul>
</li>
<li>辅助空间</li>
<li>算法复杂度  <h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2></li>
</ul>
</li>
</ul>
<ul>
<li><p>冒泡排序</p>
<ul>
<li>基本思想：两两交换，将最大（或最小）的交换至队列前  <h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2></li>
</ul>
</li>
<li><p>简单选择排序  </p>
<ul>
<li>基本思想：在未排序的序列种找到最小（或最大）的元素放到前面  </li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9TZWxlY3Rpb24tU29ydC1BbmltYXRpb24uZ2lm" alt="动画演示">  </li>
</ul>
</li>
<li><p>参考实现代码（cpp）</p>
<pre><code>    template&lt;typename T&gt;
    void selectionSort(T arr[], int n)&amp;#123;

        for(int i = 0 ; i &lt; n ; i ++)&amp;#123;

            int minIndex = i;
            for( int j = i + 1 ; j &lt; n ; j ++ )
                if( arr[j] &lt; arr[minIndex] )
                    minIndex = j;

            swap( arr[i] , arr[minIndex] );
        &amp;#125;
    &amp;#125;</code></pre>
</li>
<li><p>直接选择排序  </p>
</li>
<li><p>树型选择排序</p>
</li>
</ul>
<h2 id="插入排序及其改进"><a href="#插入排序及其改进" class="headerlink" title="插入排序及其改进"></a>插入排序及其改进</h2><ul>
<li><p>直接插入排序  </p>
<ul>
<li><p>基本思想: 将未排序的元素插入到已经排好序的队列种对应的位置</p>
</li>
<li><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTAxNjU5NC0xNTBiNmM0NjJlM2VkODA5LnBuZw?x-oss-process=image/format,png" alt="示意图">  </p>
</li>
<li><p>代码</p>
<pre><code>template&lt;typename T&gt;
void insertionSort(T arr[], int n)&amp;#123;
    for( int i = 1 ; i &lt; n ; i ++ ) &amp;#123;

    // 寻找元素arr[i]合适的插入位置
    // 写法1
    //        for( int j = i ; j &gt; 0 ; j-- )
    //            if( arr[j] &lt; arr[j-1] )
    //                swap( arr[j] , arr[j-1] );
    //            else
    //                break;

    // 写法2
    //        for( int j = i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )
    //            swap( arr[j] , arr[j-1] );

    // 写法3
                T e = arr[i];
                int j; // j保存元素e应该插入的位置
                for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; e; j--)
                    arr[j] = arr[j-1];
                arr[j] = e;
    &amp;#125;
    return;
&amp;#125;</code></pre>
</li>
<li><p>改进：   </p>
<ul>
<li><p><strong>折半插入排序：</strong> 找到已排好序种对应位置时 用 折半查找   </p>
</li>
<li><p><strong>希尔排序</strong>:</p>
<ul>
<li><p>基本思想：交换不相邻的元素以对数组的<strong>局部</strong>进行排序</p>
</li>
<li><p><img src="https://upload-images.jianshu.io/upload_images/7779232-d19c19b7153b27b2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp"></p>
</li>
<li><p>第一个O(n log n)的排序算法</p>
</li>
<li><p>参考代码</p>
<pre><code>template&lt;typename T&gt;
void shellSort(T arr[], int n)&amp;#123;

    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...
    int h = 1;
    while( h &lt; n/3 )
        h = 3 * h + 1;

    while( h &gt;= 1 )&amp;#123;

        // h-sort the array
        for( int i = h ; i &lt; n ; i ++ )&amp;#123;

            // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序
            T e = arr[i];
            int j;
            for( j = i ; j &gt;= h &amp;&amp; e &lt; arr[j-h] ; j -= h )
                arr[j] = arr[j-h];
            arr[j] = e;
        &amp;#125;

        h /= 3;
    &amp;#125;
&amp;#125;</code></pre>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/642b19f8a69c">希尔排序及其优化</a>  </p>
</li>
</ul>
</li>
<li><p>其他： 路插入排序,表插入排序等。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第三章-高级排序问题"><a href="#第三章-高级排序问题" class="headerlink" title="第三章 高级排序问题"></a>第三章 高级排序问题</h1><h2 id="归并排序及其优化"><a href="#归并排序及其优化" class="headerlink" title="归并排序及其优化"></a>归并排序及其优化</h2><ul>
<li><p>基本思想： (分治)将排序序列差分成 两个等长的子序列，对子序列进行排序后再归并</p>
</li>
<li><p>参考核心代码(cpp)</p>
<pre><code>    // 使用优化的归并排序算法, 对arr[l...r]的范围进行排序
    template&lt;typename T&gt;
    void __mergeSort2(T arr[], int l, int r)&amp;#123;

        // 优化2: 对于小规模数组, 使用插入排序
        if( r - l &lt;= 15 )&amp;#123;
            insertionSort(arr, l, r);
            return;
        &amp;#125;

        int mid = (l+r)/2;
        __mergeSort2(arr, l, mid);
        __mergeSort2(arr, mid+1, r);

        // 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge
        // 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失
        if( arr[mid] &gt; arr[mid+1] )
            __merge(arr, l, mid, r);
    &amp;#125;</code></pre>
</li>
<li><p>优化点：    </p>
<pre><code>- 当排序的元素少于一定（16）时，直接调用 插入排序  
- 如果第一个序列的最大值小于第二个序列的最小值，则不用比较，直接合并  </code></pre>
<ul>
<li><p>归并排序的自底向上写法（迭代）  </p>
</li>
<li><p><strong>核心代码参考</strong>    </p>
<pre><code>  ```        

  // 使用自底向上的归并排序算法
  template &lt;typename T&gt;
  void mergeSortBU(T arr[], int n)&amp;#123;
      // Merge Sort Bottom Up 优化
      // 对于小数组, 使用插入排序优化
      for( int i = 0 ; i &lt; n ; i += 16 )
          insertionSort(arr,i,min(i+15,n-1));

      for( int sz = 16; sz &lt; n ; sz += sz )
          for( int i = 0 ; i &lt; n - sz ; i += sz+sz )
              // 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge
              if( arr[i+sz-1] &gt; arr[i+sz] )
                  __merge(arr, i, i+sz-1, min(i+sz+sz-1,n-1) );
      // Merge Sort BU 也是一个O(nlogn)复杂度的算法，虽然只使用两重for循环
      // 所以，Merge Sort BU也可以在1秒之内轻松处理100万数量级的数据
      // 注意：不要轻易根据循环层数来判断算法的复杂度，Merge Sort BU就是一个反例
      // 关于这部分陷阱，推荐看（liubobo老师）的《玩转算法面试》课程，第二章：《面试中的复杂度分析》：）
  &amp;#125;
  ```</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></li>
</ul>
</li>
<li><p>基本思想： （分治） 将选定的元素放到合适的位置，然后 递归 排序 被该元素分开的 前 后 两个子序列。(分出来的两个子序列可能不等长，相差很大，会影响性能)</p>
</li>
<li><p>核心代码参考  </p>
<pre><code>```
// 对arr[l...r]部分进行partition操作
// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]
template &lt;typename T&gt;
int _partition(T arr[], int l, int r)&amp;#123;

    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    swap( arr[l] , arr[rand()%(r-l+1)+l] );

    T v = arr[l];
    int j = l;
    for( int i = l + 1 ; i &lt;= r ; i ++ )
        if( arr[i] &lt; v )&amp;#123;
            j ++;
            swap( arr[j] , arr[i] );
        &amp;#125;

    swap( arr[l] , arr[j]);

    return j;
&amp;#125;

// 对arr[l...r]部分进行快速排序
template &lt;typename T&gt;
void _quickSort(T arr[], int l, int r)&amp;#123;

    // 对于小规模数组, 使用插入排序进行优化
    if( r - l &lt;= 15 )&amp;#123;
        insertionSort(arr,l,r);
        return;
    &amp;#125;

    int p = _partition(arr, l, r);
    _quickSort(arr, l, p-1 );
    _quickSort(arr, p+1, r);
&amp;#125;
```</code></pre>
</li>
<li><p>优化：  </p>
<pre><code>1. 标定点 随机选（针对基本有序的序列，如果固定选最前面的元素，则分治的两个子问题不平衡，退化为O(n^2)的复杂度）  
2. 小规模排序，使用插入排序</code></pre>
</li>
<li><p>双路快排  </p>
<ul>
<li><p>基本思想：针对键值重复过多时，分治的两个子序列不等长，导致分治不平衡</p>
</li>
<li><p>核心代码参考</p>
<pre><code>// 双路快速排序的partition
// 返回p, 使得arr[l...p-1] &lt;= arr[p] ; arr[p+1...r] &gt;= arr[p]
// 双路快排处理的元素正好等于arr[p]的时候要注意，详见下面的注释：）
template &lt;typename T&gt;
int _partition2(T arr[], int l, int r)&amp;#123;

    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    swap( arr[l] , arr[rand()%(r-l+1)+l] );
    T v = arr[l];

    // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v
    int i = l+1, j = r;
    while( true )&amp;#123;
        // 注意这里的边界, arr[i] &lt; v, 不能是arr[i] &lt;= v
        // 思考一下为什么?
        while( i &lt;= r &amp;&amp; arr[i] &lt; v )
            i ++;

        // 注意这里的边界, arr[j] &gt; v, 不能是arr[j] &gt;= v
        // 思考一下为什么?
        while( j &gt;= l+1 &amp;&amp; arr[j] &gt; v )
            j --;

        // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)
        // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html

        if( i &gt; j )
            break;

        swap( arr[i] , arr[j] );
        i ++;
        j --;
    &amp;#125;

    swap( arr[l] , arr[j]);

    return j;
&amp;#125;

// 对arr[l...r]部分进行快速排序
template &lt;typename T&gt;
void _quickSort(T arr[], int l, int r)&amp;#123;

    // 对于小规模数组, 使用插入排序进行优化
    if( r - l &lt;= 15 )&amp;#123;
        insertionSort(arr,l,r);
        return;
    &amp;#125;

    // 调用双路快速排序的partition
    int p = _partition2(arr, l, r);
    _quickSort(arr, l, p-1 );
    _quickSort(arr, p+1, r);
&amp;#125;</code></pre>
</li>
</ul>
</li>
<li><p>三路快排 </p>
<ul>
<li><p>基本思想： 针对2路快排的加强，进一步解决键值重复过多的问题（增加一个等值区域）</p>
</li>
<li><p>核心代码参考</p>
<pre><code>// 递归的三路快速排序算法
template &lt;typename T&gt;
void __quickSort3Ways(T arr[], int l, int r)&amp;#123;

    // 对于小规模数组, 使用插入排序进行优化
    if( r - l &lt;= 15 )&amp;#123;
        insertionSort(arr,l,r);
        return;
    &amp;#125;

    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    swap( arr[l], arr[rand()%(r-l+1)+l ] );

    T v = arr[l];

    int lt = l;     // arr[l+1...lt] &lt; v
    int gt = r + 1; // arr[gt...r] &gt; v
    int i = l+1;    // arr[lt+1...i) == v
    while( i &lt; gt )&amp;#123;
        if( arr[i] &lt; v )&amp;#123;
            swap( arr[i], arr[lt+1]);
            i ++;
            lt ++;
        &amp;#125;
        else if( arr[i] &gt; v )&amp;#123;
            swap( arr[i], arr[gt-1]);
            gt --;
        &amp;#125;
        else&amp;#123; // arr[i] == v
            i ++;
        &amp;#125;
    &amp;#125;

    swap( arr[l] , arr[lt] );

    __quickSort3Ways(arr, l, lt-1);
    __quickSort3Ways(arr, gt, r);
&amp;#125;

template &lt;typename T&gt;
void quickSort3Ways(T arr[], int n)&amp;#123;

    srand(time(NULL));
    __quickSort3Ways( arr, 0, n-1);
&amp;#125;
// 比较Merge Sort和双路快速排序和三路快排三种排序算法的性能效率
// 对于包含有大量重复数据的数组, 三路快排有巨大的优势
// 对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围里
// 因此, 在一些语言中, 三路快排是默认的语言库函数中使用的排序算法。比如Java:)</code></pre>
<h2 id="归并排序和快速排序衍生的问题"><a href="#归并排序和快速排序衍生的问题" class="headerlink" title="归并排序和快速排序衍生的问题"></a>归并排序和快速排序衍生的问题</h2></li>
</ul>
<ul>
<li>求逆序对（归并排序）</li>
<li>求数组中的第N大元素</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第四章-堆和堆排序"><a href="#第四章-堆和堆排序" class="headerlink" title="第四章 堆和堆排序"></a>第四章 堆和堆排序</h1><h2 id="基本概念认识"><a href="#基本概念认识" class="headerlink" title="基本概念认识"></a>基本概念认识</h2><ul>
<li>队列<ul>
<li>普通队列：先进先出</li>
<li>优先队列：根据优先级出队  </li>
</ul>
</li>
<li><strong>优先队列应用</strong>  对动态的数据排序  </li>
<li>优先队列的三种实现方式  <table>
<thead>
<tr>
<th align="left">实现方式</th>
<th align="left">入队</th>
<th align="left">出队</th>
</tr>
</thead>
<tbody><tr>
<td align="left">普通数组</td>
<td align="left">O(1)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">顺序数组(元素有序)</td>
<td align="left">O(n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">堆</td>
<td align="left">O(log n)</td>
<td align="left">O(log n)</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="堆的基本存储"><a href="#堆的基本存储" class="headerlink" title="堆的基本存储"></a>堆的基本存储</h2><pre><code>* 用数组存储二叉堆
* 数组的索引次序 对应 二叉堆中 层序遍历次序
* 对于完全二叉树,对第i个元素，其与其父，其子的关系（第一个元素根的索引为0）
    * parent(i) = （i-1）/2
    * left child (i) = 2*i +1
    * right child (i) = 2*i + 2</code></pre>
<h3 id="heapfy过程（堆的建立）"><a href="#heapfy过程（堆的建立）" class="headerlink" title="heapfy过程（堆的建立）"></a>heapfy过程（堆的建立）</h3><pre><code>将n个元素逐个插入空堆中，算法复杂度为O(n log n),而heapfy过程算法复杂度O(n)  
- 代码
```
    // 构造函数, 通过一个给定数组创建一个最大堆
    // 该构造堆的过程, 时间复杂度为O(n)
    MaxHeap(Item arr[], int n)&amp;#123;
        data = new Item[n+1];
        capacity = n;

        for( int i = 0 ; i &lt; n ; i ++ )
            data[i+1] = arr[i];
        count = n;

        for( int i = count/2 ; i &gt;= 1 ; i -- )
            shiftDown(i);
    &amp;#125;
```</code></pre>
<h2 id="ShiftUp"><a href="#ShiftUp" class="headerlink" title="ShiftUp"></a>ShiftUp</h2><pre><code>- 代码
    ```
        void shiftUp(int k)&amp;#123;
        while( k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] )&amp;#123;
            swap( data[k/2], data[k] );
            k /= 2;
        &amp;#125;
        &amp;#125;
    ``` </code></pre>
<h2 id="ShiftDown"><a href="#ShiftDown" class="headerlink" title="ShiftDown"></a>ShiftDown</h2><pre><code>- 代码
```
    void shiftDown(int k)&#123;
    while( 2*k &lt;= count )&#123;
        int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置
        if( j+1 &lt;= count &amp;&amp; data[j+1] &gt; data[j] )
            j ++;
        // data[j] 是 data[2*k]和data[2*k+1]中的最大值

        if( data[k] &gt;= data[j] ) break;
        swap( data[k] , data[j] );
        k = j;
    &#125;
    &#125;
```</code></pre>
<h2 id="堆排序及其优化"><a href="#堆排序及其优化" class="headerlink" title="堆排序及其优化"></a>堆排序及其优化</h2><pre><code>* 堆排序算法：
    * 创建堆  
    * 堆顶出堆： 将堆顶与堆尾互换，堆的size-1,并将新的堆顶（原堆尾）shiftDown()
    * 重复第二步  
* 堆排序的代码
    ```
            // heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序
            // 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)
            // 整个堆排序的整体时间复杂度为O(nlogn)
            template&lt;typename T&gt;
            void heapSort1(T arr[], int n)&#123;

                MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);
                for( int i = 0 ; i &lt; n ; i ++ )
                    maxheap.insert(arr[i]);

                for( int i = n-1 ; i &gt;= 0 ; i-- )
                    arr[i] = maxheap.extractMax();

            &#125;


            // heapSort2, 借助我们的heapify过程创建堆
            // 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 实践复杂度为O(nlogn)
            // 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优
    ```
* 堆的实现细节
    *ShiftUp和ShiftDown种使用复制操作替换swap操作*  </code></pre>
<h2 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h2><ul>
<li>基本思想： 交换索引（存储地址），而不交换实际的元素</li>
<li>应用： 最小生成树Prim算法中，用来维护 每个节点对应的最小横切面的权重【同时能输出当前所有节点最小横切面中的最小横切面】<h2 id="涉及堆-的相关问题"><a href="#涉及堆-的相关问题" class="headerlink" title="涉及堆 的相关问题"></a>涉及堆 的相关问题</h2><ul>
<li>多路归并排序 多个元素同时比较的时候用，最小（大）堆</li>
<li>d叉堆 d-ary heap  </li>
<li>最大最小队列 （最大堆和最小堆同时维护？？）</li>
<li>二项堆</li>
<li>斐波那契堆</li>
</ul>
</li>
</ul>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><pre><code>基本思想： 分配 + 收集 （先排序低位再排序高位）</code></pre>
<h2 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h2><table>
<thead>
<tr>
<th align="left">排序</th>
<th align="left">平均时间复杂度</th>
<th align="left">原地排序</th>
<th align="left">额外空间</th>
<th align="left">稳定排序</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入排序（Insertion Sort）</td>
<td align="left">O(n^2)</td>
<td align="left">是</td>
<td align="left">O(1)</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">归并排序(Merge Sort)</td>
<td align="left">O（nlogn）</td>
<td align="left">否</td>
<td align="left">O(n)</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">快速排序（Quick Sort）</td>
<td align="left">O(nlogn)</td>
<td align="left">是</td>
<td align="left"><strong>O（logn）</strong></td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">堆排序（Heap Sort)</td>
<td align="left">O(nlogn)</td>
<td align="left">是</td>
<td align="left">O(1)</td>
<td align="left">否</td>
</tr>
</tbody></table>
<ul>
<li><strong>不同排序算法的选择</strong>  <ul>
<li>n较小：直接插入排序或直接选择排序</li>
<li>基本有序序列，直接插入，冒泡，随机的快速排序</li>
<li>n较大，应选复杂度好的：快速排序，归并排序， 堆排序。<ul>
<li>快速排序性能平均最好，堆排序更少的辅助空间，归并排序是稳定的排序。（当排序数少于一定时如16，<strong>调用直接插入排序</strong>）</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<p><strong>其他参考</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjIyOTk3LWIxYmIwNDg4NDlhMjI3YmUucG5n?x-oss-process=image/format,png" alt="排序算法总结"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8wMy9zb3J0LnBuZw?x-oss-process=image/format,png" alt="排序对比"><br><img src="https://img-blog.csdn.net/2018101109461342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pocTExODY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/liu17234050/article/details/104217658">C语言中的14种排序</a><br>[14中排序动画演示](<a target="_blank" rel="noopener" href="https://v.qq.com/x/page/e0523qakza6.html%EF%BC%89">https://v.qq.com/x/page/e0523qakza6.html）</a>  </p>
<hr>
<h1 id="第五章-二分搜索树"><a href="#第五章-二分搜索树" class="headerlink" title="第五章 二分搜索树"></a>第五章 二分搜索树</h1><h2 id="5-1-二分查找法"><a href="#5-1-二分查找法" class="headerlink" title="5-1 二分查找法"></a>5-1 二分查找法</h2><h2 id="5-2-二分搜索树基础"><a href="#5-2-二分搜索树基础" class="headerlink" title="5-2 二分搜索树基础"></a>5-2 二分搜索树基础</h2><h2 id="5-3-二分搜索树的节点插入"><a href="#5-3-二分搜索树的节点插入" class="headerlink" title="5-3 二分搜索树的节点插入"></a>5-3 二分搜索树的节点插入</h2><h2 id="5-4-二分搜索书的查找"><a href="#5-4-二分搜索书的查找" class="headerlink" title="5-4 二分搜索书的查找"></a>5-4 二分搜索书的查找</h2><h2 id="5-5-二分搜索树的遍历（深度优先遍历）"><a href="#5-5-二分搜索树的遍历（深度优先遍历）" class="headerlink" title="5-5 二分搜索树的遍历（深度优先遍历）"></a>5-5 二分搜索树的遍历（深度优先遍历）</h2><h2 id="5-6-层序遍历（广度优先遍历）"><a href="#5-6-层序遍历（广度优先遍历）" class="headerlink" title="5-6 层序遍历（广度优先遍历）"></a>5-6 层序遍历（广度优先遍历）</h2><h2 id="5-7-删除最大值，最小值"><a href="#5-7-删除最大值，最小值" class="headerlink" title="5-7 删除最大值，最小值"></a>5-7 删除最大值，最小值</h2><h2 id="5-8-二分搜索树的删除"><a href="#5-8-二分搜索树的删除" class="headerlink" title="5-8 二分搜索树的删除"></a>5-8 二分搜索树的删除</h2><h2 id="5-9-二分搜索树的顺序性"><a href="#5-9-二分搜索树的顺序性" class="headerlink" title="5-9 二分搜索树的顺序性"></a>5-9 二分搜索树的顺序性</h2><h2 id="5-10-二分搜索树的局限性"><a href="#5-10-二分搜索树的局限性" class="headerlink" title="5-10 二分搜索树的局限性"></a>5-10 二分搜索树的局限性</h2><h2 id="5-11-树形问题和更多树。"><a href="#5-11-树形问题和更多树。" class="headerlink" title="5-11 树形问题和更多树。"></a>5-11 树形问题和更多树。</h2><hr>
<h1 id="第六章-并查集"><a href="#第六章-并查集" class="headerlink" title="第六章:并查集"></a>第六章:并查集</h1><h2 id="6-1-并查集基础"><a href="#6-1-并查集基础" class="headerlink" title="6-1 并查集基础"></a>6-1 并查集基础</h2><h2 id="6-2-Qucik-Find"><a href="#6-2-Qucik-Find" class="headerlink" title="6-2 Qucik Find"></a>6-2 Qucik Find</h2><h2 id="6-3-Quick-Union"><a href="#6-3-Quick-Union" class="headerlink" title="6-3 Quick Union"></a>6-3 Quick Union</h2><h2 id="6-4-基于size的优化"><a href="#6-4-基于size的优化" class="headerlink" title="6-4 基于size的优化"></a>6-4 基于size的优化</h2><h2 id="6-5-基于rank的优化"><a href="#6-5-基于rank的优化" class="headerlink" title="6-5 基于rank的优化"></a>6-5 基于rank的优化</h2><h2 id="6-6-路径压缩"><a href="#6-6-路径压缩" class="headerlink" title="6-6 路径压缩"></a>6-6 路径压缩</h2><hr>
<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章:"></a>第七章:</h1><h2 id="7-1-图论基础"><a href="#7-1-图论基础" class="headerlink" title="7-1 图论基础"></a>7-1 图论基础</h2><h2 id="7-2-图的表示"><a href="#7-2-图的表示" class="headerlink" title="7-2 图的表示"></a>7-2 图的表示</h2><h2 id="7-3-相邻点迭代器"><a href="#7-3-相邻点迭代器" class="headerlink" title="7-3 相邻点迭代器"></a>7-3 相邻点迭代器</h2><h2 id="7-4-图的算法框架"><a href="#7-4-图的算法框架" class="headerlink" title="7-4 图的算法框架"></a>7-4 图的算法框架</h2><h2 id="7-5-深度优先遍历和联通分量"><a href="#7-5-深度优先遍历和联通分量" class="headerlink" title="7-5 深度优先遍历和联通分量"></a>7-5 深度优先遍历和联通分量</h2><h2 id="7-6-寻路"><a href="#7-6-寻路" class="headerlink" title="7-6 寻路"></a>7-6 寻路</h2><h2 id="7-7-广度优先遍历和最短路径"><a href="#7-7-广度优先遍历和最短路径" class="headerlink" title="7-7 广度优先遍历和最短路径"></a>7-7 广度优先遍历和最短路径</h2><h2 id="7-8-迷宫生成，ps抠图–更多无权图的应用"><a href="#7-8-迷宫生成，ps抠图–更多无权图的应用" class="headerlink" title="7-8 迷宫生成，ps抠图–更多无权图的应用"></a>7-8 迷宫生成，ps抠图–更多无权图的应用</h2><hr>
<h1 id="第八章：最小生成树"><a href="#第八章：最小生成树" class="headerlink" title="第八章：最小生成树"></a>第八章：最小生成树</h1><h2 id="8-1-有权图"><a href="#8-1-有权图" class="headerlink" title="8-1 有权图"></a>8-1 有权图</h2><h2 id="8-2-最小生成树问题和切分定理"><a href="#8-2-最小生成树问题和切分定理" class="headerlink" title="8-2 最小生成树问题和切分定理"></a>8-2 最小生成树问题和切分定理</h2><h2 id="8-3-Prim算法的第一个实现"><a href="#8-3-Prim算法的第一个实现" class="headerlink" title="8-3 Prim算法的第一个实现"></a>8-3 Prim算法的第一个实现</h2><h2 id="8-4-Prim算法的优化"><a href="#8-4-Prim算法的优化" class="headerlink" title="8-4 Prim算法的优化"></a>8-4 Prim算法的优化</h2><h2 id="8-5-优化后的Prim算法的实现"><a href="#8-5-优化后的Prim算法的实现" class="headerlink" title="8-5 优化后的Prim算法的实现"></a>8-5 优化后的Prim算法的实现</h2><h2 id="8-6-Krusk算法"><a href="#8-6-Krusk算法" class="headerlink" title="8-6 Krusk算法"></a>8-6 Krusk算法</h2><h2 id="8-7-最小生成树算法的思考"><a href="#8-7-最小生成树算法的思考" class="headerlink" title="8-7 最小生成树算法的思考"></a>8-7 最小生成树算法的思考</h2><hr>
<h1 id="第九章：最短路径"><a href="#第九章：最短路径" class="headerlink" title="第九章：最短路径"></a>第九章：最短路径</h1><h2 id="9-1-最短路径问题和松弛操作"><a href="#9-1-最短路径问题和松弛操作" class="headerlink" title="9-1 最短路径问题和松弛操作"></a>9-1 最短路径问题和松弛操作</h2><h2 id="9-2-Dijkstra算法的思想"><a href="#9-2-Dijkstra算法的思想" class="headerlink" title="9-2 Dijkstra算法的思想"></a>9-2 Dijkstra算法的思想</h2><h2 id="9-3-实现Dijkstra算法"><a href="#9-3-实现Dijkstra算法" class="headerlink" title="9-3 实现Dijkstra算法"></a>9-3 实现Dijkstra算法</h2><h2 id="9-4-负权边和Bellman-Ford算法"><a href="#9-4-负权边和Bellman-Ford算法" class="headerlink" title="9-4 负权边和Bellman-Ford算法"></a>9-4 负权边和Bellman-Ford算法</h2><h2 id="9-5-实现Bellman-Ford算法"><a href="#9-5-实现Bellman-Ford算法" class="headerlink" title="9-5 实现Bellman-Ford算法"></a>9-5 实现Bellman-Ford算法</h2><h2 id="9-6-更多和最短路径相关的思考"><a href="#9-6-更多和最短路径相关的思考" class="headerlink" title="9-6 更多和最短路径相关的思考"></a>9-6 更多和最短路径相关的思考</h2><hr>
<h1 id="第十章：结束语"><a href="#第十章：结束语" class="headerlink" title="第十章：结束语"></a>第十章：结束语</h1>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LearnNotes/" rel="tag"># LearnNotes</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/12/markdown%E5%9F%BA%E7%A1%80/" rel="prev" title="markdown基础">
                  <i class="fa fa-chevron-left"></i> markdown基础
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
      </footer>
    
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

      








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  

  

</body>
</html>
