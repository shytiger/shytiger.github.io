<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="shytiger Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="shytiger Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>shytiger Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="shytiger Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">shytiger Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/08/Java-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shytiger Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/Java-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">Java 单元测试 反射 注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-08 11:06:51" itemprop="dateCreated datePublished" datetime="2020-09-08T11:06:51+08:00">2020-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-09 15:29:04" itemprop="dateModified" datetime="2020-09-09T15:29:04+08:00">2020-09-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><ul>
<li><p>测试分类：</p>
<ol>
<li>黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。</li>
<li>白盒测试：需要写代码的。关注程序具体的执行流程。</li>
</ol>
</li>
<li><p>Junit使用：白盒测试</p>
<ul>
<li><p>步骤：</p>
<ol>
<li><p>定义一个测试类(测试用例)</p>
<ul>
<li>建议：<ul>
<li>测试类名：被测试的类名Test        CalculatorTest</li>
<li>包名：xxx.xxx.xx.test        cn.itcast.test</li>
</ul>
</li>
</ul>
</li>
<li><p>定义测试方法：可以独立运行</p>
<ul>
<li>建议：<ul>
<li>方法名：test测试的方法名        testAdd()  </li>
<li>返回值：void</li>
<li>参数列表：空参</li>
</ul>
</li>
</ul>
</li>
<li><p>给方法加@Test</p>
</li>
<li><p>导入junit依赖环境</p>
</li>
</ol>
</li>
<li><p>判定结果：</p>
<ul>
<li>红色：失败</li>
<li>绿色：成功</li>
<li>一般我们会使用断言操作来处理结果<ul>
<li>Assert.assertEquals(期望的结果,运算的结果);</li>
</ul>
</li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li>@Before:<ul>
<li>修饰的方法会在测试方法之前被自动执行</li>
</ul>
</li>
<li>@After:<ul>
<li>修饰的方法会在测试方法执行之后自动被执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><ul>
<li>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</li>
<li>反射：将类的各个组成部分封装为其他对象，这就是反射机制</li>
<li>好处：<ol>
<li>可以在程序运行过程中，操作这些对象。</li>
<li>可以解耦，提高程序的可扩展性。</li>
</ol>
</li>
</ul>
<ul>
<li>Java代码正在计算机中 经历的阶段：三个阶段<br><img src="https://img-blog.csdnimg.cn/20200908205159655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200908205616920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<ul>
<li>获取Class对象的方式：</li>
</ul>
<ol>
<li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象<ul>
<li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li>
</ul>
</li>
<li>类名.class：通过类名的属性class获取<ul>
<li>多用于参数的传递</li>
</ul>
</li>
<li>对象.getClass()：getClass()方法在Object类中定义着。<ul>
<li>多用于对象的获取字节码的方式</li>
</ul>
</li>
</ol>
<ul>
<li>结论：<br>  同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li>
</ul>
<ul>
<li><p>Class对象功能：</p>
</li>
<li><p>获取功能：</p>
<ol>
<li><p>获取成员变量们</p>
<ul>
<li><p>Field[] getFields() ：获取所有public修饰的成员变量</p>
</li>
<li><p>Field getField(String name)   获取指定名称的 public修饰的成员变量</p>
</li>
<li><p>Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</p>
</li>
<li><p>Field getDeclaredField(String name)  </p>
</li>
</ul>
</li>
<li><p>获取构造方法们</p>
<ul>
<li><p>Constructor&lt;?&gt;[] getConstructors()  </p>
</li>
<li><p>Constructor<T> getConstructor(类&lt;?&gt;… parameterTypes)  </p>
</li>
<li><p>Constructor<T> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)  </p>
</li>
<li><p>Constructor&lt;?&gt;[] getDeclaredConstructors()  </p>
</li>
</ul>
</li>
<li><p>获取成员方法们：</p>
<ul>
<li><p>Method[] getMethods()  </p>
</li>
<li><p>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)  </p>
</li>
<li><p>Method[] getDeclaredMethods()  </p>
</li>
<li><p>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)  </p>
</li>
</ul>
</li>
<li><p>获取全类名    </p>
<ul>
<li>String getName()  </li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>Field：成员变量</p>
</li>
<li><p>操作：</p>
<ol>
<li><p>设置值</p>
<ul>
<li>void set(Object obj, Object value)  </li>
</ul>
</li>
<li><p>获取值</p>
<ul>
<li>get(Object obj) </li>
</ul>
</li>
<li><p>忽略访问权限修饰符的安全检查</p>
<ul>
<li>setAccessible(true):暴力反射</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>Constructor:构造方法</p>
</li>
<li><p>创建对象：</p>
<ul>
<li><p>T newInstance(Object… initargs)  </p>
</li>
<li><p>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Method：方法对象</p>
</li>
<li><p>执行方法：</p>
<ul>
<li>Object invoke(Object obj, Object… args)  </li>
</ul>
</li>
<li><p>获取方法名称：</p>
<ul>
<li>String getName:获取方法名</li>
</ul>
</li>
</ul>
<ul>
<li>案例：</li>
<li>需求：写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法<ul>
<li>实现：<ol>
<li>配置文件</li>
<li>反射</li>
</ol>
</li>
<li>步骤：<ol>
<li>将需要创建的对象的全类名和需要执行的方法定义在<strong>配置文件</strong>中<ul>
<li>改配置文件的好处：改代码需要重新编译</li>
</ul>
</li>
<li>在程序中加载读取配置文件</li>
<li>使用反射技术来加载类文件进内存</li>
<li>创建对象</li>
<li>执行方法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><ul>
<li><p>概念：说明程序的。给计算机看的</p>
</li>
<li><p>注释：用文字描述程序的。给程序员看的</p>
</li>
<li><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p>
</li>
<li><p>概念描述：</p>
</li>
<li><p>JDK1.5之后的新特性</p>
</li>
<li><p>说明程序的</p>
</li>
<li><p>使用注解：@注解名称</p>
</li>
</ul>
<ul>
<li>作用分类：<br>①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 javadoc命令<br>②代码分析：通过代码里标识的注解对代码进行分析【使用反射】<br>③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li>
</ul>
<ul>
<li>其他<ul>
<li>相关命令<ul>
<li>javac编译</li>
<li>javap反编译</li>
<li>javadoc 生成文档</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>JDK中预定义的一些注解</p>
</li>
<li><p>@Override    ：检测被该注解标注的方法是否是继承自父类(接口)的</p>
</li>
<li><p>@Deprecated：该注解标注的内容，表示已过时</p>
</li>
<li><p>@SuppressWarnings：压制警告</p>
<ul>
<li>一般传递参数all  @SuppressWarnings(“all”)</li>
</ul>
</li>
<li><p>自定义注解</p>
</li>
<li><p>格式：<br>  元注解<br>  public @interface 注解名称{</p>
<pre><code>  属性列表;</code></pre>
<p>  }</p>
</li>
<li><p>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p>
<ul>
<li>public interface MyAnno extends java.lang.annotation.Annotation {}</li>
</ul>
</li>
</ul>
<ul>
<li><p>属性：接口中的抽象方法</p>
<ul>
<li><p>要求：</p>
<ol>
<li><p>属性的返回值类型有下列取值</p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</li>
<li><p>定义了属性，在使用时需要给属性赋值</p>
<ol>
<li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li>
<li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li>
<li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>元注解：用于描述注解的注解</p>
<ul>
<li>@Target：描述注解能够作用的位置<ul>
<li>ElementType取值：<ul>
<li>TYPE：可以作用于类上</li>
<li>METHOD：可以作用于方法上</li>
<li>FIELD：可以作用于成员变量上</li>
</ul>
</li>
</ul>
</li>
<li>@Retention：描述注解被保留的阶段<ul>
<li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到<ul>
<li>Source 不会保留到class字节码文件中</li>
<li>Class 会保留到class字节码文件中，不会被JVM读取到</li>
<li>Runtime 一般用这个</li>
</ul>
</li>
</ul>
</li>
<li>@Documented：描述注解是否被抽取到api文档中</li>
<li>@Inherited：描述注解是否被子类继承</li>
</ul>
</li>
</ul>
<ul>
<li><p>注解的应用</p>
<ul>
<li>用来替换配置文件</li>
</ul>
</li>
<li><p>在程序使用(解析)注解：获取注解中定义的属性值</p>
</li>
</ul>
<ol>
<li><p>获取注解定义的位置的对象  （Class，Method,Field）</p>
</li>
<li><p>获取指定的注解</p>
<ul>
<li><p>getAnnotation(Class)<br>//其实就是在内存中生成了一个该注解接口的子类实现对象</p>
<pre><code>  public class ProImpl implements Pro&#123;
      public String className()&#123;
          return &quot;cn.itcast.annotation.Demo1&quot;;
      &#125;
      public String methodName()&#123;
          return &quot;show&quot;;
      &#125;
  &#125;</code></pre>
</li>
</ul>
</li>
<li><p>调用注解中的抽象方法获取配置的属性值</p>
</li>
</ol>
<ul>
<li>案例：简单的测试框架</li>
<li>小结：</li>
</ul>
<ol>
<li>以后大多数时候，我们会使用注解，而不是自定义注解</li>
<li>注解给谁用？<ol>
<li>编译器</li>
<li>给解析程序用</li>
</ol>
</li>
<li>注解不是程序的一部分，可以理解为注解就是一个标签</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/05/Java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shytiger Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/05/Java%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Java集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-05 09:18:44" itemprop="dateCreated datePublished" datetime="2020-09-05T09:18:44+08:00">2020-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-08 10:38:22" itemprop="dateModified" datetime="2020-09-08T10:38:22+08:00">2020-09-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul>
<li>优质博客<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md">JavaGuide</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jing99/p/7057245.html">java集合继承关系图</a>  </li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-stack-class.html">https://www.runoob.com/java/java-stack-class.html</a>  </li>
</ul>
</li>
</ul>
<h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><ul>
<li>java集合框架图<br><img src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif"><br><img src="https://img-blog.csdnimg.cn/20200905155442847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ul>
<h1 id="集合涉及到的常见接口"><a href="#集合涉及到的常见接口" class="headerlink" title="集合涉及到的常见接口"></a>集合涉及到的常见接口</h1><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><ul>
<li>主要方法<ul>
<li>boolean hasNext()</li>
<li>E next()  </li>
</ul>
</li>
</ul>
<h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><ul>
<li>重写compareTo方法（大于 返回正  == 返回0 小于 返回负）  </li>
</ul>
<h2 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h2><ul>
<li>从写compare()方法  </li>
</ul>
<h1 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h1><p><img src="https://img-blog.csdnimg.cn/20200905162053918.png#pic_center" alt="在这里插入图片描述"><br><strong>集合中存储的都是对象的引用(地址)。</strong>  </p>
<ul>
<li>集合的输出<ul>
<li>四种输出方式<ul>
<li>Iterator</li>
<li>ListIterator</li>
<li>Enumeration</li>
<li>foreach</li>
</ul>
</li>
<li>注意：<ul>
<li><em>在迭代时，不可以通过集合对象的方法操作集合中的元素，因为会发生ConcurrentModificationException异常。所以，在迭代器时，只能用迭代器的放过操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。该接口只能通过List集合的listIterator方法获取。</em>  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>(对付顺序的好帮手)： 存储的元素是有序的、可重复的。<br><img src="https://img-blog.csdnimg.cn/20200905162201254.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><ul>
<li>Object[] 数组</li>
<li>查询快</li>
<li>add(E e) O(1)</li>
<li>add(int index, E element)  O(n-i)  </li>
<li>优秀参考：<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析 ArrayList 扩容机制</a>  </li>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList.md">ArrayList核心源码</a>   </li>
</ul>
</li>
</ul>
<h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><ul>
<li>双向链表实现</li>
<li>查询慢</li>
<li>add(E e)  O(1)</li>
<li>add(int index, E element) o(n)   </li>
</ul>
<style>
table th:first-of-type {
    width: 2cm;
}
table th:nth-of-type(2) {
    width: 300pt;
}
table th:nth-of-type(3) {
    width: 12em;
}
table th:nth-of-type(4) {
    width: 12em;
}
table th:nth-of-type(5) {
    width: 12em;
}
</style>  
<table>
<thead>
<tr>
<th>操作类型</th>
<th>增</th>
<th>删除</th>
<th>改</th>
<th>查</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>add​(int index, E element)<br> add​(E e)<br> <strong>offer​(E e)</strong><br> addAll​(Collection&lt;? extends E&gt; c)<br> <strong>addFirst​(E e)</strong><br> <strong>addLast​(E e)</strong><br></td>
<td>clear​()<br> poll​()<br> remove​(int index)<br> remove​(Object o)<br></td>
<td>set​(int index, E element)<br></td>
<td>contains​(Object o)<br>  get​(int index)<br></td>
</tr>
</tbody></table>
<ul>
<li>LinkedList可以实现List,Queue,Deque(双端队列)接口  </li>
</ul>
<h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><ul>
<li>线程安全的，效率低  </li>
</ul>
<h4 id="Stack类"><a href="#Stack类" class="headerlink" title="Stack类"></a>Stack类</h4><p>Vector类的子类</p>
<ol>
<li>boolean empty()<br>判断栈是否为空</li>
<li>E peek()<br>返回栈顶对象，不移除</li>
<li>E pop()<br>返回栈顶对象，并移除</li>
<li>E push(E item)<br>压入栈顶</li>
<li>int search(Object o)<br>返回对象在栈的位置  </li>
</ol>
<h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><ul>
<li><p>Queue接口定义了如下6个方法，我们常用的LinkedList类就实现了Queue接口。 </p>
<ol>
<li>boolean add(E e)<br>向队列中添加元素</li>
<li>E element()<br>返回队列的头，且不移除</li>
<li>boolean offer(E e)<br>向队列中添加元素</li>
<li>E peek()<br>返回队列的头，且不移除</li>
<li>E poll()<br>返回队列的头，且移除</li>
<li>E remove()<br>返回队列的头，且移除<br>add、element、remove会在操作失败时抛出异常，而offer、peek、poll在操作失败时返回特殊值。   </li>
</ol>
</li>
<li><p><strong>offer()与add()的区别</strong></p>
<ul>
<li>超出队列界限时，add（）方法是抛出异常让你处理，而offer（）方法是直接返回false</li>
<li>推荐使用offer()  </li>
</ul>
</li>
</ul>
<h3 id="PriorityQueue类"><a href="#PriorityQueue类" class="headerlink" title="PriorityQueue类"></a>PriorityQueue类</h3><ul>
<li>概述<br>实际上是一个堆（不指定Comparator时默认为最小堆）<br>队列既可以根据元素的自然顺序来排序，也可以根据 Comparator来设置排序规则。<br>队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素。<br>新建对象的时候可以指定一个初始容量，其容量会自动增加。</li>
<li>参考博客<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gnivor/p/4841191.html">Java学习笔记–PriorityQueue(优先队列)(堆)</a>  </li>
<li>注意点<ul>
<li><strong>插入方法（offer()、poll()、remove() 、add() 方法）时间复杂度为O(log(n))</strong> ；</li>
<li>**remove(Object) 和 contains(Object) 时间复杂度为O(n)**；</li>
<li>检索方法（peek、element 和 size）时间复杂度为常量。</li>
<li>不允许使用 null 元素。</li>
<li>不是同步的。不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue实例。保证线程安全可以使用PriorityBlockingQueue 类。</li>
<li>该队列是用数组实现，但是数组大小可以动态增加，容量无限。</li>
<li>此类及其迭代器实现了 Collection 和 Iterator 接口的所有可选 方法。</li>
<li>可以在构造函数中指定如何排序。<code>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code></li>
</ul>
</li>
</ul>
<p>优先队列主要方法： </p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>add​(E e)</td>
<td>将指定的元素插入到此优先级队列中。</td>
</tr>
<tr>
<td>void</td>
<td>clear​()</td>
<td>从此优先级队列中删除所有元素。</td>
</tr>
<tr>
<td>Comparator&lt;? super E&gt;</td>
<td>comparator​()</td>
<td>返回用于为了在这个队列中的元素，或比较null如果此队列根据所述排序natural ordering的元素。</td>
</tr>
<tr>
<td>boolean</td>
<td>contains​(Object o)</td>
<td>如果此队列包含指定的元素，则返回 true 。</td>
</tr>
<tr>
<td>Iterator<E></td>
<td>iterator​()</td>
<td>返回此队列中的元素的迭代器。</td>
</tr>
<tr>
<td>boolean</td>
<td>offer​(E e)</td>
<td>将指定的元素插入到此优先级队列中。</td>
</tr>
<tr>
<td>E</td>
<td>peek​()</td>
<td>检索但不删除此队列的头，如果此队列为空，则返回 null 。</td>
</tr>
<tr>
<td>E</td>
<td>poll​()</td>
<td>检索并删除此队列的头部，如果此队列为空，则返回 null 。</td>
</tr>
<tr>
<td>boolean</td>
<td>remove​(Object o)</td>
<td>从该队列中删除指定元素的单个实例（如果存在）。</td>
</tr>
<tr>
<td>int</td>
<td>size​()</td>
<td>返回此集合中的元素数。</td>
</tr>
<tr>
<td>Spliterator<E></td>
<td>spliterator​()</td>
<td>在此队列中的元素上创建late-binding和故障快速 Spliterator 。</td>
</tr>
<tr>
<td>Object[]</td>
<td>toArray​()</td>
<td>返回一个包含此队列中所有元素的数组。</td>
</tr>
<tr>
<td><T> T[]</td>
<td>toArray​(T[] a)</td>
<td>返回一个包含此队列中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>
<h2 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h2><p>双端队列 ，LinkedList类和ArrayDeque类实现了该接口。可以操作两端</p>
<h3 id="ArrayDeque类"><a href="#ArrayDeque类" class="headerlink" title="ArrayDeque类"></a>ArrayDeque类</h3><ul>
<li>与LinkedList类 相似，区别是底层为数组实现  </li>
</ul>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h3 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h3><ul>
<li>HashSet是如何保证元素唯一性的呢？<blockquote>
<p>是通过元素的两个方法，hashCode和equals来完成。<br>  如果元素的HashCode值相同，才会判断equals是否为true。<br>  如果元素的hashcode值不同，不会调用equals。  
　　　</p>
</blockquote>
<h3 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h3></li>
<li>能够按照添加的顺序遍历  </li>
</ul>
<h3 id="SortedSet接口"><a href="#SortedSet接口" class="headerlink" title="SortedSet接口"></a>SortedSet接口</h3><h4 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h4><ul>
<li>底层为红黑树</li>
<li>能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</li>
</ul>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>&lt;Key,Value&gt;<br><img src="https://img-blog.csdnimg.cn/20200905162910374.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="HashTable-类"><a href="#HashTable-类" class="headerlink" title="HashTable 类"></a>HashTable 类</h2><ul>
<li>线程安全 其内部方法基本经过<code>synchronized</code>修饰 （替代 ConcurrentHashMap）</li>
<li>效率较低，基本被淘汰  </li>
</ul>
<h2 id="HashMap-类"><a href="#HashMap-类" class="headerlink" title="HashMap  类"></a>HashMap  类</h2><ul>
<li>优秀参考链接：<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap.md">HashMap(JDK1.8)源码 </a></li>
</ul>
</li>
<li>底层数据结构： 数组 + 链表（jdk1.8后 链表长于（8）将链表转为红黑树）</li>
<li>扩容机制：<ul>
<li>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。</li>
</ul>
</li>
<li>初始容量大小和每次扩充容量大小：<ul>
<li>HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li>
<li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小。 </li>
<li>为什么是2的幂次？<ul>
<li>因为在计算元素该存放的位置的时候，用到的算法是将元素的hashcode与当前map长度-1进行与运算。源码：<pre><code class="Java">  static int indexFor(int h, int length) &amp;#123;
      // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;
      return h &amp; (length-1);
&amp;#125;</code></pre>
如果map长度为2的幂次，那长度-1的二进制一定为11111…这种形式，进行与运算就看元素的hashcode，但是如果map的长度不是2的幂次，比如为15，那长度-1就是14，二进制为1110，无论与谁相与最后一位一定是0，0001，0011，0101，1001，1011，0111，1101这几个位置就永远都不能存放元素了，空间浪费相当大。也增加了添加元素是发生碰撞的机会。减慢了查询效率。所以Hashmap的大小是2的幂次。</li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zmx729618/article/details/52795493">Java遍历HashMap并修改(remove)</a></li>
</ul>
<h3 id="LinkedHashMap-类"><a href="#LinkedHashMap-类" class="headerlink" title="LinkedHashMap 类"></a>LinkedHashMap 类</h3><ul>
<li>HashMap的子类，在上<code>HashMap</code>结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的<strong>插入顺序</strong>。  </li>
</ul>
<h2 id="SortedMap-接口"><a href="#SortedMap-接口" class="headerlink" title="SortedMap 接口"></a>SortedMap 接口</h2><h3 id="TreeMap类"><a href="#TreeMap类" class="headerlink" title="TreeMap类"></a>TreeMap类</h3><ul>
<li>底层数据结构：红黑树</li>
</ul>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="什么是快速失败（fail-fast）"><a href="#什么是快速失败（fail-fast）" class="headerlink" title="什么是快速失败（fail-fast）"></a>什么是快速失败（fail-fast）</h2><ul>
<li>快速失败(fail-fast) 是 Java 集合的一种错误检测机制。在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。</li>
<li>实现机制： 每当迭代器使用 hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。如果我们在集合被遍历期间对其进行修改的话，就会改变 modCount 的值，进而导致 modCount != expectedModCount ，进而抛出 ConcurrentModificationException 异常。</li>
<li><strong>通过 Iterator 的方法修改集合的话会修改到 expectedModCount 的值，所以不会抛出异常。</strong></li>
</ul>
<h2 id="什么是安全失败（fail-safe）"><a href="#什么是安全失败（fail-safe）" class="headerlink" title="什么是安全失败（fail-safe）"></a>什么是安全失败（fail-safe）</h2><ul>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。</li>
</ul>
<h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p><img src="https://img-blog.csdnimg.cn/20200908103807718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Java可选操作"><a href="#Java可选操作" class="headerlink" title="Java可选操作"></a>Java可选操作</h2><p>简单说就是抽象类的的某些bai派生类实现里，或者接口的du某个实现类里面，某个方法可能zhi是无意义的，调用该方dao法会抛出一个异常。例如在collection的某些实现类里，里面的元素可能都是只读的，那么add这个接口是无意义的，调用会抛出<code>UnspportedOperationException</code>异常。<br>从设计的角度说，如果一个接口的方法设计为optional，表示这个方法不是为所有的实现而设定的，而只是为某一类的实现而设定的。</p>
<h1 id="其他-草稿"><a href="#其他-草稿" class="headerlink" title="其他(草稿)"></a>其他(草稿)</h1><ul>
<li>List接口<ul>
<li>ArrayList <ul>
<li>Object[] 数组</li>
<li>查询快</li>
<li>add(E e) O(1)</li>
<li>add(int index, E element)  O(n-i)</li>
</ul>
</li>
<li>LinkedList <ul>
<li>双向链表实现</li>
<li>查询慢</li>
<li>add(E e)  O(1)</li>
<li>add(int index, E element) o(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Map接口<ul>
<li>HashMap<ul>
<li>数组 + 链表（jdk1.8后 链表长于（8）将链表转为红黑树）</li>
</ul>
</li>
<li>LinkedHashMap  <ul>
<li>在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的<strong>插入顺序</strong>。</li>
</ul>
</li>
<li>TreeMap</li>
<li>LinkedTable</li>
<li>ConcurrentHashMap<ul>
<li>只锁桶</li>
</ul>
</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet<ul>
<li>线程不安全 底层是HashMap 可以存储null值</li>
</ul>
</li>
<li>LinkedHashSet</li>
<li>TreeSet  </li>
</ul>
</li>
</ul>
<ul>
<li>Collection接口<br><img src="https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621005616085-269540653.png">  </li>
</ul>
<table>
<thead>
<tr>
<th>Modifier and Typ</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>add(E e)</td>
<td>确保此集合包含指定的元素（可选操作）。</td>
</tr>
<tr>
<td>boolean</td>
<td>addAll​(Collection&lt;? extends E&gt; c)</td>
<td>将指定集合中的所有元素添加到此集合（可选操作）。</td>
</tr>
<tr>
<td>void</td>
<td>clear​()</td>
<td>从此集合中删除所有元素（可选操作）。</td>
</tr>
<tr>
<td>boolean</td>
<td>contains​(Object o)</td>
<td>如果此集合包含指定的元素，则返回 true 。</td>
</tr>
<tr>
<td>boolean</td>
<td>containsAll​(Collection&lt;?&gt; c)</td>
<td>如果此集合包含指定集合中的所有元素，则返回 true 。</td>
</tr>
<tr>
<td>boolean</td>
<td>equals​(Object o)</td>
<td>将指定的对象与此集合进行比较以获得相等性。</td>
</tr>
<tr>
<td>int</td>
<td>hashCode​()</td>
<td>返回此集合的哈希码值。</td>
</tr>
<tr>
<td>boolean</td>
<td>isEmpty​()</td>
<td>如果此集合不包含元素，则返回 true 。</td>
</tr>
<tr>
<td>Iterator<E></td>
<td>iterator​()</td>
<td>返回此集合中元素的迭代器。</td>
</tr>
<tr>
<td>default Stream<E></td>
<td>parallelStream​()</td>
<td>返回可能并行的 Stream与此集合作为其来源。</td>
</tr>
<tr>
<td>boolean</td>
<td>remove​(Object o)</td>
<td>从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</td>
</tr>
<tr>
<td>boolean</td>
<td>removeAll​(Collection&lt;?&gt; c)</td>
<td>删除指定集合中包含的所有此集合的元素（可选操作）。</td>
</tr>
<tr>
<td>default</td>
<td>boolean removeIf​(Predicate&lt;? super E&gt; filter)</td>
<td>删除满足给定谓词的此集合的所有元素。</td>
</tr>
<tr>
<td>boolean</td>
<td>retainAll​(Collection&lt;?&gt; c)</td>
<td>仅保留此集合中包含在指定集合中的元素（可选操作）。</td>
</tr>
<tr>
<td>int</td>
<td>size​()</td>
<td>返回此集合中的元素数。</td>
</tr>
<tr>
<td>default</td>
<td>Spliterator<E> spliterator​()</td>
<td>在此集合中的元素上创建一个Spliterator 。</td>
</tr>
<tr>
<td>default</td>
<td>Stream<E> stream​()</td>
<td>返回一个序列 Stream与此集合作为其来源。</td>
</tr>
<tr>
<td>Object[]</td>
<td>toArray​()</td>
<td>返回一个包含此集合中所有元素的数组。</td>
</tr>
<tr>
<td><T> T[]</td>
<td>toArray​(T[] a)</td>
<td>返回一个包含此集合中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shytiger Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">慕课网-算法与数据结构—学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-12 16:21:41" itemprop="dateCreated datePublished" datetime="2020-08-12T16:21:41+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-14 21:01:13" itemprop="dateModified" datetime="2020-08-14T21:01:13+08:00">2020-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p><strong>慕课网-算法与数据结构-学习总结</strong>  </p>
</blockquote>
<hr>
<h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p><a target="_blank" rel="noopener" href="https://github.com/liuyubobobo/Play-with-Algorithms">课程源码play-with-Algorithms</a></p>
<h1 id="第二章-排序基础"><a href="#第二章-排序基础" class="headerlink" title="第二章 排序基础"></a>第二章 排序基础</h1><ul>
<li><strong>排序的稳定性</strong><br>  排序后是否改变原序列键值相同的序列的先后关系</li>
<li><strong>内排序与外排序</strong><br>  外排序： 由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行 。外部排序最常用的算法是多路归并排序</li>
<li><strong>影响排序的三个方面</strong>  <ul>
<li>时间性能<ul>
<li>比较</li>
<li>移动</li>
</ul>
</li>
<li>辅助空间</li>
<li>算法复杂度  <h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2></li>
</ul>
</li>
</ul>
<ul>
<li><p>冒泡排序</p>
<ul>
<li>基本思想：两两交换，将最大（或最小）的交换至队列前  <h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2></li>
</ul>
</li>
<li><p>简单选择排序  </p>
<ul>
<li>基本思想：在未排序的序列种找到最小（或最大）的元素放到前面  </li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9TZWxlY3Rpb24tU29ydC1BbmltYXRpb24uZ2lm" alt="动画演示">  </li>
</ul>
</li>
<li><p>参考实现代码（cpp）</p>
<pre><code>    template&lt;typename T&gt;
    void selectionSort(T arr[], int n)&amp;#123;

        for(int i = 0 ; i &lt; n ; i ++)&amp;#123;

            int minIndex = i;
            for( int j = i + 1 ; j &lt; n ; j ++ )
                if( arr[j] &lt; arr[minIndex] )
                    minIndex = j;

            swap( arr[i] , arr[minIndex] );
        &amp;#125;
    &amp;#125;</code></pre>
</li>
<li><p>直接选择排序  </p>
</li>
<li><p>树型选择排序</p>
</li>
</ul>
<h2 id="插入排序及其改进"><a href="#插入排序及其改进" class="headerlink" title="插入排序及其改进"></a>插入排序及其改进</h2><ul>
<li><p>直接插入排序  </p>
<ul>
<li><p>基本思想: 将未排序的元素插入到已经排好序的队列种对应的位置</p>
</li>
<li><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTAxNjU5NC0xNTBiNmM0NjJlM2VkODA5LnBuZw?x-oss-process=image/format,png" alt="示意图">  </p>
</li>
<li><p>代码</p>
<pre><code>template&lt;typename T&gt;
void insertionSort(T arr[], int n)&amp;#123;
    for( int i = 1 ; i &lt; n ; i ++ ) &amp;#123;

    // 寻找元素arr[i]合适的插入位置
    // 写法1
    //        for( int j = i ; j &gt; 0 ; j-- )
    //            if( arr[j] &lt; arr[j-1] )
    //                swap( arr[j] , arr[j-1] );
    //            else
    //                break;

    // 写法2
    //        for( int j = i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )
    //            swap( arr[j] , arr[j-1] );

    // 写法3
                T e = arr[i];
                int j; // j保存元素e应该插入的位置
                for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; e; j--)
                    arr[j] = arr[j-1];
                arr[j] = e;
    &amp;#125;
    return;
&amp;#125;</code></pre>
</li>
<li><p>改进：   </p>
<ul>
<li><p><strong>折半插入排序：</strong> 找到已排好序种对应位置时 用 折半查找   </p>
</li>
<li><p><strong>希尔排序</strong>:</p>
<ul>
<li><p>基本思想：交换不相邻的元素以对数组的<strong>局部</strong>进行排序</p>
</li>
<li><p><img src="https://upload-images.jianshu.io/upload_images/7779232-d19c19b7153b27b2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp"></p>
</li>
<li><p>第一个O(n log n)的排序算法</p>
</li>
<li><p>参考代码</p>
<pre><code>template&lt;typename T&gt;
void shellSort(T arr[], int n)&amp;#123;

    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...
    int h = 1;
    while( h &lt; n/3 )
        h = 3 * h + 1;

    while( h &gt;= 1 )&amp;#123;

        // h-sort the array
        for( int i = h ; i &lt; n ; i ++ )&amp;#123;

            // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序
            T e = arr[i];
            int j;
            for( j = i ; j &gt;= h &amp;&amp; e &lt; arr[j-h] ; j -= h )
                arr[j] = arr[j-h];
            arr[j] = e;
        &amp;#125;

        h /= 3;
    &amp;#125;
&amp;#125;</code></pre>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/642b19f8a69c">希尔排序及其优化</a>  </p>
</li>
</ul>
</li>
<li><p>其他： 路插入排序,表插入排序等。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第三章-高级排序问题"><a href="#第三章-高级排序问题" class="headerlink" title="第三章 高级排序问题"></a>第三章 高级排序问题</h1><h2 id="归并排序及其优化"><a href="#归并排序及其优化" class="headerlink" title="归并排序及其优化"></a>归并排序及其优化</h2><ul>
<li><p>基本思想： (分治)将排序序列差分成 两个等长的子序列，对子序列进行排序后再归并</p>
</li>
<li><p>参考核心代码(cpp)</p>
<pre><code>    // 使用优化的归并排序算法, 对arr[l...r]的范围进行排序
    template&lt;typename T&gt;
    void __mergeSort2(T arr[], int l, int r)&amp;#123;

        // 优化2: 对于小规模数组, 使用插入排序
        if( r - l &lt;= 15 )&amp;#123;
            insertionSort(arr, l, r);
            return;
        &amp;#125;

        int mid = (l+r)/2;
        __mergeSort2(arr, l, mid);
        __mergeSort2(arr, mid+1, r);

        // 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge
        // 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失
        if( arr[mid] &gt; arr[mid+1] )
            __merge(arr, l, mid, r);
    &amp;#125;</code></pre>
</li>
<li><p>优化点：    </p>
<pre><code>- 当排序的元素少于一定（16）时，直接调用 插入排序  
- 如果第一个序列的最大值小于第二个序列的最小值，则不用比较，直接合并  </code></pre>
<ul>
<li><p>归并排序的自底向上写法（迭代）  </p>
</li>
<li><p><strong>核心代码参考</strong>    </p>
<pre><code>  ```        

  // 使用自底向上的归并排序算法
  template &lt;typename T&gt;
  void mergeSortBU(T arr[], int n)&amp;#123;
      // Merge Sort Bottom Up 优化
      // 对于小数组, 使用插入排序优化
      for( int i = 0 ; i &lt; n ; i += 16 )
          insertionSort(arr,i,min(i+15,n-1));

      for( int sz = 16; sz &lt; n ; sz += sz )
          for( int i = 0 ; i &lt; n - sz ; i += sz+sz )
              // 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge
              if( arr[i+sz-1] &gt; arr[i+sz] )
                  __merge(arr, i, i+sz-1, min(i+sz+sz-1,n-1) );
      // Merge Sort BU 也是一个O(nlogn)复杂度的算法，虽然只使用两重for循环
      // 所以，Merge Sort BU也可以在1秒之内轻松处理100万数量级的数据
      // 注意：不要轻易根据循环层数来判断算法的复杂度，Merge Sort BU就是一个反例
      // 关于这部分陷阱，推荐看（liubobo老师）的《玩转算法面试》课程，第二章：《面试中的复杂度分析》：）
  &amp;#125;
  ```</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></li>
</ul>
</li>
<li><p>基本思想： （分治） 将选定的元素放到合适的位置，然后 递归 排序 被该元素分开的 前 后 两个子序列。(分出来的两个子序列可能不等长，相差很大，会影响性能)</p>
</li>
<li><p>核心代码参考  </p>
<pre><code>```
// 对arr[l...r]部分进行partition操作
// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]
template &lt;typename T&gt;
int _partition(T arr[], int l, int r)&amp;#123;

    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    swap( arr[l] , arr[rand()%(r-l+1)+l] );

    T v = arr[l];
    int j = l;
    for( int i = l + 1 ; i &lt;= r ; i ++ )
        if( arr[i] &lt; v )&amp;#123;
            j ++;
            swap( arr[j] , arr[i] );
        &amp;#125;

    swap( arr[l] , arr[j]);

    return j;
&amp;#125;

// 对arr[l...r]部分进行快速排序
template &lt;typename T&gt;
void _quickSort(T arr[], int l, int r)&amp;#123;

    // 对于小规模数组, 使用插入排序进行优化
    if( r - l &lt;= 15 )&amp;#123;
        insertionSort(arr,l,r);
        return;
    &amp;#125;

    int p = _partition(arr, l, r);
    _quickSort(arr, l, p-1 );
    _quickSort(arr, p+1, r);
&amp;#125;
```</code></pre>
</li>
<li><p>优化：  </p>
<pre><code>1. 标定点 随机选（针对基本有序的序列，如果固定选最前面的元素，则分治的两个子问题不平衡，退化为O(n^2)的复杂度）  
2. 小规模排序，使用插入排序</code></pre>
</li>
<li><p>双路快排  </p>
<ul>
<li><p>基本思想：针对键值重复过多时，分治的两个子序列不等长，导致分治不平衡</p>
</li>
<li><p>核心代码参考</p>
<pre><code>// 双路快速排序的partition
// 返回p, 使得arr[l...p-1] &lt;= arr[p] ; arr[p+1...r] &gt;= arr[p]
// 双路快排处理的元素正好等于arr[p]的时候要注意，详见下面的注释：）
template &lt;typename T&gt;
int _partition2(T arr[], int l, int r)&amp;#123;

    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    swap( arr[l] , arr[rand()%(r-l+1)+l] );
    T v = arr[l];

    // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v
    int i = l+1, j = r;
    while( true )&amp;#123;
        // 注意这里的边界, arr[i] &lt; v, 不能是arr[i] &lt;= v
        // 思考一下为什么?
        while( i &lt;= r &amp;&amp; arr[i] &lt; v )
            i ++;

        // 注意这里的边界, arr[j] &gt; v, 不能是arr[j] &gt;= v
        // 思考一下为什么?
        while( j &gt;= l+1 &amp;&amp; arr[j] &gt; v )
            j --;

        // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)
        // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html

        if( i &gt; j )
            break;

        swap( arr[i] , arr[j] );
        i ++;
        j --;
    &amp;#125;

    swap( arr[l] , arr[j]);

    return j;
&amp;#125;

// 对arr[l...r]部分进行快速排序
template &lt;typename T&gt;
void _quickSort(T arr[], int l, int r)&amp;#123;

    // 对于小规模数组, 使用插入排序进行优化
    if( r - l &lt;= 15 )&amp;#123;
        insertionSort(arr,l,r);
        return;
    &amp;#125;

    // 调用双路快速排序的partition
    int p = _partition2(arr, l, r);
    _quickSort(arr, l, p-1 );
    _quickSort(arr, p+1, r);
&amp;#125;</code></pre>
</li>
</ul>
</li>
<li><p>三路快排 </p>
<ul>
<li><p>基本思想： 针对2路快排的加强，进一步解决键值重复过多的问题（增加一个等值区域）</p>
</li>
<li><p>核心代码参考</p>
<pre><code>// 递归的三路快速排序算法
template &lt;typename T&gt;
void __quickSort3Ways(T arr[], int l, int r)&amp;#123;

    // 对于小规模数组, 使用插入排序进行优化
    if( r - l &lt;= 15 )&amp;#123;
        insertionSort(arr,l,r);
        return;
    &amp;#125;

    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot
    swap( arr[l], arr[rand()%(r-l+1)+l ] );

    T v = arr[l];

    int lt = l;     // arr[l+1...lt] &lt; v
    int gt = r + 1; // arr[gt...r] &gt; v
    int i = l+1;    // arr[lt+1...i) == v
    while( i &lt; gt )&amp;#123;
        if( arr[i] &lt; v )&amp;#123;
            swap( arr[i], arr[lt+1]);
            i ++;
            lt ++;
        &amp;#125;
        else if( arr[i] &gt; v )&amp;#123;
            swap( arr[i], arr[gt-1]);
            gt --;
        &amp;#125;
        else&amp;#123; // arr[i] == v
            i ++;
        &amp;#125;
    &amp;#125;

    swap( arr[l] , arr[lt] );

    __quickSort3Ways(arr, l, lt-1);
    __quickSort3Ways(arr, gt, r);
&amp;#125;

template &lt;typename T&gt;
void quickSort3Ways(T arr[], int n)&amp;#123;

    srand(time(NULL));
    __quickSort3Ways( arr, 0, n-1);
&amp;#125;
// 比较Merge Sort和双路快速排序和三路快排三种排序算法的性能效率
// 对于包含有大量重复数据的数组, 三路快排有巨大的优势
// 对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围里
// 因此, 在一些语言中, 三路快排是默认的语言库函数中使用的排序算法。比如Java:)</code></pre>
<h2 id="归并排序和快速排序衍生的问题"><a href="#归并排序和快速排序衍生的问题" class="headerlink" title="归并排序和快速排序衍生的问题"></a>归并排序和快速排序衍生的问题</h2></li>
</ul>
<ul>
<li>求逆序对（归并排序）</li>
<li>求数组中的第N大元素</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第四章-堆和堆排序"><a href="#第四章-堆和堆排序" class="headerlink" title="第四章 堆和堆排序"></a>第四章 堆和堆排序</h1><h2 id="基本概念认识"><a href="#基本概念认识" class="headerlink" title="基本概念认识"></a>基本概念认识</h2><ul>
<li>队列<ul>
<li>普通队列：先进先出</li>
<li>优先队列：根据优先级出队  </li>
</ul>
</li>
<li><strong>优先队列应用</strong>  对动态的数据排序  </li>
<li>优先队列的三种实现方式  <table>
<thead>
<tr>
<th align="left">实现方式</th>
<th align="left">入队</th>
<th align="left">出队</th>
</tr>
</thead>
<tbody><tr>
<td align="left">普通数组</td>
<td align="left">O(1)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">顺序数组(元素有序)</td>
<td align="left">O(n)</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">堆</td>
<td align="left">O(log n)</td>
<td align="left">O(log n)</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="堆的基本存储"><a href="#堆的基本存储" class="headerlink" title="堆的基本存储"></a>堆的基本存储</h2><pre><code>* 用数组存储二叉堆
* 数组的索引次序 对应 二叉堆中 层序遍历次序
* 对于完全二叉树,对第i个元素，其与其父，其子的关系
    * 根节点索引从0开始
        * parent(i) = （i-1）/2
        * left child (i) = 2*i +1
        * right child (i) = 2*i + 2
    * 根节点索引从1开始
        * parent(i) = i/2
        * left child (i) = 2*i 
        * right child (i) = 2*i + 1</code></pre>
<h3 id="heapfy过程（堆的建立）"><a href="#heapfy过程（堆的建立）" class="headerlink" title="heapfy过程（堆的建立）"></a>heapfy过程（堆的建立）</h3><pre><code>- 基本思想：从最后一个非叶子节点（索引为count/2，在根节点索引从1开始的情况下）开始，shiftdown()，自底向上实现堆
- 将n个元素逐个插入空堆中，算法复杂度为O(n log n),而heapfy过程算法复杂度O(n)  
- 代码
```
    // 构造函数, 通过一个给定数组创建一个最大堆
    // 该构造堆的过程, 时间复杂度为O(n)
    MaxHeap(Item arr[], int n)&amp;#123;
        data = new Item[n+1];
        capacity = n;

        for( int i = 0 ; i &lt; n ; i ++ )
            data[i+1] = arr[i];
        count = n;

        for( int i = count/2 ; i &gt;= 1 ; i -- )
            shiftDown(i);
    &amp;#125;
```</code></pre>
<h2 id="ShiftUp-节点上移比较"><a href="#ShiftUp-节点上移比较" class="headerlink" title="ShiftUp(节点上移比较)"></a>ShiftUp(节点上移比较)</h2><pre><code>- 代码
    ```
        void shiftUp(int k)&amp;#123;
        while( k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] )&amp;#123;
            swap( data[k/2], data[k] );
            k /= 2;
        &amp;#125;
        &amp;#125;
    ``` </code></pre>
<h2 id="ShiftDown（节点下移比较）"><a href="#ShiftDown（节点下移比较）" class="headerlink" title="ShiftDown（节点下移比较）"></a>ShiftDown（节点下移比较）</h2><pre><code>- 代码
```
    void shiftDown(int k)&#123;
    while( 2*k &lt;= count )&#123;
        int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置
        if( j+1 &lt;= count &amp;&amp; data[j+1] &gt; data[j] )
            j ++;
        // data[j] 是 data[2*k]和data[2*k+1]中的最大值

        if( data[k] &gt;= data[j] ) break;
        swap( data[k] , data[j] );
        k = j;
    &#125;
    &#125;
```</code></pre>
<h2 id="堆排序及其优化"><a href="#堆排序及其优化" class="headerlink" title="堆排序及其优化"></a>堆排序及其优化</h2><pre><code>* 堆排序算法：
    * 创建堆： 一种通过不断insert()创建O(nlogn)，一种传入数组用heapfy创建O(n)
    * 堆顶出堆： 将堆顶与堆尾互换，堆的size-1,并将新的堆顶（原堆尾）shiftDown()
    * 重复第二步  
* 堆排序的实现
    1. 借助insert()创建堆
    ```
    // heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序
    // 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)
    // 整个堆排序的整体时间复杂度为O(nlogn)
    template&lt;typename T&gt;
    void heapSort1(T arr[], int n)&#123;

        MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);
        for( int i = 0 ; i &lt; n ; i ++ )
            maxheap.insert(arr[i]);

        for( int i = n-1 ; i &gt;= 0 ; i-- )
            arr[i] = maxheap.extractMax();

    &#125;

    2. 借助heapfy() 创建堆
    // heapSort2, 借助我们的heapify过程创建堆
    // 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 实践复杂度为O(nlogn)
    // 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优
    template&lt;typename T&gt;
    void heapSort2(T arr[], int n)&#123;

        MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(arr,n);
        for( int i = n-1 ; i &gt;= 0 ; i-- )
            arr[i] = maxheap.extractMax();

    &#125;
    ```
* 堆的实现细节
    *ShiftUp和ShiftDown种使用复制操作替换swap操作*  </code></pre>
<h2 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h2><ul>
<li><p>基本思想： 分索引数组和数据数组，数据数组存数据元素。索引数组按堆的次序（比较的是实际元素的键值）存对应节点的索引（地址）。ShiftUP和ShiftDown中比较(实际元素的值)，交换对应的索引（存储地址），而不交换实际的元素。</p>
</li>
<li><p>一点理解： 维护了一个数组，既能有堆的特性（取最值），又能保持原有数组的存储次序（数据数组的索引是原数组的+1）。</p>
</li>
<li><p>ShfitUp()</p>
<pre><code>    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引
    void shiftUp( int k )&#123;
    while( k &gt; 1 &amp;&amp; data[indexes[k/2]] &lt; data[indexes[k]] )&#123;
        swap( indexes[k/2] , indexes[k] );
        k /= 2;
    &#125;
&#125;</code></pre>
</li>
<li><p>ShiftDown()</p>
<pre><code>    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引
    void shiftDown( int k )&#123;
        while( 2*k &lt;= count )&#123;
            int j = 2*k;
            if( j + 1 &lt;= count &amp;&amp; data[indexes[j+1]] &gt; data[indexes[j]] )
                j += 1;
            if( data[indexes[k]] &gt;= data[indexes[j]] )
                break;
            swap( indexes[k] , indexes[j] );
            k = j;
        &#125;
    &#125;</code></pre>
</li>
<li><p>增删实现 (<strong>插入操作 不是很理解</strong>)</p>
<pre><code>    // 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item
// 传入的i对用户而言,是从0索引的
void insert(int i, Item item)&#123;
    assert( count + 1 &lt;= capacity );
    assert( i + 1 &gt;= 1 &amp;&amp; i + 1 &lt;= capacity );
    i += 1;
    data[i] = item;
    indexes[count+1] = i;
    count++;
    shiftUp(count);
&#125;

// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据
Item extractMax()&#123;
    assert( count &gt; 0 );

    Item ret = data[indexes[1]];
    swap( indexes[1] , indexes[count] );
    count--;
    shiftDown(1);
    return ret;
&#125;</code></pre>
</li>
<li><p>应用： 最小生成树Prim算法中，用来维护 每个节点对应的最小横切面的权重【同时能输出当前所有节点最小横切面中的最小横切面】</p>
<h2 id="涉及堆-的相关问题"><a href="#涉及堆-的相关问题" class="headerlink" title="涉及堆 的相关问题"></a>涉及堆 的相关问题</h2><ul>
<li>多路归并排序 多个元素同时比较的时候用，最小（大）堆</li>
<li>d叉堆 d-ary heap  </li>
<li>最大最小队列 （最大堆和最小堆同时维护？？）</li>
<li>二项堆</li>
<li>斐波那契堆</li>
</ul>
</li>
</ul>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><pre><code>基本思想： 分配 + 收集 （先排序低位再排序高位）</code></pre>
<h2 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h2><table>
<thead>
<tr>
<th align="left">排序</th>
<th align="left">平均时间复杂度</th>
<th align="left">原地排序</th>
<th align="left">额外空间</th>
<th align="left">稳定排序</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入排序（Insertion Sort）</td>
<td align="left">O(n^2)</td>
<td align="left">是</td>
<td align="left">O(1)</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">归并排序(Merge Sort)</td>
<td align="left">O（nlogn）</td>
<td align="left">否</td>
<td align="left">O(n)</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">快速排序（Quick Sort）</td>
<td align="left">O(nlogn)</td>
<td align="left">是</td>
<td align="left"><strong>O（logn）</strong></td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">堆排序（Heap Sort)</td>
<td align="left">O(nlogn)</td>
<td align="left">是</td>
<td align="left">O(1)</td>
<td align="left">否</td>
</tr>
</tbody></table>
<ul>
<li><strong>不同排序算法的选择</strong>  <ul>
<li>n较小：直接插入排序或直接选择排序</li>
<li>基本有序序列，直接插入，冒泡，随机的快速排序</li>
<li>n较大，应选复杂度好的：快速排序，归并排序， 堆排序。<ul>
<li>快速排序性能平均最好，堆排序更少的辅助空间，归并排序是稳定的排序。（当排序数少于一定时如16，<strong>调用直接插入排序</strong>）  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>其他参考</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjIyOTk3LWIxYmIwNDg4NDlhMjI3YmUucG5n?x-oss-process=image/format,png" alt="排序算法总结"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8wMy9zb3J0LnBuZw?x-oss-process=image/format,png" alt="排序对比"><br><img src="https://img-blog.csdn.net/2018101109461342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pocTExODY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/liu17234050/article/details/104217658">C语言中的14种排序</a><br> <a target="_blank" rel="noopener" href="https://v.qq.com/x/page/e0523qakza6.html">14中排序动画演示</a>   </p>
<hr>
<h1 id="第五章-二分搜索树"><a href="#第五章-二分搜索树" class="headerlink" title="第五章 二分搜索树"></a>第五章 二分搜索树</h1><h2 id="5-1-二分查找法"><a href="#5-1-二分查找法" class="headerlink" title="5-1 二分查找法"></a>5-1 二分查找法</h2><ul>
<li><p>基本思想： （递归分治）对有序序列，不需要逐一比较，只要比较中间值，然后确定目标值的可能区域，再在可能区域递归二分查找。</p>
</li>
<li><p>细节： </p>
<ol>
<li>计算中间值时， 注意防止越界（基本类型的范围）。<ul>
<li>合理写法： int mid = left + (right-left)/2 ，</li>
<li>危险写法： int mid = (left + right)/2</li>
</ul>
</li>
<li>二分查找返回的只有一个索引，而序列中可能存在重复值。如何返回所有重复值？<ul>
<li>练习：对于存在重复值的序列，返回目标值索引的floor(第一个索引)和ceil（最后一个索引）</li>
</ul>
</li>
</ol>
</li>
<li><p>改进：（选不同的分割点）</p>
<ul>
<li>插值查找 （按比值分割） <ul>
<li>mid = left + (right-left)*&#123;(key-a[left])/(a[right]-a[left])&#125;</li>
</ul>
</li>
<li>斐波那契查找<ul>
<li>mid = left + F_block - 1 (黄金分割)<h2 id="5-2-二分搜索树"><a href="#5-2-二分搜索树" class="headerlink" title="5-2 二分搜索树"></a>5-2 二分搜索树</h2></li>
</ul>
</li>
</ul>
</li>
<li><p>二分搜索树的定义：</p>
<ul>
<li>左子树&gt;(&lt;) 根 &gt;(&lt;) 右子树 [一般不考虑键值重复的问题]</li>
</ul>
</li>
<li><p>二分搜索树的优势</p>
<ul>
<li>高效(（O(nlogn))的维护数据的有序性：min,max,floor,ceil,rank,select</li>
</ul>
</li>
<li><p>二分搜索树的节点插入</p>
<ul>
<li><p>实现方式： </p>
<ol>
<li><p>递归(返回子树根节点)[从根节点开始搜索，找到key值则替换，未找到则根据比较关系递归子树]</p>
<pre><code class="Cpp"> // 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法
 // 返回插入新节点后的二分搜索树的根
 private Node insert(Node node, Key key, Value value)\&amp;#123;

     if( node == null )&amp;#123;
         count ++;
         return new Node(key, value);
     &amp;#125;

     if( key.compareTo(node.key) == 0 )
         node.value = value;
     else if( key.compareTo(node.key) &lt; 0 )
         node.left = insert( node.left , key, value);
     else    // key &gt; node-&gt;key
         node.right = insert( node.right, key, value);

     return node;
 &amp;#125;</code></pre>
</li>
<li><p>迭代</p>
<ul>
<li>当作练习</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>二分搜索书的查找  </p>
<ul>
<li>基本思想: 二分查找</li>
</ul>
</li>
<li><p>二分搜索树的遍历</p>
<ul>
<li>（深度优先遍历）  <ul>
<li>前序遍历，中序遍历，后序遍历</li>
</ul>
</li>
<li>（广度优先遍历）<ul>
<li>层序遍历</li>
</ul>
</li>
</ul>
</li>
<li><p>删除最大值，最小值  </p>
<ul>
<li>实现：<ul>
<li>递归：（不断递归(左/右)子树，直到节点没有（左/右）子树，删除该节点，返回其的（右/左）子树赋值给上一节点的（左/右）子树）</li>
</ul>
</li>
</ul>
</li>
<li><p>删除Key对应的节点</p>
<ul>
<li>实现： <ul>
<li>递归<ul>
<li>从根节点开始递归搜索<ul>
<li>如果目标值在根节点则删除根节点，选新的中间值上位（左子树最右（大/小）的节点，右子树最左（小/大）的节点）</li>
<li>否则根据比较次序，选择（左/右）子树递归搜索，根节点的（左/右）子树 = 返回删除最值后的子树的根节点<h2 id="5-3-二分搜索树的特性"><a href="#5-3-二分搜索树的特性" class="headerlink" title="5-3 二分搜索树的特性"></a>5-3 二分搜索树的特性</h2></li>
<li>顺序性</li>
<li>minimum/maximum</li>
<li>successor/predecessor 后继/前继</li>
<li>floor/ceil （存在键值重复时，索引的范围）</li>
<li>rank/select 已知key获取排名/已知排名获取key,value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>局限性：(不平衡) 依照顺序或逆序插入元素，二分搜索树退化为链表（跟节点为第一个元素，在最左，或最右）。</p>
</li>
<li><p>支持重复键值的二分搜索树</p>
<ul>
<li>思路一： 让键值重复节点的右子树或左子树包含键值重复的节点。</li>
<li>思路二： 每个节点增加一个区域（链表或数组），存键值相等的元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><pre><code>- 平衡二叉树：
    - 左右子树高度差不超过1的二叉搜索树，即平衡二叉树所有结点的平衡因子绝对值不超过1（平衡因子 = 结点左子树的高度 - 结点右子树的高度）。
- 实现方式：
    - AVL树
    - 红黑树
    - 2-3树
    - Splay树</code></pre>
<h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><ul>
<li>基本思想，每插入一个节点，自底向上维护树的平衡，以及每个节点的平衡因子</li>
<li>平衡调整的四种类型：<ul>
<li>LL型 右旋调整 调整后涉及到的节点的平衡因子（bf）均为0</li>
<li>RR型 左旋调整 调整后涉及到的节点的平衡因子(bf)均为0</li>
<li>LR型 先左旋调整至LL型， 然后右旋调整 bf的维护如下： </li>
<li>RL型 先右旋调整至RR型， 然后左旋调整<br><img src="/source/pictures/%E5%B9%B3%E8%A1%A1%E8%B0%83%E6%95%B4%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B.bmp"></li>
</ul>
</li>
</ul>
<ul>
<li><p>插入操作思路整理：</p>
<ul>
<li>考虑当前节点的子树是否添加了新节点<ul>
<li>没有 则不用维护，直接返回</li>
<li>左子树添加了新节点 <strong>&gt;&gt;&gt;</strong> 当前节点的平衡因子要加一($bf= bf+1$)<ul>
<li>若$bf&gt;1$(需要平衡调整) <strong>&gt;&gt;&gt;</strong> 进行左平衡调整</li>
</ul>
</li>
<li>右子树添加了新节点 <strong>&gt;&gt;&gt;</strong> 当前节点的平衡因子要减一($bf = bf -1$)<ul>
<li>若$bf&lt;-1$，需要平衡调整 **&gt;&gt;&gt;** 进行右平衡调整</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>左平衡调整(cur.bf &gt; 1)</p>
<ul>
<li>看cur的左子节点L 的平衡因子 L.bf<ul>
<li>L.bf == 1 <strong>&gt;&gt;&gt;</strong> LL型 <strong>&gt;&gt;&gt;</strong> 右旋操作</li>
<li>L.bf == -1 <strong>&gt;&gt;&gt;</strong> LR型 <strong>&gt;&gt;&gt;</strong> 先左旋调整至LL型，然后右旋调整</li>
</ul>
</li>
</ul>
</li>
<li><p>右平衡调整(cur.bf &lt; -1)</p>
<ul>
<li>看cur节点的右孩子节点R 的平衡因子R.bf<ul>
<li>R.bf == -1 <strong>&gt;&gt;&gt;</strong> RR型 <strong>&gt;&gt;&gt;</strong> 左旋操作</li>
<li>R.bf == 1 <strong>&gt;&gt;&gt;</strong> RL型 <strong>&gt;&gt;&gt;</strong> 先右旋调整至RR型，然后左旋调整</li>
</ul>
</li>
</ul>
</li>
<li><p>插入操作代码</p>
<pre><code class="Java">  //插入操作
  void insert(K key,V value) &amp;#123;
      taller = false; //增加了新的一层？？
      root = __insert(root,key,value);
  &amp;#125;

  //返回插入新节点后的根节点
  private AVLNode __insert(AVLNode curNode,K key,V value) &amp;#123;
      if(curNode==null) &amp;#123;
          curNode = new AVLNode(key,value);
          taller = true; //增加了新节点
          return curNode;//
      &amp;#125;
      else &amp;#123;
          if(key.compareTo(curNode.key)==0) &amp;#123;
              return curNode;//节点已经存在，返回（不覆盖旧值）
          &amp;#125;
          else if(key.compareTo(curNode.key)&lt;0) &amp;#123;
              curNode.left = __insert(curNode.left,key,value); //往左子树新增节点
              if(taller) &amp;#123;//增加了新节点
                  switch(curNode.bf) &amp;#123;
                      case 0: //新增节点没有打破平衡，但bf+1
                          curNode.bf = 1;//左边新加一个点
                          taller = true;//此处很重要，自底 向上传递平衡信息
                          break;
                      case 1:  //本来左子树多一个结点，然后taller为true,左子树又增加了一个结点
                          curNode = leftBalance(curNode); //左平衡时必须保证 curNode具有左孩子
                          taller = false; //左平衡后 达到平衡
                          break;
                      case -1: //新增节点使得curNode左右平衡
                          curNode.bf = 0;
                          taller = false;
                          break;
                  &amp;#125;
              &amp;#125;
              return curNode;
          &amp;#125;
          else &amp;#123; //往当前节点的右子树增添节点
              curNode.right = __insert(curNode.right,key,value);//往右子树增加节点
              if(taller) &amp;#123;
                  switch(curNode.bf) &amp;#123;
                      case 0:
                          curNode.bf = -1;
                          taller = true;
                          break;
                      case 1:
                           curNode.bf = 0;
                           taller = false;
                           break;
                      case -1:
                          curNode = rightBalance(curNode);
                          taller = false;
                          break;        
                  &amp;#125;
              &amp;#125;
              return curNode;
          &amp;#125;
      &amp;#125;
  &amp;#125;</code></pre>
</li>
<li><p>左平衡调整代码</p>
<pre><code class="Java">  /*
   * 左平衡操作
   */
  //[当前curNode的bf&gt;0，又再左子树增加节点时需要左平衡操作]
  AVLNode leftBalance(AVLNode curNode) &amp;#123;
      AVLNode L = curNode.left;
      if(L.bf==1) &amp;#123; //LL型需要左旋
          curNode.bf = 0;//右旋平衡
          L.bf = 0;//右旋平衡
          return rightRotate(curNode);
      &amp;#125;
      else if(L.bf==-1) &amp;#123;//LR型需要 先左旋  后右旋
          AVLNode LR = L.right; //左孩子的右孩子
          //以下代码不是很理解,,,画一下实际例子可以明白，，但为啥子LR.bf不会一直被维护为0？（因为LR不一定是新增节点?）
          switch(LR.bf) &amp;#123;
              case 1:
                  curNode.bf = -1;
                  L.bf = 0;
                  break;
              case 0:
                  curNode.bf = 0;
                  L.bf = 0;
                  break;
              case -1:
                  curNode.bf = 0;
                  L.bf = 1;
                  break;
          &amp;#125;
          LR.bf = 0;
          curNode.left = leftRotate(curNode.left);
          return rightRotate(curNode);
      &amp;#125;
      else &amp;#123;//不需要左平衡处理
          return curNode;
      &amp;#125;
  &amp;#125;</code></pre>
</li>
<li><p>右平衡调整代码</p>
<pre><code class="Java">  //右平衡操作
  /*
   * curNode bf本已经-1的基础上，在右方又新增节点
   */
  AVLNode rightBalance(AVLNode curNode) &amp;#123;
      AVLNode R = curNode.right;
      if(R.bf==-1) &amp;#123; //RR型 
          curNode.bf = 0;
          R.bf = 0;
          return leftRotate(curNode);
      &amp;#125;
      else if(R.bf==1) &amp;#123;//RL型
          AVLNode RL = R.left;
          switch(RL.bf) &amp;#123;
              case 0:
                  curNode.bf = 0;
                  R.bf = 0;
                  break;
              case 1:
                  R.bf =-1;
                  curNode.bf = 0;
                  break;
              case -1:
                  curNode.bf = 1;
                  R.bf = 0;
                  break;
          &amp;#125;
          RL.bf = 0;
          curNode.right = rightRotate(R);
          return leftRotate(curNode);

      &amp;#125;
      else &amp;#123;
          return curNode;
      &amp;#125;
  &amp;#125;</code></pre>
</li>
<li><p>左旋操作</p>
<pre><code class="Java">  //左旋操作
  AVLNode leftRotate(AVLNode curNode) &amp;#123;
      AVLNode subRoot = curNode.right;
      curNode.right = subRoot.left;
      subRoot.left = curNode;
      return subRoot;
  &amp;#125;</code></pre>
</li>
<li><p>右旋操作</p>
<pre><code class="Java">  //右旋操作
  AVLNode rightRotate(AVLNode curNode) &amp;#123;
      AVLNode subRoot = curNode.left;//左孩子上位
      curNode.left = subRoot.right;//把你的右孩子给我，作为我的左孩子(保证排序性)
      subRoot.right = curNode;//你上位后我成为你的有孩子
      return subRoot;
  &amp;#125;</code></pre>
</li>
<li><p>其他操作实现：</p>
<ul>
<li>可参考&lt;&lt;数据结构从应用到时间（Java版）&gt;&gt;<h2 id="5-5-多路查找树"><a href="#5-5-多路查找树" class="headerlink" title="5-5 多路查找树"></a>5-5 多路查找树</h2></li>
</ul>
</li>
<li><p>多路查找树的意义</p>
<blockquote>
<p>对于树来说，一个结点只能存储一个元素，那么在元素非常多的时候，就会使得要么树的度非常大（结点拥有子树的个数的最大值），要么树的高度非常大，甚至两者都必须足够大才行，这就使得内存存取外存次数非常多，这显然成了时间效率上的瓶颈，这迫使我们要打破每一个结点只存储一个元素的限制，为此引入了多路查找树的概念</p>
</blockquote>
</li>
<li><p>2-3 树 </p>
<ul>
<li>每个结点都具有两个孩子（我们称它为 2 结点）或三个孩子（我们称它为 3 结点）的树</li>
<li>特性  <pre><code>      一个 2 结点 包含一个元素和两个孩子（或没有孩子），且左子树数据元素小于该元素右子树数据元素大于该元素
    一个 3 结点 包含一小一大两个元素和三个孩子（或没有孩子）
    如果有 3 个孩子的话
    左子树包含小于较小元素的元素
    右子树包含大于较大元素的元素
    中间子树包含介于两元素之间的元素</code></pre>
</li>
</ul>
</li>
<li><p>2-3-4 树</p>
</li>
<li><p>B 树</p>
<h2 id="5-6-树形问题和更多树。"><a href="#5-6-树形问题和更多树。" class="headerlink" title="5-6 树形问题和更多树。"></a>5-6 树形问题和更多树。</h2><ul>
<li>平衡二叉树和堆的结合Treap</li>
<li>trie ：查找效率与单词长度有关，与单词中的单词数量无关</li>
<li>其他树形(递归)问题：<ul>
<li>一条龙游戏</li>
<li>8 数码问题</li>
<li>8 皇后问题</li>
<li>数独</li>
<li>搬运工</li>
</ul>
</li>
<li>更多树的结构<ul>
<li>KD树</li>
<li>区间树</li>
<li>哈夫曼树</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第六章-并查集"><a href="#第六章-并查集" class="headerlink" title="第六章:并查集"></a>第六章:并查集</h1><h2 id="6-1-并查集基础"><a href="#6-1-并查集基础" class="headerlink" title="6-1 并查集基础"></a>6-1 并查集基础</h2><ul>
<li><p>解决的问题： </p>
<ul>
<li>连接问题， 数学中集合类的实现，</li>
<li>路径问题</li>
</ul>
</li>
<li><p>并查集的基本方法</p>
<ul>
<li>union(p,q) 将p与q 联合 （同属一个集合（连通分支））</li>
<li>find(p) 查找p所在集合序号</li>
<li>isConnect(p,q) </li>
</ul>
</li>
<li><p>并查集的实现</p>
<ul>
<li><p>数组实现（QuickFind） （数组索引为元素键值，数组值为对应的集合号）</p>
<ul>
<li>union(p,q) 需要遍历更新所有元素的集合号，时间复杂度O(n)</li>
<li>find(p) 直接数组下标查找，O(1) </li>
<li>isConnect()  复杂度O(1)</li>
</ul>
</li>
<li><p>树形实现（数组索引为元素键值，数组值为该节点的父节点的索引）</p>
<ul>
<li><p>union(p,q) 时间复杂度O(h)，h为树的高度 </p>
</li>
<li><p>find(p) 需要回溯到(所在分支的)跟节点，O(h)，h为树的高度 </p>
</li>
<li><p>isConnect()  复杂度O(h，h为树的高度 </p>
</li>
<li><p>树形实现中 union() 的三种实现方式（不断改进（降低）树的高度h）</p>
<ul>
<li>随机合并</li>
<li>基于size的优化 <ul>
<li>维护一个size数组，存每个分支的元素多少</li>
<li>将元素较少的树合并到元素较多的的树 新的分支size = size1 + size2</li>
</ul>
</li>
<li>基于rank的优化 <ul>
<li>维护一个rank数组，存每个分支对应树的高度</li>
<li>将高度小的和平到高度大的</li>
</ul>
</li>
</ul>
</li>
<li><p>find() 过程中的 路径压缩（降低树的高度）</p>
<ul>
<li><p>基本思想： 基于树形实现的并查集，在find()时，需要回溯到分支树的根节点，在回溯的过程，可以将树的高度进行调整。</p>
</li>
<li><p>具体实现思路： 回溯过程中，将当前节点的父节点不断向上更新</p>
</li>
<li><p>代码</p>
<pre><code class="cpp">// 查找过程, 查找元素p所对应的集合编号
// O(h)复杂度, h为树的高度
private int find(int p)&amp;#123;
  assert( p &gt;= 0 &amp;&amp; p &lt; count );

  // path compression 1
  while( p != parent[p] )&amp;#123;
      parent[p] = parent[parent[p]]; //指向父节点的父节点
      p = parent[p];
  &amp;#125;
  return p;

  // path compression 2, 递归算法
//            if( p != parent[p] )
//                parent[p] = find( parent[p] );
//            return parent[p];
&amp;#125;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>并查集的应用</p>
<ul>
<li>题目<ul>
<li>leetcode130_<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第七章-图"><a href="#第七章-图" class="headerlink" title="第七章: 图"></a>第七章: 图</h1><h2 id="7-1-图论基础"><a href="#7-1-图论基础" class="headerlink" title="7-1 图论基础"></a>7-1 图论基础</h2><ul>
<li>图的应用<ul>
<li>通信网路</li>
<li>社交网络</li>
<li>状态机等</li>
</ul>
</li>
<li>图的分类<ul>
<li>无权图与有权图</li>
<li>有向图与无向图</li>
</ul>
</li>
<li>图的表示<ul>
<li>（n,m） n个顶点，m条边</li>
<li>邻接矩阵 $n * n$矩阵 适合稠密图</li>
<li>邻接表  适合稀疏图</li>
<li>其他<h2 id="7-2-相邻点迭代器"><a href="#7-2-相邻点迭代器" class="headerlink" title="7-2 相邻点迭代器"></a>7-2 相邻点迭代器</h2></li>
</ul>
</li>
<li>图遍历过程中，避不开的便是遍历当前节点的相邻节点</li>
<li>迭代器的思想： 对外提供访问数据的功能，同时避免内部数据直接暴露在外</li>
<li>复杂度分析<ul>
<li>邻接矩阵 O(n) </li>
<li>邻接表 O(m)<h2 id="7-4-图的算法框架"><a href="#7-4-图的算法框架" class="headerlink" title="7-4 图的算法框架"></a>7-4 图的算法框架</h2></li>
</ul>
</li>
<li>读图方式（仅限本课程）<ul>
<li>不断添加边（需要知道顶点数）</li>
</ul>
</li>
</ul>
<h2 id="7-5-深度优先遍历和联通分量"><a href="#7-5-深度优先遍历和联通分量" class="headerlink" title="7-5 深度优先遍历和联通分量"></a>7-5 深度优先遍历和联通分量</h2><ul>
<li>深度优先遍历（DFS)<ul>
<li>基本思想 递归</li>
<li>复杂分析<ul>
<li>邻接表O（V+E）</li>
<li>邻接矩阵O(V^2)</li>
</ul>
</li>
</ul>
</li>
<li>求连通分支<ul>
<li>维护一个size为顶点数的vis数组 （可以存每个节点是否被访问，也可以每个节点存属于哪个分支）</li>
<li>对每一个没有被访问的节点进行深度优先遍历</li>
</ul>
</li>
<li>寻路<ul>
<li>维护一个from 数组 ，from[i]存第i个节点在dfs(s)过程中的上一个节点</li>
<li>从$s$ 节点开始 dfs()</li>
<li>从目的点d 开始，根据from数组回溯，得到s到d的路径<h2 id="7-7-广度优先遍历和最短路径"><a href="#7-7-广度优先遍历和最短路径" class="headerlink" title="7-7 广度优先遍历和最短路径"></a>7-7 广度优先遍历和最短路径</h2></li>
</ul>
</li>
<li>广度优先遍历<ul>
<li>基本思想 迭代</li>
<li>实现细节<ul>
<li><strong>处理环</strong>： 相对于树来说 图存在环的可能，所以遍历的时候是<strong>将加入队列的元素标记为已访问</strong>，而不是访问结点时才标记。</li>
</ul>
</li>
<li>复杂度分析<ul>
<li>邻接表O（V+E）</li>
<li>邻接矩阵O(V^2)</li>
</ul>
</li>
<li>求 无权图的 <strong>最短路径</strong><ul>
<li>维护一个from（回溯）数组，from[i]存第i个节点到dfs(s)过程中的上一个节点</li>
<li>维护一个order数组， order[i] 存 第i个节点在从s开始的bfs过程中的第几层（最短距离）</li>
<li>从$s$ 节点开始 bfs()</li>
<li>从 d 开始，根据from数组回溯<h2 id="7-8-更多无权图的应用"><a href="#7-8-更多无权图的应用" class="headerlink" title="7-8 更多无权图的应用"></a>7-8 更多无权图的应用</h2></li>
</ul>
</li>
</ul>
</li>
<li>迷宫生成，ps抠图等 </li>
</ul>
<hr>
<h1 id="第八章：最小生成树"><a href="#第八章：最小生成树" class="headerlink" title="第八章：最小生成树"></a>第八章：最小生成树</h1><h2 id="8-1-最小生成树问题和切分定理"><a href="#8-1-最小生成树问题和切分定理" class="headerlink" title="8-1 最小生成树问题和切分定理"></a>8-1 最小生成树问题和切分定理</h2><ul>
<li>最小生成树的应用<ul>
<li>电缆布线设计，网络设计，电路设计等。</li>
</ul>
</li>
<li>最小生成树的适用范围<ul>
<li>主要针对 带权 无向 连通图</li>
</ul>
</li>
<li>切分定理<ul>
<li>相关概念<ul>
<li>切分</li>
<li>横切边</li>
</ul>
</li>
<li><strong>切分定理</strong>： 给定任意切分，横切边中权值最小的边必然属于最小生成树<h2 id="8-2-Prim算法及其优化"><a href="#8-2-Prim算法及其优化" class="headerlink" title="8-2 Prim算法及其优化"></a>8-2 Prim算法及其优化</h2></li>
</ul>
</li>
<li>Lazy Prim 算法<ul>
<li>基本思想： 迭代/递归 贪心（每次根据切分定理得到局部最优） 动态规划？</li>
<li>算法流程<ul>
<li>递归/迭代遍历节点</li>
<li>将节点集合 分为  已经<strong>被访问过的节点</strong>和<strong>未被访问过的节点</strong>，并将切分这两个集合的<strong>横切边</strong>存入最小堆中 </li>
<li>每次选择最小堆中的横切边 出堆<ul>
<li>若 该横切边的两个端点均 已经被访问 ， 丢弃该边， 不做操作</li>
<li>否则， 将该边加入最小生成树中，继续<strong>遍历 该边中未被访问的点</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>lazy体现在（局限性）: <ul>
<li>最小堆中，维护的横切边中，有很多不再时横切边的 没有及时丢弃。</li>
<li>复杂度 O(ElogE)</li>
</ul>
</li>
</ul>
</li>
<li>Prim算法的优化<ul>
<li>用<strong>索引堆</strong> (pq)来维护 <ul>
<li>每个已经被访问的点对应的最小横切边 的权重。pq.get（i） 表示第i个节点关联的当前最小横切边权重</li>
<li>上述横切边集合中 的 最小横切边的权重 （最小中的最小） （及堆顶）</li>
<li>用 edgeTo 辅助维护 边的信息（起始点）</li>
</ul>
</li>
<li>用 vis 数组来维护 节点是否已被访问</li>
<li>Prim 算法流程<ul>
<li>初始化： 将起始点的横切边 的权值加入索引堆<strong>pq</strong>中，起始点标记为 已经被访问</li>
<li>循环：<ul>
<li>选<strong>pq</strong>中 最小权值的横切边<strong>e</strong> 加入到最小生成树的 边集合</li>
<li><strong>递归</strong> 选出来边<strong>e</strong>的两个端点中 未被访问的节点v：<ul>
<li>端点v 标记为 已经被访问</li>
<li>遍历端点v 的 邻接边<strong>adjEdge</strong>，邻接边的另一个端点<strong>w</strong><ul>
<li>保证**pq[w]**小（(与w节点关联的当前最小横切边的权重）<ul>
<li>若<strong>pq[w]</strong>) 为空，则将 <strong>adjEdge</strong> 的权重 更新至 <strong>pq[w]</strong></li>
<li>或者若<strong>adjEdge</strong>的权重小于 <strong>pq[w]</strong>  则将 <strong>adjEdge</strong> 的权重更新至<strong>pq[w]</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>复杂度分析 O(ElogV)</li>
</ul>
</li>
</ul>
<h2 id="8-3-Krusk算法"><a href="#8-3-Krusk算法" class="headerlink" title="8-3 Krusk算法"></a>8-3 Krusk算法</h2><ul>
<li>基本思想： 贪心 不断将<strong>不与已添加的边构成圈的最小边</strong> 加入到生成树边集合种</li>
<li>数据结构<ul>
<li>用最小堆，维护边集合，保证每次能取出剩余边中的最小边</li>
<li>用并查集，维护节点在当前生成树边集合下的连通度，判断新增边是否构成环</li>
</ul>
</li>
<li>算法流程<ul>
<li>对边进行排序(复杂度O(ElogE))，用最最小堆来维护边集合。</li>
<li>将最小边出堆，并加入生成树的集合。</li>
<li>循环开始：<ul>
<li>将 剩余边集合中 最小边 出堆<ul>
<li>判断改边与 生成树边集合中的边是否 构成环 （用并查集判断）<ul>
<li>若成环 抛弃， 继续找下一个边</li>
<li>将改边加入生成树的边集合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>复杂度分析 O(ElogE)<h2 id="8-6-最小生成树算法的思考"><a href="#8-6-最小生成树算法的思考" class="headerlink" title="8-6 最小生成树算法的思考"></a>8-6 最小生成树算法的思考</h2></li>
</ul>
</li>
<li>其他最小生成树的算法<ul>
<li>Vyssotsky’s Algorithm 将边逐渐添加到生成树中，一旦形成环，删除环中权值最大的边</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第九章：最短路径"><a href="#第九章：最短路径" class="headerlink" title="第九章：最短路径"></a>第九章：最短路径</h1><h2 id="9-1-最短路径问题和松弛操作"><a href="#9-1-最短路径问题和松弛操作" class="headerlink" title="9-1 最短路径问题和松弛操作"></a>9-1 最短路径问题和松弛操作</h2><ul>
<li>最短路径的应用<ul>
<li>路径规划</li>
<li>工作任务计划</li>
</ul>
</li>
<li>广度优先遍历 求 无权图 的最短路径<ul>
<li>最短路径树 （单源最短路径：一点到所有其他点的最短路径）</li>
</ul>
</li>
<li>松弛操作(Relaxation)<ul>
<li>考虑经过该节点的 是否有到达其他节点的更短的路径<h2 id="9-2-Dijkstra算法的思想"><a href="#9-2-Dijkstra算法的思想" class="headerlink" title="9-2 Dijkstra算法的思想"></a>9-2 Dijkstra算法的思想</h2></li>
</ul>
</li>
<li>适用条件<ul>
<li>图中不能有<strong>负权边</strong></li>
<li>复杂度O(E log V)</li>
</ul>
</li>
<li>实现<ul>
<li>数据结构：<ul>
<li>索引堆： 维护每个节点当前被到达的最短路径， 以及 所有最短路径中的最短路径<ul>
<li>辅助：访问标记数组： 存当前节点是否进行了松弛操作</li>
</ul>
</li>
<li>回溯数组: 存到达该节点的最短路径中的上一个节点</li>
</ul>
</li>
</ul>
</li>
<li>算法流程<ul>
<li>初始化数据结构：<ul>
<li>索引堆<code>IndexMinHeap(imh)</code> imh[w] 表示第w个节点当前最短路径的权值</li>
<li>访问数组 <code>boolean[] marked</code>， marked[i] 表示第 i 个节点<strong>是否</strong>进行过松弛操作，初始都为false</li>
<li>回溯数组<code>int[] from</code>, from[i] 表示目的点为第i个节点的上一个节点，初始均赋值为-1</li>
</ul>
</li>
<li>初始化：将 源节点 $s$ 到自身的路径的权重 加入索引堆</li>
<li>循环（直至索引堆为空）<ul>
<li>当前距离源节点$s$ 最近的节点  $v$ ， 出堆<ul>
<li>如果 $v$ 没有进行过松弛操作（marked[v]==false）, 则对其进行 <strong>松弛操作</strong>：<ul>
<li>对 $v$ 所有邻节点 $w$ :<ul>
<li>如果 $w$ 没有进行过松弛操作（$marked[v]==false$）<ul>
<li>$s$ 经过 $v$ 到达 $w$ 的最短路径为：$dis = dis(s,v) + dis(v,w)$</li>
<li><code>if from[w]==-1||ids&lt;imh[w]</code> <ul>
<li><code>imh[w] = dis</code></li>
<li><code>from[w] = v</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>marked[v] = true</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>实现代码：<ul>
<li>初始化及核心代码<pre><code class="java">//初始化  
marked = new boolean[graph.V()];
from = new int[graph.V()];
for(int i=0;i&lt;graph.V();i++) &amp;#123;
    from[i] = -1;
    marked[i] = false;
&amp;#125;
//Dijkstra
IndexMinHeap&lt;Weight&gt; imh = new IndexMinHeap&lt;&gt;(graph.V());
imh.insert(s, (Weight)(Number)(0.0));
while(!imh.isEmpty()) &amp;#123;
    int v = imh.extractMinIndex();
    if(!marked[v]) 
        Relaxation(v,imh); //Relaxation松弛操作
&amp;#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>  - 松弛操作
```java
        //松弛操作
        void Relaxation(int v, IndexMinHeap imh) &amp;#123;
        marked[v] = true;
        //遍历邻边
        for(Edge&lt;Weight&gt; e : (List&lt;Edge&gt;)graph.adj(v)) &amp;#123;
            int w = e.getOther(v);
            if(!marked[w])
            &amp;#123;
                Double dis = e.getW().doubleValue()+(((Number) imh.getItem(v)).doubleValue());
                if(from[w] == -1||imh.getItem(w).compareTo(dis)&gt;0) &amp;#123;
                    if(!imh.contain(w))
                        imh.insert(w,dis);
                    else 
                        imh.change(w, dis);
                    from[w] = v;
                &amp;#125;

            &amp;#125;
        &amp;#125;</code></pre>
<h2 id="9-3-负权边和Bellman-Ford算法"><a href="#9-3-负权边和Bellman-Ford算法" class="headerlink" title="9-3 负权边和Bellman-Ford算法"></a>9-3 负权边和Bellman-Ford算法</h2><ul>
<li><p>负权边带来的问题</p>
<ul>
<li>每次选择的并不是</li>
<li>负权环</li>
</ul>
</li>
<li><p>Bellman-Ford 单源最短路径算法</p>
<ul>
<li>前提： 图中不能有<strong>负权环</strong></li>
<li>Bellman-Ford 可以判断图中是否有负权环<ul>
<li>如果一个图没有负权环，则：<ul>
<li>从一个顶点到另一个顶点的最短路径，最多经过所有($V$)的顶点，即有$V-1$条边</li>
</ul>
</li>
<li>否则， 存在 顶点 经过了两次， 即 存在<strong>负</strong>权环</li>
</ul>
</li>
<li>复杂度 $O(EV)$</li>
</ul>
</li>
<li><p>Bellman-Ford 基本思想</p>
<ul>
<li>对所有点进行 $v-1$ 次 松弛操作，如果还可以继续松弛，则存在负权环</li>
<li>对所有点(V)进行松弛操作， 遍历所有的边(E),复杂度为O(VE)??</li>
</ul>
</li>
<li><p>算法流程</p>
<ul>
<li>Initial: from[s] = s; distTo[s] = 0;//初始化源节点 信息 </li>
<li>for pass = 1:G.V()-1 : //遍历 G.V()-1 遍<ul>
<li>for(int v=0; v &lt; G.V();v++) : //每一遍对每个节点进行一次松弛操作<ul>
<li>Relaxation(v)：<ul>
<li>如果$v$可达，遍历 $v$ 的所有邻接点 $wi$：<ul>
<li>$dis = dis(s,v) + dis(v,wi)$</li>
<li>if from[w]==-1||dis &lt; dis(s,w) :<ul>
<li>dis(s,w) = dis;</li>
<li>from[w] = v;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>//对每个节点再进行一次松弛操作，如果路径还能再减，则存在<strong>负权环</strong></li>
</ul>
</li>
<li><p>实现代码</p>
<pre><code class="java">      // Bellman-Ford的过程
      // 进行V-1次循环, 每一次循环求出从起点到其余所有点, 最多使用pass步可到达的最短距离
      for( int pass = 1 ; pass &lt; G.V() ; pass ++ )&amp;#123;

          // 每次循环中对所有的边进行一遍松弛操作
          // 遍历所有边的方式是先遍历所有的顶点, 然后遍历和所有顶点相邻的所有边
          for( int i = 0 ; i &lt; G.V() ; i ++ )&amp;#123;
              // 使用我们实现的邻边迭代器遍历和所有顶点相邻的所有边
              for( Object item : G.adj(i) )&amp;#123;
                  Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;)item;
                  // 对于每一个边首先判断e-&gt;v()可达
                  // 之后看如果e-&gt;w()以前没有到达过， 显然我们可以更新distTo[e-&gt;w()]
                  // 或者e-&gt;w()以前虽然到达过, 但是通过这个e我们可以获得一个更短的距离, 即可以进行一次松弛操作, 我们也可以更新distTo[e-&gt;w()]
                  if( from[e.v()] != null &amp;&amp; (from[e.w()] == null || distTo[e.v()].doubleValue() + e.wt().doubleValue() &lt; distTo[e.w()].doubleValue()) )&amp;#123;
                      distTo[e.w()] = distTo[e.v()].doubleValue() + e.wt().doubleValue();
                      from[e.w()] = e;
                  &amp;#125;
              &amp;#125;
          &amp;#125;
      &amp;#125;</code></pre>
</li>
<li><p>检测是否有负权环</p>
<pre><code class="java"> // 判断图中是否有负权环
  boolean detectNegativeCycle()&amp;#123;

      for( int i = 0 ; i &lt; G.V() ; i ++ )&amp;#123;
          for( Object item : G.adj(i) )&amp;#123;
              Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;)item;
              if( from[e.v()] != null &amp;&amp; distTo[e.v()].doubleValue() + e.wt().doubleValue() &lt; distTo[e.w()].doubleValue() )
                  return true;
          &amp;#125;
      &amp;#125;

      return false;
  &amp;#125;
</code></pre>
</li>
</ul>
<pre><code>- queue-based Bellman-Ford
  - 对Bellman-Ford的优化

- 其他
  - 处理负权边通常是针对 **有向图**， 因为无向图的负权边 本身就是一个**负权环**

##    9-4 更多和最短路径相关的思考  
- 单源最短路径算法总结

算法|边的权重|图的有向性|复杂度  
:---|:---|:---|:---
dijkstra|无负权边|有向，无向图均可|$O(ElogV)$
Bellman-Ford|无负权环|有向图,或无负权边的无向图|$O(ElogV)$
利用拓扑排序|有向无环图（DAG）|有向图|$O(V+E)$
- 所有对最短路径算法
  - Floyed算法， 处理无负权环的图，复杂度$O(V^3)$
- 最长路径算法
  - 不能有正权环
  - 无权图的最长路径问题是指数难度的
  - 对于有权图，不能使用Dijkstra求最长路径问题
  - 可以使用Bellman-Ford (把所有路径都取负)

---  
# 第十章：结束语
线性问题 &gt;&gt; 树形问题 &gt;&gt; 图形问题

- 线性问题
  - 排序问题
    - $O(n^2)$ 选择排序 插入排序
    - $O(nlog(n))$ 归并排序 快速排序 

- 更多的算法问题
  - 数据结构相关
    - 双向队列
    - 斐波那契堆
    - 红黑树
    - 区间树
    - KD树
    - ...
  - 具体领域相关
    - 数学： 数论 计算几何
    - 图论： 网络流
- 算法设计相关
  - 分治算法
    - 归并排序，快速算法， 树结构
  - 贪心
    - 选择排序； 堆 ； Kruskal ; Prim; Dijkstra ;...
  - 递归回溯
    - 树的遍历
    - 图的遍历
  - 动态规划
    - 思想： **最优子结构**
    - Prim ; Dijkstra 
- 大家加油！！


</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/12/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shytiger Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">用hexo搭建博客笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-12 10:57:45 / Modified: 15:35:16" itemprop="dateCreated datePublished" datetime="2020-08-12T10:57:45+08:00">2020-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li>nodejs</li>
<li>git</li>
<li>淘宝镜像源</li>
<li>hexo 安装</li>
</ol>
<h2 id="hexo-使用"><a href="#hexo-使用" class="headerlink" title="hexo 使用"></a>hexo 使用</h2><p>hexo s</p>
<p>hexo new “filename”</p>
<p>hexo init</p>
<p>hexo clean</p>
<p>hexo generate</p>
<p>配置git 仓库</p>
<p>hexo d</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shytiger Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-12 10:29:59" itemprop="dateCreated datePublished" datetime="2020-08-12T10:29:59+08:00">2020-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yan</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

      








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  

  

</body>
</html>
