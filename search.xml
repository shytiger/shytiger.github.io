<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ROS学习记录</title>
      <link href="/2020/09/16/ROS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/09/16/ROS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/09/16/HTMLDemo/"/>
      <url>/2020/09/16/HTMLDemo/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html><head><meta charset="utf-8"><title>菜鸟教程(runoob.com)</title></head><body> <!--链接--><a href="#C4">查看章节 4</a></p><h2>章节 1 引言</h2><p>  </p><h2>章节 2 文本标签</h2><!-- 文本格式化 --><p>    <b>这个文本是加粗的</b>    <br />    <strong>这个文本是加粗的</strong>    <br />    <big>这个文本字体放大</big>    <br />    <em>这个文本是斜体的</em>    <br />    <i>这个文本是斜体的</i>    <br />    <small>这个文本是缩小的</small>    <br />    这个文本包含<sub>下标</sub>    <br />    这个文本包含<sup>上标</sup></p><!-- 预格式文本 --><p>    <pre>        此例演示如何使用 pre 标签        对空行和    空格        进行控制            上为空行    </pre></p><!--计算机输出标签显示效果--><p>    <code>计算机输出</code>    <br />    <kbd>键盘输入</kbd>    <br />    <tt>打字机文本</tt>    <br />    <samp>计算机代码样本</samp>    <br />    <var>计算机变量</var>    <br />    <p>    <b>注释：</b>这些标签常用于显示计算机/编程代码。    </p></p><!--地址--><p>    <address>        Written by <a href="mailto:webmaster@example.com">Jon Doe</a>.<br>         Visit us at:<br>        Example.com<br>        Box 564, Disneyland<br>        USA    </address></p><!--缩略词标签 鼠标放置相应位置显示更多--><p>    <abbr title="etcetera">etc.</abbr>    <br />    <acronym title="World Wide Web">WWW</acronym>    <p>        abbr：表示全词的缩写；        acronym：表示标记一个首字母缩写；    </p>    <p>在某些浏览器中，当您把鼠标移至缩略词语上时，title 可用于展示表达的完整版本。</p>    <p>仅对于 IE 5 中的 acronym 元素有效。</p>    <p>对于 Netscape 6.2 中的 abbr 和 acronym 元素都有效。</p></p><!--文字方向--><p>    <p>该段落文字从左到右显示。</p>      <p><bdo dir="rtl">该段落文字从右到左显示。</bdo></p>  </p><!--块引用--><p>WWF's goal is to: <q>Build a future where people live in harmony with nature.</q>We hope they succeed.</p><!--删除字效果--><p>My favorite color is <del>blue</del> <ins>red</ins>!</p><!--文本格式小结--><p><pre>    &lt; &gt;    b---bold    em---emphasize    i--italic    sub---subscript    sup---superscript    ins---insert    del---delete    kbd---keyboard    bdo---Bi-Directional Override    q---quate    dfn---define</pre></p><h2>章节 3 图片标签</h2><p>这边显示该章节的内容……</p><h2><a id="C4">章节 4 链接标签</a></h2><p>这边显示该章节的内容……</p><h2>章节 5 列表标签</h2><p>    早上起床    <ol type="I" start = "5">        <li>睁眼</li>        <li>摸手机</li>        <li>解锁</li>        <li>刷手机</li>        <li>起床</li>    </ol>    <!--type: disc square circle-->    早上起床    <ul type="square">        <li>睁眼</li>        <li>摸手机</li>        <li>解锁</li>        <li>刷手机</li>        <li>起床</li>    </ul></p><h2>章节 6</h2><p>这边显示该章节的内容……</p><h2>章节 7</h2><p>这边显示该章节的内容……</p><h2>章节 8</h2><p>这边显示该章节的内容……</p><h2>章节 9</h2><p>这边显示该章节的内容……</p><h2>章节 10</h2><p>这边显示该章节的内容……</p><h2>章节 11</h2><p>这边显示该章节的内容……</p><h2>章节 12</h2><p>这边显示该章节的内容……</p><h2>章节 13</h2><p>这边显示该章节的内容……</p><h2>章节 14</h2><p>这边显示该章节的内容……</p><h2>章节 15</h2><p>这边显示该章节的内容……</p><h2>章节 16</h2><p>这边显示该章节的内容……</p><h2>章节 17</h2><p>这边显示该章节的内容……</p><a href="//www.runoob.com/" target="_top">点击这里!</a> </body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小知识记录</title>
      <link href="/2020/09/16/%E5%B0%8F%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/09/16/%E5%B0%8F%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="UTF-8和GBK的区别"><a href="#UTF-8和GBK的区别" class="headerlink" title="UTF-8和GBK的区别"></a>UTF-8和GBK的区别</h1><p><a href="https://blog.csdn.net/qq_37859539/article/details/79857476">UTF-8和GBK的区别</a><br><a href="https://blog.csdn.net/u010234516/article/details/52853214?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">锟斤拷？UTF-8与GBK互转，为什么会乱码？</a></p><ul><li><p>GBK</p><ul><li>GBK的中文编码是双字节来表示的，英文编码是用ASC||码表示的</li><li>为区分中文，将其最高位都定成1。英文单字节最高位都为0。</li><li>GBK包含全部中文字符</li></ul></li><li><p>UTF-8</p><ul><li>兼容ASCII，存储英文文件都是单字节，文件小。</li><li>中文使用24位（三个字节）来编码。 </li><li>UTF-8则包含全世界所有国家需要用到的字符。</li><li>对于某一个字符的UTF-8编码，如果只有一个字节则其最高二进制位为0；如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的位数，其余各字节均以10开头。UTF-8最多可用到6个字节。</li></ul></li><li><p>UTF-16</p><ul><li>双字节存储，这就带来一个问题，即高低字节的顺序。两个字节有两种顺序，它们也用BOM来标明。分为大尾码和小尾码两种。大尾码的BOM是FEFF，小尾码的BOM是FFF</li></ul></li><li><p>BOM（Byte Order Mark）。</p><ul><li>用windows自带的记事本创建一个utf8格式的文件，就会加上这个标记。但是，如果用ultraedit创建utf8文件，并不会加上这个标记。</li></ul></li><li><p>转换</p><ul><li>UTF-8 &gt; GBK &gt;UTF8  顺利还原 </li><li>GBK &gt; UTF-8 &gt; GBK 乱码（GBK&gt;UTF-8时可能产生了不存在于UTF-8中的序列）</li><li>小结<ul><li>以非UTF-8编码编码出的字节数组，一旦以UTF-8进行解码，通常这是一条不归路，再尝试将解码出的字符以UTF-8进行编码，也无法还原之前的字节数组。</li><li>相反地，其他的固定长度编码几乎都可以顺利还原。</li></ul></li></ul></li><li><p>java是使用什么编码来保存字符的呢？</p><ul><li>unicode 编码可以表示所有字符   (具体实现还是UTF-16编码)</li><li>每种编码都会提供和unicode编码之间的转换规则。</li><li>字符串直接量new一个String，这个String就是以unicode在内存中存储的。</li><li>为什么一个char中既可以存储一个字母，也可以存储一个汉字，明明很多编码如GBK、UTF-8中汉字和字母的长度不一样。如果java虚拟机使用unicode编码，那这一切就很好理解了，字母和汉字长度一样。(char类型的变量也是占用两个字节)  </li></ul></li></ul><h1 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h1><ul><li>get：<ol><li>请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。</li><li>请求参数大小是有限制的。</li><li>不太安全。</li></ol></li><li>post：<ol start="2"><li>请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)</li><li>请求参数的大小没有限制。</li><li>较为安全。</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>玩转算法面试leetcode记录</title>
      <link href="/2020/09/15/%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95leetcode%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/09/15/%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95leetcode%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><a href="https://github.com/liuyubobobo/Play-with-Algorithm-Interview.git">Github</a></p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="解决面试问题的整体思路"><a href="#解决面试问题的整体思路" class="headerlink" title="解决面试问题的整体思路"></a>解决面试问题的整体思路</h2><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="面试中的时间复杂度"><a href="#面试中的时间复杂度" class="headerlink" title="面试中的时间复杂度"></a>面试中的时间复杂度</h2><h2 id="对数据规模的一个概念"><a href="#对数据规模的一个概念" class="headerlink" title="对数据规模的一个概念"></a>对数据规模的一个概念</h2><h2 id="常见的复杂度分析"><a href="#常见的复杂度分析" class="headerlink" title="常见的复杂度分析"></a>常见的复杂度分析</h2><h2 id="复杂度实验"><a href="#复杂度实验" class="headerlink" title="复杂度实验"></a>复杂度实验</h2><h2 id="递归算法的复杂度分析"><a href="#递归算法的复杂度分析" class="headerlink" title="递归算法的复杂度分析"></a>递归算法的复杂度分析</h2><h2 id="均摊复杂度分析"><a href="#均摊复杂度分析" class="headerlink" title="均摊复杂度分析"></a>均摊复杂度分析</h2><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="数组中的问题"><a href="#数组中的问题" class="headerlink" title="数组中的问题"></a>数组中的问题</h2><h2 id="基本算法思路的应用"><a href="#基本算法思路的应用" class="headerlink" title="基本算法思路的应用"></a>基本算法思路的应用</h2><h2 id="双索引技术"><a href="#双索引技术" class="headerlink" title="双索引技术"></a>双索引技术</h2><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="两类查找问题"><a href="#两类查找问题" class="headerlink" title="两类查找问题"></a>两类查找问题</h2><h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="在链表中穿针引线"><a href="#在链表中穿针引线" class="headerlink" title="在链表中穿针引线"></a>在链表中穿针引线</h2><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="栈和队列的使用"><a href="#栈和队列的使用" class="headerlink" title="栈和队列的使用"></a>栈和队列的使用</h2><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="二叉树和递归"><a href="#二叉树和递归" class="headerlink" title="二叉树和递归"></a>二叉树和递归</h2><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="递归与回溯"><a href="#递归与回溯" class="headerlink" title="递归与回溯"></a>递归与回溯</h2><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h2 id="二维平面上使用回溯法"><a href="#二维平面上使用回溯法" class="headerlink" title="二维平面上使用回溯法"></a>二维平面上使用回溯法</h2><h2 id="回溯法是经典人工智能的基础"><a href="#回溯法是经典人工智能的基础" class="headerlink" title="回溯法是经典人工智能的基础"></a>回溯法是经典人工智能的基础</h2><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习记录</title>
      <link href="/2020/09/15/HTML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/09/15/HTML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. web概念概述2. HTML</code></pre><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JavaWeb：    * 使用Java语言开发基于互联网的项目* 软件架构：    1. C/S: Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装，部署，维护 麻烦    2. B/S: Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序        * 优点：            1. 开发、安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高* B/S架构详解    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样。                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 我们要学习动态资源，必须先学习静态资源！    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><pre><code>1. 概念：是最基础的网页开发语言    * Hyper Text Markup Language 超文本标记语言        * 超文本:            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.        * 标记语言:            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml            * 标记语言不是编程语言2. 快速入门：    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，但是建议使用小写。    * 代码：        &lt;html&gt;            &lt;head&gt;                &lt;title&gt;title&lt;/title&gt;            &lt;/head&gt;            &lt;body&gt;                &lt;FONT color=&#39;red&#39;&gt;Hello World&lt;/font&gt;&lt;br/&gt;                &lt;font color=&#39;green&#39;&gt;Hello World&lt;/font&gt;            &lt;/body&gt;        &lt;/html&gt;3. 标签学习：    1. 文件标签：构成html最基本的标签        * html:html文档的根标签        * head：头标签。用于指定html文档的一些属性。引入外部的资源        * title：标题标签。        * body：体标签        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档    2. 文本标签：和文本有关的标签        * 注释：&lt;!-- 注释内容 --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6:字体大小逐渐递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对其方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;:字体标签        * &lt;center&gt;:文本居中            * 属性：                * color：颜色                * size：大小                * face：字体        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF            * width：                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)                2. 数值%：占比相对于父元素的比例    3. 图片标签：        * img：展示图片            * 属性：                * src：指定图片的位置        * 代码：             &lt;!--展示一张图片 img--&gt;            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;            &lt;!--                相对路径                    * 以.开头的路径                        * ./：代表当前目录  ./image/1.jpg                        * ../:代表上一级目录             --&gt;            &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;            &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;    4. 列表标签：        * 有序列表：            * ol:            * li:        * 无序列表：            * ul:            * li:    5. 链接标签：        * a:定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self:默认值，在当前页面打开                    * _blank：在空白页面打开        * 代码：             &lt;!--超链接  a--&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;    6. div和span：        * div:每一个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签 内联标签    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。        1. &lt;header&gt;：页眉        2. &lt;footer&gt;：页脚    8. 表格标签：        只有行的概念 没有列的概念        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并列            * rowspan：合并行        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分</code></pre><h2 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h2><pre><code>1. 确定使用table来完成布局    2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;3. 如果某一行有多个单元格，则使用    &lt;tr&gt;        &lt;td&gt;            &lt;table&gt;&lt;/table&gt;        &lt;/td&gt;    &lt;/tr&gt;4. 代码实现    &lt;!DOCTYPE html&gt;    &lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;黑马旅游网&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--采用table来完成布局--&gt;        &lt;!--最外层的table，用于整个页面的布局--&gt;        &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;           &lt;!-- 第1行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第2行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第3行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt;                        &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt;                            &lt;td&gt;                                &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;                            &lt;/td&gt;                            &lt;td&gt;                                门票                            &lt;/td&gt;                            &lt;td&gt;                                门票                            &lt;/td&gt;                            &lt;td&gt;                                门票                            &lt;/td&gt;                            &lt;td&gt;                                门票                            &lt;/td&gt;                            &lt;td&gt;                                门票                            &lt;/td&gt;                            &lt;td&gt;                                门票                            &lt;/td&gt;                            &lt;td&gt;                                门票                            &lt;/td&gt;                            &lt;td&gt;                                门票                            &lt;/td&gt;                            &lt;td&gt;                                门票                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第4行 轮播图 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第5行 黑马精选--&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt;                    黑马精选                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第6行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第7行 国内游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt;                    国内游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第8行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第9行 境外游 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt;                    境外游                    &lt;hr  color=&quot;#ffd700&quot; &gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第10行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt;                        &lt;tr&gt;                            &lt;td rowspan=&quot;2&quot;&gt;                                &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt;                            &lt;/td&gt;                            &lt;td&gt;                                &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td&gt;                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                            &lt;td&gt;                               &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt;                                &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt;                                &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第11行 --&gt;            &lt;tr&gt;                &lt;td&gt;                    &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;!-- 第12行 --&gt;            &lt;tr&gt;                &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt;                    &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;                    江苏传智播客教育科技股份有限公司                    版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882                    &lt;/font&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h1 id="今日内容："><a href="#今日内容：" class="headerlink" title="今日内容："></a>今日内容：</h1><pre><code>1. HTML标签：表单标签2. CSS：</code></pre><h2 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h2><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围        * 属性：            * action：指定提交数据的URL            * method:指定提交方式                * 分类：一共7种，2种比较常用                   * get：                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。                        2. 请求参数大小是有限制的。                        3. 不太安全。                   * post：                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制。                        3. 较为安全。        * 表单项中的数据要想被提交：必须指定其name属性    * 表单项标签：        * input：可以通过type属性值，改变元素展示的样式            * type属性：                * text：文本输入框，默认值                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息                    * password：密码输入框                * radio:单选框                    * 注意：                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        3. checked属性，可以指定默认值                * checkbox：复选框                    * 注意：                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        2. checked属性，可以指定默认值                * file：文件选择框                * hidden：隐藏域，用于提交一些信息。                * 按钮：                    * submit：提交按钮。可以提交表单                    * button：普通按钮                    * image：图片提交按钮                        * src属性指定图片的路径               * label：指定输入项的文字描述信息               * 注意：                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。        * select: 下拉列表            * 子元素：option，指定列表项        * textarea：文本域            * cols：指定列数，每一行有多少个字符            * rows：默认多少行。</code></pre><h2 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h2><pre><code>1. 概念： Cascading Style Sheets 层叠样式表    * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处：    1. 功能强大    2. 将内容展示和样式控制分离        * 降低耦合度。解耦        * 让分工协作更容易        * 提高开发效率3. CSS的使用：CSS与html结合方式    1. 内联样式         * 在标签内使用style属性指定css代码         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;    2. 内部样式        * 在head标签内，定义style标签，style标签的标签体内容就是css代码        * 如：            &lt;style&gt;                div&#123;                    color:blue;                &#125;            &lt;/style&gt;            &lt;div&gt;hello css&lt;/div&gt;    3. 外部样式        1. 定义css资源文件。        2. 在head标签内，定义link标签，引入外部的资源文件        * 如：            * a.css文件：                div&#123;                    color:green;                &#125;            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;            &lt;div&gt;hello css&lt;/div&gt;            &lt;div&gt;hello css&lt;/div&gt;    * 注意：        * 1,2,3种方式 css作用范围越来越大        * 1方式不常用，后期常用2,3        * 3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;4. css语法：    * 格式：        选择器 &#123;            属性名1:属性值1;            属性名2:属性值2;            ...        &#125;    * 选择器:筛选具有相似特征的元素    * 注意：        * 每一对属性需要使用；隔开，最后一对属性可以不加；5. 选择器：筛选具有相似特征的元素    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一                * 语法：#id属性值&#123;&#125;            2. 元素选择器：选择具有相同标签名称的元素                * 语法： 标签名称&#123;&#125;                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性值的元素。                * 语法：.class属性值&#123;&#125;                * 注意：类选择器选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素：                * 语法： *&#123;&#125;            2. 并集选择器：                * 选择器1,选择器2&#123;&#125;            3. 子选择器：筛选选择器1元素下的选择器2元素                * 语法：  选择器1 选择器2&#123;&#125;            4. 父选择器：筛选选择器2的父元素选择器1                * 语法：  选择器1 &gt; 选择器2&#123;&#125;            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;            6. 伪类选择器：选择一些元素具有的状态                * 语法： 元素:状态&#123;&#125;                * 如： &lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态6. 属性    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-align：对其方式        * line-height：行高     2. 背景        * background：    3. 边框        * border：设置边框，符合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小        * float：浮动            * left            * right</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><ul><li><p>框架<br><img src="https://img-blog.csdnimg.cn/20200916170406610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p><pre><code>  &lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;注册页面&lt;/title&gt;  &lt;style&gt;      *&#123;          margin: 0px;          padding: 0px;          box-sizing: border-box;      &#125;      body&#123;          background: url(&quot;img/register_bg.png&quot;) no-repeat center;          padding-top: 25px;      &#125;      .rg_layout&#123;          width: 900px;          height: 500px;          border: 8px solid #EEEEEE;          background-color: white;          /*让div水平居中*/          margin: auto;      &#125;      .rg_left&#123;          /*border: 1px solid red;*/          float: left;          margin: 15px;      &#125;      .rg_left &gt; p:first-child&#123;          color:#FFD026;          font-size: 20px;      &#125;      .rg_left &gt; p:last-child&#123;          color:#A6A6A6;          font-size: 20px;      &#125;</code></pre></li></ul><pre><code>        .rg_center&#123;            float: left;           /* border: 1px solid red;*/        &#125;        .rg_right&#123;            /*border: 1px solid red;*/            float: right;            margin: 15px;        &#125;        .rg_right &gt; p:first-child&#123;            font-size: 15px;        &#125;        .rg_right p a &#123;            color:pink;        &#125;        .td_left&#123;            width: 100px;            text-align: right;            height: 45px;        &#125;        .td_right&#123;            padding-left: 50px ;        &#125;        #username,#password,#email,#name,#tel,#birthday,#checkcode&#123;            width: 251px;            height: 32px;            border: 1px solid #A6A6A6 ;            /*设置边框圆角*/            border-radius: 5px;            padding-left: 10px;        &#125;        #checkcode&#123;            width: 110px;        &#125;        #img_check&#123;            height: 32px;            vertical-align: middle;        &#125;        #btn_sub&#123;            width: 150px;            height: 40px;            background-color: #FFD026;            border: 1px solid #FFD026 ;        &#125;    &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;div class=&quot;rg_layout&quot;&gt;        &lt;div class=&quot;rg_left&quot;&gt;            &lt;p&gt;新用户注册&lt;/p&gt;            &lt;p&gt;USER REGISTER&lt;/p&gt;        &lt;/div&gt;        &lt;div class=&quot;rg_center&quot;&gt;            &lt;div class=&quot;rg_form&quot;&gt;                &lt;!--定义表单 form--&gt;                &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;                    &lt;table&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男                                &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女                            &lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;                            &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;                                &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                        &lt;tr&gt;                            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;                        &lt;/tr&gt;                    &lt;/table&gt;                &lt;/form&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;rg_right&quot;&gt;            &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC学习记录</title>
      <link href="/2020/09/12/JDBC%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/09/12/JDBC%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h1><pre><code>1. JDBC基本概念2. 快速入门3. 对JDBC中各个接口和类详解</code></pre><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门：    * 步骤：        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下            2.右键--&gt;Add As Library        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接受返回结果        7. 处理结果        8. 释放资源    * 代码实现：          //1. 导入驱动jar包        //2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);        //4.定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        //5.获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //6.执行sql        int count = stmt.executeUpdate(sql);        //7.处理结果        System.out.println(count);        //8.释放资源        stmt.close();        conn.close();3. 详解各个对象：    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。                 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                 static &#123;                        try &#123;                            java.sql.DriverManager.registerDriver(new Driver());                        &#125; catch (SQLException E) &#123;                            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);                        &#125;                    &#125;                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接：                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子：jdbc:mysql://localhost:3306/db3                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql 的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                 * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql) ：可以执行任意的sql 了解             2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码：                Statement stmt = null;                Connection conn = null;                try &#123;                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;                    //3.获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);                    //4.获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5.执行sql                    int count = stmt.executeUpdate(sql);//影响的行数                    //6.处理结果                    System.out.println(count);                    if(count &gt; 0)&#123;                        System.out.println(&quot;添加成功！&quot;);                    &#125;else&#123;                        System.out.println(&quot;添加失败！&quot;);                    &#125;                &#125; catch (ClassNotFoundException e) &#123;                    e.printStackTrace();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    //stmt.close();                    //7. 释放资源                    //避免空指针异常                    if(stmt != null)&#123;                        try &#123;                            stmt.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                    if(conn != null)&#123;                        try &#123;                            conn.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;    4. ResultSet：结果集对象,封装查询结果        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx：代表数据类型   如： int getInt() ,    String getString()            * 参数：                1. int：代表列的编号,从1开始   如： getString(1)                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)        * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据               //循环判断游标是否是最后一行末尾。                while(rs.next())&#123;                    //获取数据                    //6.2 获取数据                    int id = rs.getInt(1);                    String name = rs.getString(&quot;name&quot;);                    double balance = rs.getDouble(3);                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);                &#125;        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll()&#123;&#125;                3. 实现方法 select * from emp;    5. PreparedStatement：执行sql的对象        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题            1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a            2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;         2. 解决sql注入问题：使用PreparedStatement对象来解决        3. 预编译的SQL：参数使用?作为占位符        4. 步骤：            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            2. 注册驱动            3. 获取数据库连接对象 Connection            4. 定义sql                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)             6. 给？赋值：                * 方法： setXxx(参数1,参数2)                    * 参数1：？的位置编号 从1 开始                    * 参数2：？的值            7. 执行sql，接受返回结果，不需要传递sql语句            8. 处理结果            9. 释放资源        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止SQL注入            2. 效率更高</code></pre><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=    3. 抽取一个方法释放资源* 代码实现：    public class JDBCUtils &#123;    private static String url;    private static String user;    private static String password;    private static String driver;    /**     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块     */    static&#123;        //读取资源文件，获取值。        try &#123;            //1. 创建Properties集合类。            Properties pro = new Properties();            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);            String path = res.getPath();            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties            //2. 加载文件           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));            pro.load(new FileReader(path));            //3. 获取数据，赋值            url = pro.getProperty(&quot;url&quot;);            user = pro.getProperty(&quot;user&quot;);            password = pro.getProperty(&quot;password&quot;);            driver = pro.getProperty(&quot;driver&quot;);            //4. 注册驱动            Class.forName(driver);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 获取连接     * @return 连接对象     */    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url, user, password);    &#125;    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(Statement stmt,Connection conn)&#123;        if( stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( conn != null)&#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(ResultSet rs,Statement stmt, Connection conn)&#123;        if( rs != null)&#123;            try &#123;                rs.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( conn != null)&#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登录成功            * select * from user where username = &quot;&quot; and password = &quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)            );            INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);            INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;);        2. 代码实现：            public class JDBCDemo9 &#123;                public static void main(String[] args) &#123;                    //1.键盘录入，接受用户名和密码                    Scanner sc = new Scanner(System.in);                    System.out.println(&quot;请输入用户名：&quot;);                    String username = sc.nextLine();                    System.out.println(&quot;请输入密码：&quot;);                    String password = sc.nextLine();                    //2.调用方法                    boolean flag = new JDBCDemo9().login(username, password);                    //3.判断结果，输出不同语句                    if(flag)&#123;                        //登录成功                        System.out.println(&quot;登录成功！&quot;);                    &#125;else&#123;                        System.out.println(&quot;用户名或密码错误！&quot;);                    &#125;                &#125;                /**                 * 登录方法                 */                public boolean login(String username ,String password)&#123;                    if(username == null || password == null)&#123;                        return false;                    &#125;                    //连接数据库判断是否登录成功                    Connection conn = null;                    Statement stmt =  null;                    ResultSet rs = null;                    //1.获取连接                    try &#123;                        conn =  JDBCUtils.getConnection();                        //2.定义sql                        String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39; &quot;;                        //3.获取执行sql的对象                        stmt = conn.createStatement();                        //4.执行查询                        rs = stmt.executeQuery(sql);                        //5.判断                       /* if(rs.next())&#123;//如果有下一行，则返回true                            return true;                        &#125;else&#123;                            return false;                        &#125;*/                       return rs.next();//如果有下一行，则返回true                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;finally &#123;                        JDBCUtils.close(rs,stmt,conn);                    &#125;                    return false;                &#125;            &#125;</code></pre><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作：    1. 开启事务    2. 提交事务    3. 回滚事务3. 使用Connection对象来管理事务    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务        * 在执行sql之前开启事务    * 提交事务：commit()         * 当所有sql都执行完提交事务    * 回滚事务：rollback()         * 在catch中回滚事务4. 代码：    public class JDBCDemo10 &#123;        public static void main(String[] args) &#123;            Connection conn = null;            PreparedStatement pstmt1 = null;            PreparedStatement pstmt2 = null;            try &#123;                //1.获取连接                conn = JDBCUtils.getConnection();                //开启事务                conn.setAutoCommit(false);                //2.定义sql                //2.1 张三 - 500                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;                //2.2 李四 + 500                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;                //3.获取执行sql对象                pstmt1 = conn.prepareStatement(sql1);                pstmt2 = conn.prepareStatement(sql2);                //4. 设置参数                pstmt1.setDouble(1,500);                pstmt1.setInt(2,1);                pstmt2.setDouble(1,500);                pstmt2.setInt(2,2);                //5.执行sql                pstmt1.executeUpdate();                // 手动制造异常                int i = 3/0;                pstmt2.executeUpdate();                //提交事务                conn.commit();            &#125; catch (Exception e) &#123;                //事务回滚                try &#123;                    if(conn != null) &#123;                        conn.rollback();                    &#125;                &#125; catch (SQLException e1) &#123;                    e1.printStackTrace();                &#125;                e.printStackTrace();            &#125;finally &#123;                JDBCUtils.close(pstmt1,conn);                JDBCUtils.close(pstmt2,null);            &#125;        &#125;    &#125;</code></pre><h1 id="daty02"><a href="#daty02" class="headerlink" title="daty02"></a>daty02</h1><pre><code>1. 数据库连接池2. Spring JDBC : JDBC Template</code></pre><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法    * 代码：        public class JDBCUtils &#123;            //1.定义成员变量 DataSource            private static DataSource ds ;            static&#123;                try &#123;                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;            /**             * 获取连接             */            public static Connection getConnection() throws SQLException &#123;                return ds.getConnection();            &#125;            /**             * 释放资源             */            public static void close(Statement stmt,Connection conn)&#123;               /* if(stmt != null)&#123;                    try &#123;                        stmt.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                if(conn != null)&#123;                    try &#123;                        conn.close();//归还连接                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;*/               close(null,stmt,conn);            &#125;            public static void close(ResultSet rs , Statement stmt, Connection conn)&#123;                if(rs != null)&#123;                    try &#123;                        rs.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                if(stmt != null)&#123;                    try &#123;                        stmt.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                if(conn != null)&#123;                    try &#123;                        conn.close();//归还连接                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;            /**             * 获取连接池方法             */            public static DataSource getDataSource()&#123;                return  ds;            &#125;        &#125;</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：            import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;            import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;            public class JdbcTemplateDemo2 &#123;                //Junit单元测试，可以让方法独立执行                //1. 获取JDBCTemplate对象                private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                /**                 * 1. 修改1号数据的 salary 为 10000                 */                @Test                public void test1()&#123;                    //2. 定义sql                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;                    //3. 执行sql                    int count = template.update(sql);                    System.out.println(count);                &#125;                /**                 * 2. 添加一条记录                 */                @Test                public void test2()&#123;                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                &#125;                /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3()&#123;                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                &#125;                /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4()&#123;                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;                &#125;                /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                    for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;                        System.out.println(stringObjectMap);                    &#125;                &#125;                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;                        @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                            emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                            return emp;                        &#125;                    &#125;);                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6_2()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                /**                 * 7. 查询总记录数                 */                @Test                public void test7()&#123;                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                &#125;            &#125;</code></pre><h1 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h1><pre><code>1. 数据库连接池2. Spring JDBC : JDBC Template</code></pre><h2 id="数据库连接池-1"><a href="#数据库连接池-1" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法    * 代码：        public class JDBCUtils &#123;            //1.定义成员变量 DataSource            private static DataSource ds ;            static&#123;                try &#123;                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;            /**             * 获取连接             */            public static Connection getConnection() throws SQLException &#123;                return ds.getConnection();            &#125;            /**             * 释放资源             */            public static void close(Statement stmt,Connection conn)&#123;               /* if(stmt != null)&#123;                    try &#123;                        stmt.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                if(conn != null)&#123;                    try &#123;                        conn.close();//归还连接                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;*/               close(null,stmt,conn);            &#125;            public static void close(ResultSet rs , Statement stmt, Connection conn)&#123;                if(rs != null)&#123;                    try &#123;                        rs.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                if(stmt != null)&#123;                    try &#123;                        stmt.close();                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                if(conn != null)&#123;                    try &#123;                        conn.close();//归还连接                    &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;            /**             * 获取连接池方法             */            public static DataSource getDataSource()&#123;                return  ds;            &#125;        &#125;</code></pre><h2 id="Spring-JDBC-1"><a href="#Spring-JDBC-1" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：            import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;            import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;            public class JdbcTemplateDemo2 &#123;                //Junit单元测试，可以让方法独立执行                //1. 获取JDBCTemplate对象                private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                /**                 * 1. 修改1号数据的 salary 为 10000                 */                @Test                public void test1()&#123;                    //2. 定义sql                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;                    //3. 执行sql                    int count = template.update(sql);                    System.out.println(count);                &#125;                /**                 * 2. 添加一条记录                 */                @Test                public void test2()&#123;                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                &#125;                /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3()&#123;                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                &#125;                /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4()&#123;                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;                &#125;                /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                    for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;                        System.out.println(stringObjectMap);                    &#125;                &#125;                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;                        @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                            emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                            return emp;                        &#125;                    &#125;);                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6_2()&#123;                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) &#123;                        System.out.println(emp);                    &#125;                &#125;                /**                 * 7. 查询总记录数                 */                @Test                public void test7()&#123;                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                &#125;            &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习记录</title>
      <link href="/2020/09/11/Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/09/11/Linux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h1><h2 id="linux启动和登录"><a href="#linux启动和登录" class="headerlink" title="linux启动和登录"></a>linux启动和登录</h2><p> <img src="https://img-blog.csdnimg.cn/20200911093653451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="linux-目录"><a href="#linux-目录" class="headerlink" title="linux 目录"></a>linux 目录</h2><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg" alt="在这里插入图片描述">  </p><h2 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h2><p>/bin 可执行文件<br>/boot 内核启动程序<br>/lib 库目录<br>/media 挂载多媒体路径<br>/mnt 为了让用户挂在别的文件系统<br>/usr 很多应用会安装在此目录<br>/sbin 超级管理员 的执行文件 比如ifconfig<br>/proc 系统内存的映射，会保留一些进程运行的信息<br>/etc  系统软件的启动配置目录<br>/dev设备文件所在目录<br><a href="https://www.runoob.com/linux/linux-system-contents.html">参考链接</a></p><h3 id="根目录和用户目录"><a href="#根目录和用户目录" class="headerlink" title="根目录和用户目录"></a>根目录和用户目录</h3><p><img src="https://img-blog.csdnimg.cn/20200911093804909.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2020/09/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/09/10/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql学习记录</title>
      <link href="/2020/09/09/MySql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/09/09/MySql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h1><ol><li>数据库的基本概念</li></ol><ol start="2"><li><p>MySQL数据库软件</p><ol><li>安装</li><li>卸载</li><li>配置</li></ol></li><li><p>SQL</p></li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL4. 常见的数据库软件    * 参见《MySQL基础.pdf》</code></pre><h2 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h2><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit</code></pre><ul><li>MySQL目录结构<br><img src="https://img-blog.csdnimg.cn/20200909200123480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><pre><code>      1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;          * 配置文件 my.ini      2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;          * 几个概念              * 数据库：文件夹              * 表：文件              * 数据：数据</code></pre></li></ul><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><p><img src="https://img-blog.csdnimg.cn/20200909202418343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;         * 查看某个数据库的字符集             * show create database database-name    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：    select        字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名；        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略3. 条件查询    1. where子句后跟条件    2. 运算符        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !            -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;            SELECT * FROM student WHERE age &gt;= 20;            -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;            -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;            -- 查询年龄大于等于20 小于等于30            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;            -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);            -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断            SELECT * FROM student WHERE english IS NULL;            -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;            -- 查询姓名第二个字是化的人            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;            -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;            -- 查询姓名中包含德的人            SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;</code></pre><h1 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h1><pre><code>1. DQL:查询语句    1. 排序查询    2. 聚合函数    3. 分组查询    4. 分页查询2. 约束3. 多表之间的关系4. 范式5. 数据库的备份和还原</code></pre><h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h1><pre><code>1. 排序查询    * 语法：order by 子句        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...    * 排序方式：        * ASC：升序，默认的。        * DESC：降序。    * 注意：        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。    1. count：计算个数        1. 一般选择非空的列：主键        2. count(*) 不推荐    2. max：计算最大值    3. min：计算最小值    4. sum：计算和    5. avg：计算平均值    * 注意：聚合函数的计算，排除null值。        解决方案：            1. 选择不包含非空的列进行计算            2. IFNULL函数3. 分组查询:    1. 语法：group by 分组字段；    2. 注意：        1. 分组之后查询的字段：分组字段、聚合函数        2. where 和 having 的区别？            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。        -- 按照性别分组。分别查询男、女同学的平均分        SELECT sex , AVG(math) FROM student GROUP BY sex;        -- 按照性别分组。分别查询男、女同学的平均分,人数        SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;        SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;4. 分页查询    1. 语法：limit 开始的索引,每页查询的条数;    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数        -- 每页显示3条记录            SELECT * FROM student LIMIT 0,3; -- 第1页        SELECT * FROM student LIMIT 3,3; -- 第2页        SELECT * FROM student LIMIT 6,3; -- 第3页    3. limit 是一个MySQL&quot;方言&quot;</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    * 分类：    1. 主键约束：primary key    2. 非空约束：not null    3. 唯一约束：unique    4. 外键约束：foreign key* 非空约束：not null，某一列的值不能为null    1. 创建表时添加约束        CREATE TABLE stu(            id INT,            NAME VARCHAR(20) NOT NULL -- name为非空        );    2. 创建表完后，添加非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;    3. 删除name的非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20);* 唯一约束：unique，某一列的值不能重复    1. 注意：        * 唯一约束可以有NULL值，但是只能有一条记录为null    2. 在创建表时，添加唯一约束        CREATE TABLE stu(            id INT,            phone_number VARCHAR(20) UNIQUE -- 手机号        );    3. 删除唯一约束        ALTER TABLE stu DROP INDEX phone_number;    4. 在表创建完后，添加唯一约束        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。    1. 注意：        1. 含义：非空且唯一        2. 一张表只能有一个字段为主键        3. 主键就是表中记录的唯一标识    2. 在创建表时，添加主键约束        create table stu(            id int primary key,-- 给id添加主键约束            name varchar(20)        );    3. 删除主键        -- 错误 alter table stu modify id int ;        ALTER TABLE stu DROP PRIMARY KEY;    4. 创建完表后，添加主键        ALTER TABLE stu MODIFY id INT PRIMARY KEY;    5. 自动增长：        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长        2. 在创建表时，添加主键约束，并且完成主键自增长        create table stu(            id int primary key auto_increment,-- 给id添加主键约束            name varchar(20)        );        3. 删除自动增长        ALTER TABLE stu MODIFY id INT;        4. 添加自动增长        ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。    1. 在创建表时，可以添加外键        * 语法：            create table 表名(                ....                外键列                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)            );    2. 删除外键        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;    3. 创建表之后，添加外键        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);    4. 级联操作        1. 添加级联操作            语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称                     FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;        2. 分类：            1. 级联更新：ON UPDATE CASCADE             2. 级联删除：ON DELETE CASCADE </code></pre><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><pre><code>1. 多表之间的关系    1. 分类：        1. 一对一(了解)：            * 如：人和身份证            * 分析：一个人只有一个身份证，一个身份证只能对应一个人        2. 一对多(多对一)：            * 如：部门和员工            * 分析：一个部门有多个员工，一个员工只能对应一个部门        3. 多对多：            * 如：学生和课程            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择    2. 实现关系：        1. 一对多(多对一)：            * 如：部门和员工            * 实现方式：在多的一方建立外键，指向一的一方的主键。</code></pre><p><img src="https://img-blog.csdnimg.cn/20200910191623461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="一对多"></p><pre><code>        2. 多对多：            * 如：学生和课程            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</code></pre><p><img src="https://img-blog.csdnimg.cn/20200910192032808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="多对多"></p><pre><code>        3. 一对一(了解)：            * 如：人和身份证            * 实现方式：一对一关系实现，可以在任意一方添加**唯一**外键指向另一方的主键。    3. 案例        -- 创建旅游线路分类表 tab_category        -- cid 旅游线路分类主键，自动增长        -- cname 旅游线路分类名称非空，唯一，字符串 100        CREATE TABLE tab_category (            cid INT PRIMARY KEY AUTO_INCREMENT,            cname VARCHAR(100) NOT NULL UNIQUE        );        -- 创建旅游线路表 tab_route        /*        rid 旅游线路主键，自动增长        rname 旅游线路名称非空，唯一，字符串 100        price 价格        rdate 上架时间，日期类型        cid 外键，所属分类        */        CREATE TABLE tab_route(            rid INT PRIMARY KEY AUTO_INCREMENT,            rname VARCHAR(100) NOT NULL UNIQUE,            price DOUBLE,            rdate DATE,            cid INT,            FOREIGN KEY (cid) REFERENCES tab_category(cid)        );        /*创建用户表 tab_user        uid 用户主键，自增长        username 用户名长度 100，唯一，非空        password 密码长度 30，非空        name 真实姓名长度 100        birthday 生日        sex 性别，定长字符串 1        telephone 手机号，字符串 11        email 邮箱，字符串长度 100        */        CREATE TABLE tab_user (            uid INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(100) UNIQUE NOT NULL,            PASSWORD VARCHAR(30) NOT NULL,            NAME VARCHAR(100),            birthday DATE,            sex CHAR(1) DEFAULT &#39;男&#39;,            telephone VARCHAR(11),            email VARCHAR(100)        );        /*        创建收藏表 tab_favorite        rid 旅游线路 id，外键        date 收藏时间        uid 用户 id，外键        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次        */        CREATE TABLE tab_favorite (            rid INT, -- 线路id            DATE DATETIME,            uid INT, -- 用户id            -- 创建复合主键            PRIMARY KEY(rid,uid), -- 联合主键            FOREIGN KEY (rid) REFERENCES tab_route(rid),            FOREIGN KEY(uid) REFERENCES tab_user(uid)        );2. 数据库设计的范式    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 分类：        1. 第一范式（1NF）：每一列都是不可分割的原子数据项        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）            * 几个概念：                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称） --&gt; 分数                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称） -- &gt; 姓名                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                    例如：学号--&gt;系名，系名--&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                    例如：该表中码为：（学号，课程名称）                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre><ul><li><p>原表格<br><img src="https://img-blog.csdnimg.cn/2020091020260320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>第一范式 每一列都是不可分割的原子数据项<br><img src="https://img-blog.csdnimg.cn/20200910202648650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>第二范式 消除部分函数依赖<br><img src="https://img-blog.csdnimg.cn/20200910202706792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>第三范式 消除传递依赖<br><img src="https://img-blog.csdnimg.cn/20200910202731231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><ol><li>命令行：<ul><li>语法：·<ul><li>备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</li><li>还原：<ol><li>登录数据库</li><li>创建数据库</li><li>使用数据库</li><li>执行文件。source 文件路径</li></ol></li></ul></li></ul></li><li>图形化工具：      </li></ol></li></ul><h1 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h1><pre><code>1. 多表查询2. 事务3. DCL</code></pre><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><pre><code>* 查询语法：    select        列名列表    from        表名列表    where....* 准备sql    # 创建部门表    CREATE TABLE dept(        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(20)    );    INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);    # 创建员工表    CREATE TABLE emp (        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1), -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dept_id INT,        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)    );    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);* 笛卡尔积：    * 有两个集合A,B .取这两个集合的所有组成情况。    * 要完成多表查询，需要消除无用的数据* 多表查询的分类：    1. 内连接查询：        1. 隐式内连接：使用where条件消除无用数据            * 例子：            -- 查询所有员工信息和对应的部门信息            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;            -- 查询员工表的名称，性别。部门表的名称            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;            SELECT                 t1.name, -- 员工表的姓名                t1.gender,-- 员工表的性别                t2.name -- 部门表的名称            FROM                emp t1,                dept t2            WHERE                 t1.`dept_id` = t2.`id`;        2. 显式内连接：            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件            * 例如：                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;                    * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;            3. 内连接查询：            1. 从哪些表中查询数据            2. 条件是什么            3. 查询哪些字段    2. 外链接查询：        1. 左外连接：            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；            * 查询的是左表所有数据以及其交集部分。            * 例子：                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称                SELECT     t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;        2. 右外连接：            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；            * 查询的是右表所有数据以及其交集部分。            * 例子：                SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;    3. 子查询：        * 概念：查询中嵌套查询，称嵌套查询为子查询。            -- 查询工资最高的员工信息            -- 1 查询最高的工资是多少 9000            SELECT MAX(salary) FROM emp;            -- 2 查询员工信息，并且工资等于9000的            SELECT * FROM emp WHERE emp.`salary` = 9000;            -- 一条sql就完成这个操作。子查询            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);        * 子查询不同情况            1. 子查询的结果是单行单列的：                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =                *                 -- 查询员工工资小于平均工资的人                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);            2. 子查询的结果是多行单列的：                * 子查询可以作为条件，使用运算符in来判断                -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息                SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;;                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;                -- 子查询                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);            3. 子查询的结果是多行多列的：                * 子查询可以作为一张虚拟表参与查询                * 注：虚拟表中不要有分号（提前结束）                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息                -- 子查询                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2                WHERE t1.id = t2.dept_id;                -- 普通内连接                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;    * 多表查询练习            -- 部门表            CREATE TABLE dept (              id INT PRIMARY KEY PRIMARY KEY, -- 部门id              dname VARCHAR(50), -- 部门名称              loc VARCHAR(50) -- 部门所在地            );            -- 添加4个部门            INSERT INTO dept(id,dname,loc) VALUES             (10,&#39;教研部&#39;,&#39;北京&#39;),            (20,&#39;学工部&#39;,&#39;上海&#39;),            (30,&#39;销售部&#39;,&#39;广州&#39;),            (40,&#39;财务部&#39;,&#39;深圳&#39;);            -- 职务表，职务名称，职务描述            CREATE TABLE job (              id INT PRIMARY KEY,              jname VARCHAR(20),              description VARCHAR(50)            );            -- 添加4个职务            INSERT INTO job (id, jname, description) VALUES            (1, &#39;董事长&#39;, &#39;管理整个公司，接单&#39;),            (2, &#39;经理&#39;, &#39;管理部门员工&#39;),            (3, &#39;销售员&#39;, &#39;向客人推销产品&#39;),            (4, &#39;文员&#39;, &#39;使用办公软件&#39;);            -- 员工表            CREATE TABLE emp (              id INT PRIMARY KEY, -- 员工id              ename VARCHAR(50), -- 员工姓名              job_id INT, -- 职务id              mgr INT , -- 上级领导              joindate DATE, -- 入职日期              salary DECIMAL(7,2), -- 工资              bonus DECIMAL(7,2), -- 奖金              dept_id INT, -- 所在部门编号              CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),              CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)            );            -- 添加员工            INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES             (1001,&#39;孙悟空&#39;,4,1004,&#39;2000-12-17&#39;,&#39;8000.00&#39;,NULL,20),            (1002,&#39;卢俊义&#39;,3,1006,&#39;2001-02-20&#39;,&#39;16000.00&#39;,&#39;3000.00&#39;,30),            (1003,&#39;林冲&#39;,3,1006,&#39;2001-02-22&#39;,&#39;12500.00&#39;,&#39;5000.00&#39;,30),            (1004,&#39;唐僧&#39;,2,1009,&#39;2001-04-02&#39;,&#39;29750.00&#39;,NULL,20),            (1005,&#39;李逵&#39;,4,1006,&#39;2001-09-28&#39;,&#39;12500.00&#39;,&#39;14000.00&#39;,30),            (1006,&#39;宋江&#39;,2,1009,&#39;2001-05-01&#39;,&#39;28500.00&#39;,NULL,30),            (1007,&#39;刘备&#39;,2,1009,&#39;2001-09-01&#39;,&#39;24500.00&#39;,NULL,10),            (1008,&#39;猪八戒&#39;,4,1004,&#39;2007-04-19&#39;,&#39;30000.00&#39;,NULL,20),            (1009,&#39;罗贯中&#39;,1,NULL,&#39;2001-11-17&#39;,&#39;50000.00&#39;,NULL,10),            (1010,&#39;吴用&#39;,3,1006,&#39;2001-09-08&#39;,&#39;15000.00&#39;,&#39;0.00&#39;,30),            (1011,&#39;沙僧&#39;,4,1004,&#39;2007-05-23&#39;,&#39;11000.00&#39;,NULL,20),            (1012,&#39;李逵&#39;,4,1006,&#39;2001-12-03&#39;,&#39;9500.00&#39;,NULL,30),            (1013,&#39;小白龙&#39;,4,1004,&#39;2001-12-03&#39;,&#39;30000.00&#39;,NULL,20),            (1014,&#39;关羽&#39;,4,1007,&#39;2002-01-23&#39;,&#39;13000.00&#39;,NULL,10);            -- 工资等级表            CREATE TABLE salarygrade (              grade INT PRIMARY KEY,   -- 级别              losalary INT,  -- 最低工资              hisalary INT -- 最高工资            );            -- 添加5个工资等级            INSERT INTO salarygrade(grade,losalary,hisalary) VALUES             (1,7000,12000),            (2,12010,14000),            (3,14010,20000),            (4,20010,30000),            (5,30010,99990);            -- 需求：            -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述            /*                分析：                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表                    2.查询条件 emp.job_id = job.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description` -- 职务描述            FROM                 emp t1, job t2            WHERE                 t1.`job_id` = t2.`id`;            -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置            /*                分析：                    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description`, -- 职务描述                t3.`dname`, -- 部门名称                t3.`loc` -- 部门位置            FROM                 emp t1, job t2,dept t3            WHERE                 t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;            -- 3.查询员工姓名，工资，工资等级            /*                分析：                    1.员工姓名，工资 emp  工资等级 salarygrade                    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary                        emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.ename ,                t1.`salary`,                t2.*            FROM emp t1, salarygrade t2            WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;            -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级            /*                分析：                    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.`ename`,                t1.`salary`,                t2.`jname`,                t2.`description`,                t3.`dname`,                t3.`loc`,                t4.`grade`            FROM                 emp t1,job t2,dept t3,salarygrade t4            WHERE                 t1.`job_id` = t2.`id`                 AND t1.`dept_id` = t3.`id`                AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;            -- 5.查询出部门编号、部门名称、部门位置、部门人数            /*                分析：                    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表                    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)                    3.使用子查询将第2步的查询结果和dept表进行关联查询            */            SELECT                 t1.`id`,t1.`dname`,t1.`loc` , t2.total            FROM                 dept t1,                (SELECT                    dept_id,COUNT(id) total                FROM                     emp                GROUP BY dept_id) t2            WHERE t1.`id` = t2.dept_id;            -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询            /*                分析：                    1.姓名 emp， 直接上级的姓名 emp                        * emp表的id 和 mgr 是自关联                    2.条件 emp.id = emp.mgr                    3.查询左表的所有数据，和 交集数据                        * 使用左外连接查询            */            /*            select                t1.ename,                t1.mgr,                t2.`id`,                t2.ename            from emp t1, emp t2            where t1.mgr = t2.`id`;            */            SELECT                 t1.ename,                t1.mgr,                t2.`id`,                t2.`ename`            FROM emp t1            LEFT JOIN emp t2            ON t1.`mgr` = t2.`id`;</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. 事务的基本介绍    1. 概念：        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。    2. 操作：        1. 开启事务： start transaction;        2. 回滚：rollback;        3. 提交：commit;</code></pre><p><img src="https://img-blog.csdnimg.cn/20200911152804495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> </p><pre><code>    3. 例子：        CREATE TABLE account (            id INT PRIMARY KEY AUTO_INCREMENT,            NAME VARCHAR(10),            balance DOUBLE        );        -- 添加数据        INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);        SELECT * FROM account;        UPDATE account SET balance = 1000;        -- 张三给李四转账 500 元        -- 0. 开启事务        START TRANSACTION;        -- 1. 张三账户 -500        UPDATE account SET balance = balance - 500 WHERE NAME = &#39;zhangsan&#39;;        -- 2. 李四账户 +500        -- 出错了...        UPDATE account SET balance = balance + 500 WHERE NAME = &#39;lisi&#39;;        -- 发现执行没有问题，提交事务        COMMIT;        -- 发现出问题了，回滚事务        ROLLBACK;    4. MySQL数据库中事务默认自动提交        * 事务提交的两种方式：            * 自动提交：                * mysql就是自动提交的                * 一条DML(增删改)语句会自动提交一次事务。            * 手动提交：                * Oracle 数据库默认是手动提交事务                * 需要先开启事务，再提交        * 修改事务的默认提交方式：            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交            * 修改默认提交方式： set @@autocommit = 0;2. 事务的四大特征：    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。    3. 隔离性：多个事务之间。相互独立。    4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解）    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。    * 存在问题：        1. 脏读：一个事务，读取到另一个事务中没有提交的数据        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。    * 隔离级别：        1. read uncommitted：读未提交            * 产生的问题：脏读、不可重复读、幻读        2. read committed：读已提交 （Oracle）            * 产生的问题：不可重复读、幻读        3. repeatable read：可重复读 （MySQL默认）            * 产生的问题：幻读        4. serializable：串行化            * 可以解决所有的问题        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低        * 数据库查询隔离级别：            * select @@tx_isolation;        * 数据库设置隔离级别：            * set global transaction isolation level  级别字符串;    * 演示：        set global transaction isolation level read uncommitted;        start transaction;        -- 转账操作        update account set balance = balance - 500 where id = 1;        update account set balance = balance + 500 where id = 2;</code></pre><h2 id="DCL："><a href="#DCL：" class="headerlink" title="DCL："></a>DCL：</h2><pre><code>* SQL分类：    1. DDL：操作数据库和表    2. DML：增删改表中数据    3. DQL：查询表中数据    4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权    1. 管理用户        1. 添加用户：            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;        2. 删除用户：            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;        3. 修改用户密码：            UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;            SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);            SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);            * mysql中忘记了root用户的密码？                1. cmd -- &gt; net stop mysql 停止mysql服务                    * 需要管理员运行该cmd                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功                4. use mysql;                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;                6. 关闭两个窗口                7. 打开任务管理器，手动结束mysqld.exe 的进程                8. 启动mysql服务                9. 使用新密码登录。        4. 查询用户：            -- 1. 切换到mysql数据库            USE myql;            -- 2. 查询user表            SELECT * FROM USER;            * 通配符： % 表示可以在任意主机使用用户登录数据库    2. 权限管理：        1. 查询权限：            -- 查询权限            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;            SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;        2. 授予权限：            -- 授予权限            grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;            -- 给张三用户授予所有权限，在任意数据库任意表上            GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;        3. 撤销权限：            -- 撤销权限：            revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;            REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="一-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#一-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="一 OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>一 OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="五层体系结构"></p><p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p><h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><p><strong>域名系统</strong></p><blockquote><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、cisco公司的域名是/">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/">www.cisco.com</a> 等。</p></blockquote><p><strong>HTTP协议</strong></p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote><h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><p><strong>运输层主要使用以下两种协议:</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><p><strong>TCP 与 UDP 的对比见问题三。</strong></p><h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p><h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><p>sd = socket(protofamily,type,proto);</p><ul><li>创建套接字</li><li>操作系统返回套接字描述符（sd）</li><li>第一个参数（协议族）：protofamily = PF_INET(TCP/IP)</li><li>第二个参数（套接字类型）<ul><li>type = SOCK_STREAM,SOCK_DGRAM or SOCK_RAW (TCP) </li></ul></li><li>第三个参数（协议号）：0为默认</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 单元测试 反射 注解</title>
      <link href="/2020/09/08/Java-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/09/08/Java-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h2><ul><li><p>测试分类：</p><ol><li>黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。</li><li>白盒测试：需要写代码的。关注程序具体的执行流程。</li></ol></li><li><p>Junit使用：白盒测试</p><ul><li><p>步骤：</p><ol><li><p>定义一个测试类(测试用例)</p><ul><li>建议：<ul><li>测试类名：被测试的类名Test        CalculatorTest</li><li>包名：xxx.xxx.xx.test        cn.itcast.test</li></ul></li></ul></li><li><p>定义测试方法：可以独立运行</p><ul><li>建议：<ul><li>方法名：test测试的方法名        testAdd()  </li><li>返回值：void</li><li>参数列表：空参</li></ul></li></ul></li><li><p>给方法加@Test</p></li><li><p>导入junit依赖环境</p></li></ol></li><li><p>判定结果：</p><ul><li>红色：失败</li><li>绿色：成功</li><li>一般我们会使用断言操作来处理结果<ul><li>Assert.assertEquals(期望的结果,运算的结果);</li></ul></li></ul></li><li><p>补充：</p><ul><li>@Before:<ul><li>修饰的方法会在测试方法之前被自动执行</li></ul></li><li>@After:<ul><li>修饰的方法会在测试方法执行之后自动被执行</li></ul></li></ul></li></ul></li></ul><h2 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h2><ul><li>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</li><li>反射：将类的各个组成部分封装为其他对象，这就是反射机制</li><li>好处：<ol><li>可以在程序运行过程中，操作这些对象。</li><li>可以解耦，提高程序的可扩展性。</li></ol></li></ul><ul><li>Java代码正在计算机中 经历的阶段：三个阶段<br><img src="https://img-blog.csdnimg.cn/20200908205159655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200908205616920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><ul><li>获取Class对象的方式：</li></ul><ol><li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象<ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li></ul></li><li>类名.class：通过类名的属性class获取<ul><li>多用于参数的传递</li></ul></li><li>对象.getClass()：getClass()方法在Object类中定义着。<ul><li>多用于对象的获取字节码的方式</li></ul></li></ol><ul><li>结论：<br>  同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</li></ul><ul><li><p>Class对象功能：</p></li><li><p>获取功能：</p><ol><li><p>获取成员变量们</p><ul><li><p>Field[] getFields() ：获取所有public修饰的成员变量</p></li><li><p>Field getField(String name)   获取指定名称的 public修饰的成员变量</p></li><li><p>Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</p></li><li><p>Field getDeclaredField(String name)  </p></li></ul></li><li><p>获取构造方法们</p><ul><li><p>Constructor&lt;?&gt;[] getConstructors()  </p></li><li><p>Constructor<T> getConstructor(类&lt;?&gt;… parameterTypes)  </p></li><li><p>Constructor<T> getDeclaredConstructor(类&lt;?&gt;… parameterTypes)  </p></li><li><p>Constructor&lt;?&gt;[] getDeclaredConstructors()  </p></li></ul></li><li><p>获取成员方法们：</p><ul><li><p>Method[] getMethods()  </p></li><li><p>Method getMethod(String name, 类&lt;?&gt;… parameterTypes)  </p></li><li><p>Method[] getDeclaredMethods()  </p></li><li><p>Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes)  </p></li></ul></li><li><p>获取全类名    </p><ul><li>String getName()  </li></ul></li></ol></li></ul><ul><li><p>Field：成员变量</p></li><li><p>操作：</p><ol><li><p>设置值</p><ul><li>void set(Object obj, Object value)  </li></ul></li><li><p>获取值</p><ul><li>get(Object obj) </li></ul></li><li><p>忽略访问权限修饰符的安全检查</p><ul><li>setAccessible(true):暴力反射</li></ul></li></ol></li></ul><ul><li><p>Constructor:构造方法</p></li><li><p>创建对象：</p><ul><li><p>T newInstance(Object… initargs)  </p></li><li><p>如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</p></li></ul></li></ul><ul><li><p>Method：方法对象</p></li><li><p>执行方法：</p><ul><li>Object invoke(Object obj, Object… args)  </li></ul></li><li><p>获取方法名称：</p><ul><li>String getName:获取方法名</li></ul></li></ul><ul><li>案例：</li><li>需求：写一个”框架”，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法<ul><li>实现：<ol><li>配置文件</li><li>反射</li></ol></li><li>步骤：<ol><li>将需要创建的对象的全类名和需要执行的方法定义在<strong>配置文件</strong>中<ul><li>改配置文件的好处：改代码需要重新编译</li></ul></li><li>在程序中加载读取配置文件</li><li>使用反射技术来加载类文件进内存</li><li>创建对象</li><li>执行方法</li></ol></li></ul></li></ul><h2 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h2><ul><li><p>概念：说明程序的。给计算机看的</p></li><li><p>注释：用文字描述程序的。给程序员看的</p></li><li><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p></li><li><p>概念描述：</p></li><li><p>JDK1.5之后的新特性</p></li><li><p>说明程序的</p></li><li><p>使用注解：@注解名称</p></li></ul><ul><li>作用分类：<br>①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 javadoc命令<br>②代码分析：通过代码里标识的注解对代码进行分析【使用反射】<br>③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li></ul><ul><li>其他<ul><li>相关命令<ul><li>javac编译</li><li>javap反编译</li><li>javadoc 生成文档</li></ul></li></ul></li></ul><ul><li><p>JDK中预定义的一些注解</p></li><li><p>@Override    ：检测被该注解标注的方法是否是继承自父类(接口)的</p></li><li><p>@Deprecated：该注解标注的内容，表示已过时</p></li><li><p>@SuppressWarnings：压制警告</p><ul><li>一般传递参数all  @SuppressWarnings(“all”)</li></ul></li><li><p>自定义注解</p></li><li><p>格式：<br>  元注解<br>  public @interface 注解名称{</p><pre><code>  属性列表;</code></pre><p>  }</p></li><li><p>本质：注解本质上就是一个接口，该接口默认继承Annotation接口</p><ul><li>public interface MyAnno extends java.lang.annotation.Annotation {}</li></ul></li></ul><ul><li><p>属性：接口中的抽象方法</p><ul><li><p>要求：</p><ol><li><p>属性的返回值类型有下列取值</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li><p>定义了属性，在使用时需要给属性赋值</p><ol><li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li></ol></li></ol></li></ul></li><li><p>元注解：用于描述注解的注解</p><ul><li>@Target：描述注解能够作用的位置<ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li>@Retention：描述注解被保留的阶段<ul><li>@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到<ul><li>Source 不会保留到class字节码文件中</li><li>Class 会保留到class字节码文件中，不会被JVM读取到</li><li>Runtime 一般用这个</li></ul></li></ul></li><li>@Documented：描述注解是否被抽取到api文档中</li><li>@Inherited：描述注解是否被子类继承</li></ul></li></ul><ul><li><p>注解的应用</p><ul><li>用来替换配置文件</li></ul></li><li><p>在程序使用(解析)注解：获取注解中定义的属性值</p></li></ul><ol><li><p>获取注解定义的位置的对象  （Class，Method,Field）</p></li><li><p>获取指定的注解</p><ul><li><p>getAnnotation(Class)<br>//其实就是在内存中生成了一个该注解接口的子类实现对象</p><pre><code>  public class ProImpl implements Pro&#123;      public String className()&#123;          return &quot;cn.itcast.annotation.Demo1&quot;;      &#125;      public String methodName()&#123;          return &quot;show&quot;;      &#125;  &#125;</code></pre></li></ul></li><li><p>调用注解中的抽象方法获取配置的属性值</p></li></ol><ul><li>案例：简单的测试框架</li><li>小结：</li></ul><ol><li>以后大多数时候，我们会使用注解，而不是自定义注解</li><li>注解给谁用？<ol><li>编译器</li><li>给解析程序用</li></ol></li><li>注解不是程序的一部分，可以理解为注解就是一个标签</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2020/09/05/Java%E9%9B%86%E5%90%88/"/>
      <url>/2020/09/05/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>优质博客<ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md">JavaGuide</a></li><li><a href="https://www.cnblogs.com/jing99/p/7057245.html">java集合继承关系图</a>  </li><li><a href="https://www.runoob.com/java/java-stack-class.html">https://www.runoob.com/java/java-stack-class.html</a>  </li></ul></li></ul><h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><ul><li>java集合框架图<br><img src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif"><br><img src="https://img-blog.csdnimg.cn/20200905155442847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><h1 id="集合涉及到的常见接口"><a href="#集合涉及到的常见接口" class="headerlink" title="集合涉及到的常见接口"></a>集合涉及到的常见接口</h1><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><ul><li>主要方法<ul><li>boolean hasNext()</li><li>E next()  </li></ul></li></ul><h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><ul><li>重写compareTo方法（大于 返回正  == 返回0 小于 返回负）  </li></ul><h2 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h2><ul><li>从写compare()方法  </li></ul><h1 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h1><p><img src="https://img-blog.csdnimg.cn/20200905162053918.png#pic_center" alt="在这里插入图片描述"><br><strong>集合中存储的都是对象的引用(地址)。</strong>  </p><ul><li>集合的输出<ul><li>四种输出方式<ul><li>Iterator</li><li>ListIterator</li><li>Enumeration</li><li>foreach</li></ul></li><li>注意：<ul><li><em>在迭代时，不可以通过集合对象的方法操作集合中的元素，因为会发生ConcurrentModificationException异常。所以，在迭代器时，只能用迭代器的放过操作元素，可是Iterator方法是有限的，只能对元素进行判断，取出，删除的操作，如果想要其他的操作如添加，修改等，就需要使用其子接口，ListIterator。该接口只能通过List集合的listIterator方法获取。</em>  </li></ul></li></ul></li></ul><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>(对付顺序的好帮手)： 存储的元素是有序的、可重复的。<br><img src="https://img-blog.csdnimg.cn/20200905162201254.png#pic_center" alt="在这里插入图片描述"></p><h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><ul><li>Object[] 数组</li><li>查询快</li><li>add(E e) O(1)</li><li>add(int index, E element)  O(n-i)  </li><li>优秀参考：<ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md">通过源码一步一步分析 ArrayList 扩容机制</a>  </li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList.md">ArrayList核心源码</a>   </li></ul></li></ul><h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><ul><li>双向链表实现</li><li>查询慢</li><li>add(E e)  O(1)</li><li>add(int index, E element) o(n)   </li></ul><style>table th:first-of-type {    width: 2cm;}table th:nth-of-type(2) {    width: 300pt;}table th:nth-of-type(3) {    width: 12em;}table th:nth-of-type(4) {    width: 12em;}table th:nth-of-type(5) {    width: 12em;}</style>  <table><thead><tr><th>操作类型</th><th>增</th><th>删除</th><th>改</th><th>查</th></tr></thead><tbody><tr><td>函数</td><td>add​(int index, E element)<br> add​(E e)<br> <strong>offer​(E e)</strong><br> addAll​(Collection&lt;? extends E&gt; c)<br> <strong>addFirst​(E e)</strong><br> <strong>addLast​(E e)</strong><br></td><td>clear​()<br> poll​()<br> remove​(int index)<br> remove​(Object o)<br></td><td>set​(int index, E element)<br></td><td>contains​(Object o)<br>  get​(int index)<br></td></tr></tbody></table><ul><li>LinkedList可以实现List,Queue,Deque(双端队列)接口  </li></ul><h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><ul><li>线程安全的，效率低  </li></ul><h4 id="Stack类"><a href="#Stack类" class="headerlink" title="Stack类"></a>Stack类</h4><p>Vector类的子类</p><ol><li>boolean empty()<br>判断栈是否为空</li><li>E peek()<br>返回栈顶对象，不移除</li><li>E pop()<br>返回栈顶对象，并移除</li><li>E push(E item)<br>压入栈顶</li><li>int search(Object o)<br>返回对象在栈的位置  </li></ol><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><ul><li><p>Queue接口定义了如下6个方法，我们常用的LinkedList类就实现了Queue接口。 </p><ol><li>boolean add(E e)<br>向队列中添加元素</li><li>E element()<br>返回队列的头，且不移除</li><li>boolean offer(E e)<br>向队列中添加元素</li><li>E peek()<br>返回队列的头，且不移除</li><li>E poll()<br>返回队列的头，且移除</li><li>E remove()<br>返回队列的头，且移除<br>add、element、remove会在操作失败时抛出异常，而offer、peek、poll在操作失败时返回特殊值。   </li></ol></li><li><p><strong>offer()与add()的区别</strong></p><ul><li>超出队列界限时，add（）方法是抛出异常让你处理，而offer（）方法是直接返回false</li><li>推荐使用offer()  </li></ul></li></ul><h3 id="PriorityQueue类"><a href="#PriorityQueue类" class="headerlink" title="PriorityQueue类"></a>PriorityQueue类</h3><ul><li>概述<br>实际上是一个堆（不指定Comparator时默认为最小堆）<br>队列既可以根据元素的自然顺序来排序，也可以根据 Comparator来设置排序规则。<br>队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素。<br>新建对象的时候可以指定一个初始容量，其容量会自动增加。</li><li>参考博客<br><a href="https://www.cnblogs.com/gnivor/p/4841191.html">Java学习笔记–PriorityQueue(优先队列)(堆)</a>  </li><li>注意点<ul><li><strong>插入方法（offer()、poll()、remove() 、add() 方法）时间复杂度为O(log(n))</strong> ；</li><li>**remove(Object) 和 contains(Object) 时间复杂度为O(n)**；</li><li>检索方法（peek、element 和 size）时间复杂度为常量。</li><li>不允许使用 null 元素。</li><li>不是同步的。不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue实例。保证线程安全可以使用PriorityBlockingQueue 类。</li><li>该队列是用数组实现，但是数组大小可以动态增加，容量无限。</li><li>此类及其迭代器实现了 Collection 和 Iterator 接口的所有可选 方法。</li><li>可以在构造函数中指定如何排序。<code>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code></li></ul></li></ul><p>优先队列主要方法： </p><table><thead><tr><th>Modifier and Type</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean</td><td>add​(E e)</td><td>将指定的元素插入到此优先级队列中。</td></tr><tr><td>void</td><td>clear​()</td><td>从此优先级队列中删除所有元素。</td></tr><tr><td>Comparator&lt;? super E&gt;</td><td>comparator​()</td><td>返回用于为了在这个队列中的元素，或比较null如果此队列根据所述排序natural ordering的元素。</td></tr><tr><td>boolean</td><td>contains​(Object o)</td><td>如果此队列包含指定的元素，则返回 true 。</td></tr><tr><td>Iterator<E></td><td>iterator​()</td><td>返回此队列中的元素的迭代器。</td></tr><tr><td>boolean</td><td>offer​(E e)</td><td>将指定的元素插入到此优先级队列中。</td></tr><tr><td>E</td><td>peek​()</td><td>检索但不删除此队列的头，如果此队列为空，则返回 null 。</td></tr><tr><td>E</td><td>poll​()</td><td>检索并删除此队列的头部，如果此队列为空，则返回 null 。</td></tr><tr><td>boolean</td><td>remove​(Object o)</td><td>从该队列中删除指定元素的单个实例（如果存在）。</td></tr><tr><td>int</td><td>size​()</td><td>返回此集合中的元素数。</td></tr><tr><td>Spliterator<E></td><td>spliterator​()</td><td>在此队列中的元素上创建late-binding和故障快速 Spliterator 。</td></tr><tr><td>Object[]</td><td>toArray​()</td><td>返回一个包含此队列中所有元素的数组。</td></tr><tr><td><T> T[]</td><td>toArray​(T[] a)</td><td>返回一个包含此队列中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。</td></tr></tbody></table><h2 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a>Deque接口</h2><p>双端队列 ，LinkedList类和ArrayDeque类实现了该接口。可以操作两端</p><h3 id="ArrayDeque类"><a href="#ArrayDeque类" class="headerlink" title="ArrayDeque类"></a>ArrayDeque类</h3><ul><li>与LinkedList类 相似，区别是底层为数组实现  </li></ul><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h3 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h3><ul><li>HashSet是如何保证元素唯一性的呢？<blockquote><p>是通过元素的两个方法，hashCode和equals来完成。<br>  如果元素的HashCode值相同，才会判断equals是否为true。<br>  如果元素的hashcode值不同，不会调用equals。  　　　</p></blockquote><h3 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h3></li><li>能够按照添加的顺序遍历  </li></ul><h3 id="SortedSet接口"><a href="#SortedSet接口" class="headerlink" title="SortedSet接口"></a>SortedSet接口</h3><h4 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h4><ul><li>底层为红黑树</li><li>能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</li></ul><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>&lt;Key,Value&gt;<br><img src="https://img-blog.csdnimg.cn/20200905162910374.png#pic_center" alt="在这里插入图片描述"></p><h2 id="HashTable-类"><a href="#HashTable-类" class="headerlink" title="HashTable 类"></a>HashTable 类</h2><ul><li>线程安全 其内部方法基本经过<code>synchronized</code>修饰 （替代 ConcurrentHashMap）</li><li>效率较低，基本被淘汰  </li></ul><h2 id="HashMap-类"><a href="#HashMap-类" class="headerlink" title="HashMap  类"></a>HashMap  类</h2><ul><li>优秀参考链接：<ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/HashMap.md">HashMap(JDK1.8)源码 </a></li></ul></li><li>底层数据结构： 数组 + 链表（jdk1.8后 链表长于（8）将链表转为红黑树）</li><li>扩容机制：<ul><li>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置。</li></ul></li><li>初始容量大小和每次扩充容量大小：<ul><li>HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小。 </li><li>为什么是2的幂次？<ul><li>因为在计算元素该存放的位置的时候，用到的算法是将元素的hashcode与当前map长度-1进行与运算。源码：<pre><code class="Java">  static int indexFor(int h, int length) &amp;#123;      // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;      return h &amp; (length-1);&amp;#125;</code></pre>如果map长度为2的幂次，那长度-1的二进制一定为11111…这种形式，进行与运算就看元素的hashcode，但是如果map的长度不是2的幂次，比如为15，那长度-1就是14，二进制为1110，无论与谁相与最后一位一定是0，0001，0011，0101，1001，1011，0111，1101这几个位置就永远都不能存放元素了，空间浪费相当大。也增加了添加元素是发生碰撞的机会。减慢了查询效率。所以Hashmap的大小是2的幂次。</li></ul></li></ul></li><li><a href="https://blog.csdn.net/zmx729618/article/details/52795493">Java遍历HashMap并修改(remove)</a></li></ul><h3 id="LinkedHashMap-类"><a href="#LinkedHashMap-类" class="headerlink" title="LinkedHashMap 类"></a>LinkedHashMap 类</h3><ul><li>HashMap的子类，在上<code>HashMap</code>结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的<strong>插入顺序</strong>。  </li></ul><h2 id="SortedMap-接口"><a href="#SortedMap-接口" class="headerlink" title="SortedMap 接口"></a>SortedMap 接口</h2><h3 id="TreeMap类"><a href="#TreeMap类" class="headerlink" title="TreeMap类"></a>TreeMap类</h3><ul><li>底层数据结构：红黑树</li></ul><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="什么是快速失败（fail-fast）"><a href="#什么是快速失败（fail-fast）" class="headerlink" title="什么是快速失败（fail-fast）"></a>什么是快速失败（fail-fast）</h2><ul><li>快速失败(fail-fast) 是 Java 集合的一种错误检测机制。在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。</li><li>实现机制： 每当迭代器使用 hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedModCount 值，是的话就返回遍历；否则抛出异常，终止遍历。如果我们在集合被遍历期间对其进行修改的话，就会改变 modCount 的值，进而导致 modCount != expectedModCount ，进而抛出 ConcurrentModificationException 异常。</li><li><strong>通过 Iterator 的方法修改集合的话会修改到 expectedModCount 的值，所以不会抛出异常。</strong></li></ul><h2 id="什么是安全失败（fail-safe）"><a href="#什么是安全失败（fail-safe）" class="headerlink" title="什么是安全失败（fail-safe）"></a>什么是安全失败（fail-safe）</h2><ul><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 ConcurrentModificationException 异常。</li></ul><h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p><img src="https://img-blog.csdnimg.cn/20200908103807718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODkyNTEx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Java可选操作"><a href="#Java可选操作" class="headerlink" title="Java可选操作"></a>Java可选操作</h2><p>简单说就是抽象类的的某些bai派生类实现里，或者接口的du某个实现类里面，某个方法可能zhi是无意义的，调用该方dao法会抛出一个异常。例如在collection的某些实现类里，里面的元素可能都是只读的，那么add这个接口是无意义的，调用会抛出<code>UnspportedOperationException</code>异常。<br>从设计的角度说，如果一个接口的方法设计为optional，表示这个方法不是为所有的实现而设定的，而只是为某一类的实现而设定的。</p><h1 id="其他-草稿"><a href="#其他-草稿" class="headerlink" title="其他(草稿)"></a>其他(草稿)</h1><ul><li>List接口<ul><li>ArrayList <ul><li>Object[] 数组</li><li>查询快</li><li>add(E e) O(1)</li><li>add(int index, E element)  O(n-i)</li></ul></li><li>LinkedList <ul><li>双向链表实现</li><li>查询慢</li><li>add(E e)  O(1)</li><li>add(int index, E element) o(n)</li></ul></li></ul></li></ul><ul><li>Map接口<ul><li>HashMap<ul><li>数组 + 链表（jdk1.8后 链表长于（8）将链表转为红黑树）</li></ul></li><li>LinkedHashMap  <ul><li>在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的<strong>插入顺序</strong>。</li></ul></li><li>TreeMap</li><li>LinkedTable</li><li>ConcurrentHashMap<ul><li>只锁桶</li></ul></li></ul></li><li>Set<ul><li>HashSet<ul><li>线程不安全 底层是HashMap 可以存储null值</li></ul></li><li>LinkedHashSet</li><li>TreeSet  </li></ul></li></ul><ul><li>Collection接口<br><img src="https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621005616085-269540653.png">  </li></ul><table><thead><tr><th>Modifier and Typ</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean</td><td>add(E e)</td><td>确保此集合包含指定的元素（可选操作）。</td></tr><tr><td>boolean</td><td>addAll​(Collection&lt;? extends E&gt; c)</td><td>将指定集合中的所有元素添加到此集合（可选操作）。</td></tr><tr><td>void</td><td>clear​()</td><td>从此集合中删除所有元素（可选操作）。</td></tr><tr><td>boolean</td><td>contains​(Object o)</td><td>如果此集合包含指定的元素，则返回 true 。</td></tr><tr><td>boolean</td><td>containsAll​(Collection&lt;?&gt; c)</td><td>如果此集合包含指定集合中的所有元素，则返回 true 。</td></tr><tr><td>boolean</td><td>equals​(Object o)</td><td>将指定的对象与此集合进行比较以获得相等性。</td></tr><tr><td>int</td><td>hashCode​()</td><td>返回此集合的哈希码值。</td></tr><tr><td>boolean</td><td>isEmpty​()</td><td>如果此集合不包含元素，则返回 true 。</td></tr><tr><td>Iterator<E></td><td>iterator​()</td><td>返回此集合中元素的迭代器。</td></tr><tr><td>default Stream<E></td><td>parallelStream​()</td><td>返回可能并行的 Stream与此集合作为其来源。</td></tr><tr><td>boolean</td><td>remove​(Object o)</td><td>从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</td></tr><tr><td>boolean</td><td>removeAll​(Collection&lt;?&gt; c)</td><td>删除指定集合中包含的所有此集合的元素（可选操作）。</td></tr><tr><td>default</td><td>boolean removeIf​(Predicate&lt;? super E&gt; filter)</td><td>删除满足给定谓词的此集合的所有元素。</td></tr><tr><td>boolean</td><td>retainAll​(Collection&lt;?&gt; c)</td><td>仅保留此集合中包含在指定集合中的元素（可选操作）。</td></tr><tr><td>int</td><td>size​()</td><td>返回此集合中的元素数。</td></tr><tr><td>default</td><td>Spliterator<E> spliterator​()</td><td>在此集合中的元素上创建一个Spliterator 。</td></tr><tr><td>default</td><td>Stream<E> stream​()</td><td>返回一个序列 Stream与此集合作为其来源。</td></tr><tr><td>Object[]</td><td>toArray​()</td><td>返回一个包含此集合中所有元素的数组。</td></tr><tr><td><T> T[]</td><td>toArray​(T[] a)</td><td>返回一个包含此集合中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>慕课网-算法与数据结构—学习总结</title>
      <link href="/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>慕课网-算法与数据结构-学习总结</strong>  </p></blockquote><hr><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p><a href="https://github.com/liuyubobobo/Play-with-Algorithms">课程源码play-with-Algorithms</a></p><h1 id="第二章-排序基础"><a href="#第二章-排序基础" class="headerlink" title="第二章 排序基础"></a>第二章 排序基础</h1><ul><li><strong>排序的稳定性</strong><br>  排序后是否改变原序列键值相同的序列的先后关系</li><li><strong>内排序与外排序</strong><br>  外排序： 由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行 。外部排序最常用的算法是多路归并排序</li><li><strong>影响排序的三个方面</strong>  <ul><li>时间性能<ul><li>比较</li><li>移动</li></ul></li><li>辅助空间</li><li>算法复杂度  <h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2></li></ul></li></ul><ul><li><p>冒泡排序</p><ul><li>基本思想：两两交换，将最大（或最小）的交换至队列前  <h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2></li></ul></li><li><p>简单选择排序  </p><ul><li>基本思想：在未排序的序列种找到最小（或最大）的元素放到前面  </li><li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9TZWxlY3Rpb24tU29ydC1BbmltYXRpb24uZ2lm" alt="动画演示">  </li></ul></li><li><p>参考实现代码（cpp）</p><pre><code>    template&lt;typename T&gt;    void selectionSort(T arr[], int n)&amp;#123;        for(int i = 0 ; i &lt; n ; i ++)&amp;#123;            int minIndex = i;            for( int j = i + 1 ; j &lt; n ; j ++ )                if( arr[j] &lt; arr[minIndex] )                    minIndex = j;            swap( arr[i] , arr[minIndex] );        &amp;#125;    &amp;#125;</code></pre></li><li><p>直接选择排序  </p></li><li><p>树型选择排序</p></li></ul><h2 id="插入排序及其改进"><a href="#插入排序及其改进" class="headerlink" title="插入排序及其改进"></a>插入排序及其改进</h2><ul><li><p>直接插入排序  </p><ul><li><p>基本思想: 将未排序的元素插入到已经排好序的队列种对应的位置</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTAxNjU5NC0xNTBiNmM0NjJlM2VkODA5LnBuZw?x-oss-process=image/format,png" alt="示意图">  </p></li><li><p>代码</p><pre><code>template&lt;typename T&gt;void insertionSort(T arr[], int n)&amp;#123;    for( int i = 1 ; i &lt; n ; i ++ ) &amp;#123;    // 寻找元素arr[i]合适的插入位置    // 写法1    //        for( int j = i ; j &gt; 0 ; j-- )    //            if( arr[j] &lt; arr[j-1] )    //                swap( arr[j] , arr[j-1] );    //            else    //                break;    // 写法2    //        for( int j = i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )    //            swap( arr[j] , arr[j-1] );    // 写法3                T e = arr[i];                int j; // j保存元素e应该插入的位置                for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; e; j--)                    arr[j] = arr[j-1];                arr[j] = e;    &amp;#125;    return;&amp;#125;</code></pre></li><li><p>改进：   </p><ul><li><p><strong>折半插入排序：</strong> 找到已排好序种对应位置时 用 折半查找   </p></li><li><p><strong>希尔排序</strong>:</p><ul><li><p>基本思想：交换不相邻的元素以对数组的<strong>局部</strong>进行排序</p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/7779232-d19c19b7153b27b2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp"></p></li><li><p>第一个O(n log n)的排序算法</p></li><li><p>参考代码</p><pre><code>template&lt;typename T&gt;void shellSort(T arr[], int n)&amp;#123;    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...    int h = 1;    while( h &lt; n/3 )        h = 3 * h + 1;    while( h &gt;= 1 )&amp;#123;        // h-sort the array        for( int i = h ; i &lt; n ; i ++ )&amp;#123;            // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序            T e = arr[i];            int j;            for( j = i ; j &gt;= h &amp;&amp; e &lt; arr[j-h] ; j -= h )                arr[j] = arr[j-h];            arr[j] = e;        &amp;#125;        h /= 3;    &amp;#125;&amp;#125;</code></pre></li><li><p><a href="https://www.jianshu.com/p/642b19f8a69c">希尔排序及其优化</a>  </p></li></ul></li><li><p>其他： 路插入排序,表插入排序等。</p></li></ul></li></ul></li></ul><hr><h1 id="第三章-高级排序问题"><a href="#第三章-高级排序问题" class="headerlink" title="第三章 高级排序问题"></a>第三章 高级排序问题</h1><h2 id="归并排序及其优化"><a href="#归并排序及其优化" class="headerlink" title="归并排序及其优化"></a>归并排序及其优化</h2><ul><li><p>基本思想： (分治)将排序序列差分成 两个等长的子序列，对子序列进行排序后再归并</p></li><li><p>参考核心代码(cpp)</p><pre><code>    // 使用优化的归并排序算法, 对arr[l...r]的范围进行排序    template&lt;typename T&gt;    void __mergeSort2(T arr[], int l, int r)&amp;#123;        // 优化2: 对于小规模数组, 使用插入排序        if( r - l &lt;= 15 )&amp;#123;            insertionSort(arr, l, r);            return;        &amp;#125;        int mid = (l+r)/2;        __mergeSort2(arr, l, mid);        __mergeSort2(arr, mid+1, r);        // 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge        // 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失        if( arr[mid] &gt; arr[mid+1] )            __merge(arr, l, mid, r);    &amp;#125;</code></pre></li><li><p>优化点：    </p><pre><code>- 当排序的元素少于一定（16）时，直接调用 插入排序  - 如果第一个序列的最大值小于第二个序列的最小值，则不用比较，直接合并  </code></pre><ul><li><p>归并排序的自底向上写法（迭代）  </p></li><li><p><strong>核心代码参考</strong>    </p><pre><code>  ```          // 使用自底向上的归并排序算法  template &lt;typename T&gt;  void mergeSortBU(T arr[], int n)&amp;#123;      // Merge Sort Bottom Up 优化      // 对于小数组, 使用插入排序优化      for( int i = 0 ; i &lt; n ; i += 16 )          insertionSort(arr,i,min(i+15,n-1));      for( int sz = 16; sz &lt; n ; sz += sz )          for( int i = 0 ; i &lt; n - sz ; i += sz+sz )              // 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge              if( arr[i+sz-1] &gt; arr[i+sz] )                  __merge(arr, i, i+sz-1, min(i+sz+sz-1,n-1) );      // Merge Sort BU 也是一个O(nlogn)复杂度的算法，虽然只使用两重for循环      // 所以，Merge Sort BU也可以在1秒之内轻松处理100万数量级的数据      // 注意：不要轻易根据循环层数来判断算法的复杂度，Merge Sort BU就是一个反例      // 关于这部分陷阱，推荐看（liubobo老师）的《玩转算法面试》课程，第二章：《面试中的复杂度分析》：）  &amp;#125;  ```</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></li></ul></li><li><p>基本思想： （分治） 将选定的元素放到合适的位置，然后 递归 排序 被该元素分开的 前 后 两个子序列。(分出来的两个子序列可能不等长，相差很大，会影响性能)</p></li><li><p>核心代码参考  </p><pre><code>```// 对arr[l...r]部分进行partition操作// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]template &lt;typename T&gt;int _partition(T arr[], int l, int r)&amp;#123;    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr[l] , arr[rand()%(r-l+1)+l] );    T v = arr[l];    int j = l;    for( int i = l + 1 ; i &lt;= r ; i ++ )        if( arr[i] &lt; v )&amp;#123;            j ++;            swap( arr[j] , arr[i] );        &amp;#125;    swap( arr[l] , arr[j]);    return j;&amp;#125;// 对arr[l...r]部分进行快速排序template &lt;typename T&gt;void _quickSort(T arr[], int l, int r)&amp;#123;    // 对于小规模数组, 使用插入排序进行优化    if( r - l &lt;= 15 )&amp;#123;        insertionSort(arr,l,r);        return;    &amp;#125;    int p = _partition(arr, l, r);    _quickSort(arr, l, p-1 );    _quickSort(arr, p+1, r);&amp;#125;```</code></pre></li><li><p>优化：  </p><pre><code>1. 标定点 随机选（针对基本有序的序列，如果固定选最前面的元素，则分治的两个子问题不平衡，退化为O(n^2)的复杂度）  2. 小规模排序，使用插入排序</code></pre></li><li><p>双路快排  </p><ul><li><p>基本思想：针对键值重复过多时，分治的两个子序列不等长，导致分治不平衡</p></li><li><p>核心代码参考</p><pre><code>// 双路快速排序的partition// 返回p, 使得arr[l...p-1] &lt;= arr[p] ; arr[p+1...r] &gt;= arr[p]// 双路快排处理的元素正好等于arr[p]的时候要注意，详见下面的注释：）template &lt;typename T&gt;int _partition2(T arr[], int l, int r)&amp;#123;    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr[l] , arr[rand()%(r-l+1)+l] );    T v = arr[l];    // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v    int i = l+1, j = r;    while( true )&amp;#123;        // 注意这里的边界, arr[i] &lt; v, 不能是arr[i] &lt;= v        // 思考一下为什么?        while( i &lt;= r &amp;&amp; arr[i] &lt; v )            i ++;        // 注意这里的边界, arr[j] &gt; v, 不能是arr[j] &gt;= v        // 思考一下为什么?        while( j &gt;= l+1 &amp;&amp; arr[j] &gt; v )            j --;        // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)        // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html        if( i &gt; j )            break;        swap( arr[i] , arr[j] );        i ++;        j --;    &amp;#125;    swap( arr[l] , arr[j]);    return j;&amp;#125;// 对arr[l...r]部分进行快速排序template &lt;typename T&gt;void _quickSort(T arr[], int l, int r)&amp;#123;    // 对于小规模数组, 使用插入排序进行优化    if( r - l &lt;= 15 )&amp;#123;        insertionSort(arr,l,r);        return;    &amp;#125;    // 调用双路快速排序的partition    int p = _partition2(arr, l, r);    _quickSort(arr, l, p-1 );    _quickSort(arr, p+1, r);&amp;#125;</code></pre></li></ul></li><li><p>三路快排 </p><ul><li><p>基本思想： 针对2路快排的加强，进一步解决键值重复过多的问题（增加一个等值区域）</p></li><li><p>核心代码参考</p><pre><code>// 递归的三路快速排序算法template &lt;typename T&gt;void __quickSort3Ways(T arr[], int l, int r)&amp;#123;    // 对于小规模数组, 使用插入排序进行优化    if( r - l &lt;= 15 )&amp;#123;        insertionSort(arr,l,r);        return;    &amp;#125;    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr[l], arr[rand()%(r-l+1)+l ] );    T v = arr[l];    int lt = l;     // arr[l+1...lt] &lt; v    int gt = r + 1; // arr[gt...r] &gt; v    int i = l+1;    // arr[lt+1...i) == v    while( i &lt; gt )&amp;#123;        if( arr[i] &lt; v )&amp;#123;            swap( arr[i], arr[lt+1]);            i ++;            lt ++;        &amp;#125;        else if( arr[i] &gt; v )&amp;#123;            swap( arr[i], arr[gt-1]);            gt --;        &amp;#125;        else&amp;#123; // arr[i] == v            i ++;        &amp;#125;    &amp;#125;    swap( arr[l] , arr[lt] );    __quickSort3Ways(arr, l, lt-1);    __quickSort3Ways(arr, gt, r);&amp;#125;template &lt;typename T&gt;void quickSort3Ways(T arr[], int n)&amp;#123;    srand(time(NULL));    __quickSort3Ways( arr, 0, n-1);&amp;#125;// 比较Merge Sort和双路快速排序和三路快排三种排序算法的性能效率// 对于包含有大量重复数据的数组, 三路快排有巨大的优势// 对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围里// 因此, 在一些语言中, 三路快排是默认的语言库函数中使用的排序算法。比如Java:)</code></pre><h2 id="归并排序和快速排序衍生的问题"><a href="#归并排序和快速排序衍生的问题" class="headerlink" title="归并排序和快速排序衍生的问题"></a>归并排序和快速排序衍生的问题</h2></li></ul><ul><li>求逆序对（归并排序）</li><li>求数组中的第N大元素</li></ul></li></ul><hr><h1 id="第四章-堆和堆排序"><a href="#第四章-堆和堆排序" class="headerlink" title="第四章 堆和堆排序"></a>第四章 堆和堆排序</h1><h2 id="基本概念认识"><a href="#基本概念认识" class="headerlink" title="基本概念认识"></a>基本概念认识</h2><ul><li>队列<ul><li>普通队列：先进先出</li><li>优先队列：根据优先级出队  </li></ul></li><li><strong>优先队列应用</strong>  对动态的数据排序  </li><li>优先队列的三种实现方式  <table><thead><tr><th align="left">实现方式</th><th align="left">入队</th><th align="left">出队</th></tr></thead><tbody><tr><td align="left">普通数组</td><td align="left">O(1)</td><td align="left">O(n)</td></tr><tr><td align="left">顺序数组(元素有序)</td><td align="left">O(n)</td><td align="left">O(1)</td></tr><tr><td align="left">堆</td><td align="left">O(log n)</td><td align="left">O(log n)</td></tr></tbody></table></li></ul><h2 id="堆的基本存储"><a href="#堆的基本存储" class="headerlink" title="堆的基本存储"></a>堆的基本存储</h2><pre><code>* 用数组存储二叉堆* 数组的索引次序 对应 二叉堆中 层序遍历次序* 对于完全二叉树,对第i个元素，其与其父，其子的关系    * 根节点索引从0开始        * parent(i) = （i-1）/2        * left child (i) = 2*i +1        * right child (i) = 2*i + 2    * 根节点索引从1开始        * parent(i) = i/2        * left child (i) = 2*i         * right child (i) = 2*i + 1</code></pre><h3 id="heapfy过程（堆的建立）"><a href="#heapfy过程（堆的建立）" class="headerlink" title="heapfy过程（堆的建立）"></a>heapfy过程（堆的建立）</h3><pre><code>- 基本思想：从最后一个非叶子节点（索引为count/2，在根节点索引从1开始的情况下）开始，shiftdown()，自底向上实现堆- 将n个元素逐个插入空堆中，算法复杂度为O(n log n),而heapfy过程算法复杂度O(n)  - 代码```    // 构造函数, 通过一个给定数组创建一个最大堆    // 该构造堆的过程, 时间复杂度为O(n)    MaxHeap(Item arr[], int n)&amp;#123;        data = new Item[n+1];        capacity = n;        for( int i = 0 ; i &lt; n ; i ++ )            data[i+1] = arr[i];        count = n;        for( int i = count/2 ; i &gt;= 1 ; i -- )            shiftDown(i);    &amp;#125;```</code></pre><h2 id="ShiftUp-节点上移比较"><a href="#ShiftUp-节点上移比较" class="headerlink" title="ShiftUp(节点上移比较)"></a>ShiftUp(节点上移比较)</h2><pre><code>- 代码    ```        void shiftUp(int k)&amp;#123;        while( k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] )&amp;#123;            swap( data[k/2], data[k] );            k /= 2;        &amp;#125;        &amp;#125;    ``` </code></pre><h2 id="ShiftDown（节点下移比较）"><a href="#ShiftDown（节点下移比较）" class="headerlink" title="ShiftDown（节点下移比较）"></a>ShiftDown（节点下移比较）</h2><pre><code>- 代码```    void shiftDown(int k)&#123;    while( 2*k &lt;= count )&#123;        int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置        if( j+1 &lt;= count &amp;&amp; data[j+1] &gt; data[j] )            j ++;        // data[j] 是 data[2*k]和data[2*k+1]中的最大值        if( data[k] &gt;= data[j] ) break;        swap( data[k] , data[j] );        k = j;    &#125;    &#125;```</code></pre><h2 id="堆排序及其优化"><a href="#堆排序及其优化" class="headerlink" title="堆排序及其优化"></a>堆排序及其优化</h2><pre><code>* 堆排序算法：    * 创建堆： 一种通过不断insert()创建O(nlogn)，一种传入数组用heapfy创建O(n)    * 堆顶出堆： 将堆顶与堆尾互换，堆的size-1,并将新的堆顶（原堆尾）shiftDown()    * 重复第二步  * 堆排序的实现    1. 借助insert()创建堆    ```    // heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序    // 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)    // 整个堆排序的整体时间复杂度为O(nlogn)    template&lt;typename T&gt;    void heapSort1(T arr[], int n)&#123;        MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);        for( int i = 0 ; i &lt; n ; i ++ )            maxheap.insert(arr[i]);        for( int i = n-1 ; i &gt;= 0 ; i-- )            arr[i] = maxheap.extractMax();    &#125;    2. 借助heapfy() 创建堆    // heapSort2, 借助我们的heapify过程创建堆    // 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 实践复杂度为O(nlogn)    // 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优    template&lt;typename T&gt;    void heapSort2(T arr[], int n)&#123;        MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(arr,n);        for( int i = n-1 ; i &gt;= 0 ; i-- )            arr[i] = maxheap.extractMax();    &#125;    ```* 堆的实现细节    *ShiftUp和ShiftDown种使用复制操作替换swap操作*  </code></pre><h2 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h2><ul><li><p>基本思想： 分索引数组和数据数组，数据数组存数据元素。索引数组按堆的次序（比较的是实际元素的键值）存对应节点的索引（地址）。ShiftUP和ShiftDown中比较(实际元素的值)，交换对应的索引（存储地址），而不交换实际的元素。</p></li><li><p>一点理解： 维护了一个数组，既能有堆的特性（取最值），又能保持原有数组的存储次序（数据数组的索引是原数组的+1）。</p></li><li><p>ShfitUp()</p><pre><code>    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引    void shiftUp( int k )&#123;    while( k &gt; 1 &amp;&amp; data[indexes[k/2]] &lt; data[indexes[k]] )&#123;        swap( indexes[k/2] , indexes[k] );        k /= 2;    &#125;&#125;</code></pre></li><li><p>ShiftDown()</p><pre><code>    // 索引堆中, 数据之间的比较根据data的大小进行比较, 但实际操作的是索引    void shiftDown( int k )&#123;        while( 2*k &lt;= count )&#123;            int j = 2*k;            if( j + 1 &lt;= count &amp;&amp; data[indexes[j+1]] &gt; data[indexes[j]] )                j += 1;            if( data[indexes[k]] &gt;= data[indexes[j]] )                break;            swap( indexes[k] , indexes[j] );            k = j;        &#125;    &#125;</code></pre></li><li><p>增删实现 (<strong>插入操作 不是很理解</strong>)</p><pre><code>    // 向最大索引堆中插入一个新的元素, 新元素的索引为i, 元素为item// 传入的i对用户而言,是从0索引的void insert(int i, Item item)&#123;    assert( count + 1 &lt;= capacity );    assert( i + 1 &gt;= 1 &amp;&amp; i + 1 &lt;= capacity );    i += 1;    data[i] = item;    indexes[count+1] = i;    count++;    shiftUp(count);&#125;// 从最大索引堆中取出堆顶元素, 即索引堆中所存储的最大数据Item extractMax()&#123;    assert( count &gt; 0 );    Item ret = data[indexes[1]];    swap( indexes[1] , indexes[count] );    count--;    shiftDown(1);    return ret;&#125;</code></pre></li><li><p>应用： 最小生成树Prim算法中，用来维护 每个节点对应的最小横切面的权重【同时能输出当前所有节点最小横切面中的最小横切面】</p><h2 id="涉及堆-的相关问题"><a href="#涉及堆-的相关问题" class="headerlink" title="涉及堆 的相关问题"></a>涉及堆 的相关问题</h2><ul><li>多路归并排序 多个元素同时比较的时候用，最小（大）堆</li><li>d叉堆 d-ary heap  </li><li>最大最小队列 （最大堆和最小堆同时维护？？）</li><li>二项堆</li><li>斐波那契堆</li></ul></li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><pre><code>基本思想： 分配 + 收集 （先排序低位再排序高位）</code></pre><h2 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h2><table><thead><tr><th align="left">排序</th><th align="left">平均时间复杂度</th><th align="left">原地排序</th><th align="left">额外空间</th><th align="left">稳定排序</th></tr></thead><tbody><tr><td align="left">插入排序（Insertion Sort）</td><td align="left">O(n^2)</td><td align="left">是</td><td align="left">O(1)</td><td align="left">是</td></tr><tr><td align="left">归并排序(Merge Sort)</td><td align="left">O（nlogn）</td><td align="left">否</td><td align="left">O(n)</td><td align="left">是</td></tr><tr><td align="left">快速排序（Quick Sort）</td><td align="left">O(nlogn)</td><td align="left">是</td><td align="left"><strong>O（logn）</strong></td><td align="left">否</td></tr><tr><td align="left">堆排序（Heap Sort)</td><td align="left">O(nlogn)</td><td align="left">是</td><td align="left">O(1)</td><td align="left">否</td></tr></tbody></table><ul><li><strong>不同排序算法的选择</strong>  <ul><li>n较小：直接插入排序或直接选择排序</li><li>基本有序序列，直接插入，冒泡，随机的快速排序</li><li>n较大，应选复杂度好的：快速排序，归并排序， 堆排序。<ul><li>快速排序性能平均最好，堆排序更少的辅助空间，归并排序是稳定的排序。（当排序数少于一定时如16，<strong>调用直接插入排序</strong>）  </li></ul></li></ul></li></ul><p><strong>其他参考</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjIyOTk3LWIxYmIwNDg4NDlhMjI3YmUucG5n?x-oss-process=image/format,png" alt="排序算法总结"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8wMy9zb3J0LnBuZw?x-oss-process=image/format,png" alt="排序对比"><br><img src="https://img-blog.csdn.net/2018101109461342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pocTExODY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> <a href="https://blog.csdn.net/liu17234050/article/details/104217658">C语言中的14种排序</a><br> <a href="https://v.qq.com/x/page/e0523qakza6.html">14中排序动画演示</a>   </p><hr><h1 id="第五章-二分搜索树"><a href="#第五章-二分搜索树" class="headerlink" title="第五章 二分搜索树"></a>第五章 二分搜索树</h1><h2 id="5-1-二分查找法"><a href="#5-1-二分查找法" class="headerlink" title="5-1 二分查找法"></a>5-1 二分查找法</h2><ul><li><p>基本思想： （递归分治）对有序序列，不需要逐一比较，只要比较中间值，然后确定目标值的可能区域，再在可能区域递归二分查找。</p></li><li><p>细节： </p><ol><li>计算中间值时， 注意防止越界（基本类型的范围）。<ul><li>合理写法： int mid = left + (right-left)/2 ，</li><li>危险写法： int mid = (left + right)/2</li></ul></li><li>二分查找返回的只有一个索引，而序列中可能存在重复值。如何返回所有重复值？<ul><li>练习：对于存在重复值的序列，返回目标值索引的floor(第一个索引)和ceil（最后一个索引）</li></ul></li></ol></li><li><p>改进：（选不同的分割点）</p><ul><li>插值查找 （按比值分割） <ul><li>mid = left + (right-left)*&#123;(key-a[left])/(a[right]-a[left])&#125;</li></ul></li><li>斐波那契查找<ul><li>mid = left + F_block - 1 (黄金分割)<h2 id="5-2-二分搜索树"><a href="#5-2-二分搜索树" class="headerlink" title="5-2 二分搜索树"></a>5-2 二分搜索树</h2></li></ul></li></ul></li><li><p>二分搜索树的定义：</p><ul><li>左子树&gt;(&lt;) 根 &gt;(&lt;) 右子树 [一般不考虑键值重复的问题]</li></ul></li><li><p>二分搜索树的优势</p><ul><li>高效(（O(nlogn))的维护数据的有序性：min,max,floor,ceil,rank,select</li></ul></li><li><p>二分搜索树的节点插入</p><ul><li><p>实现方式： </p><ol><li><p>递归(返回子树根节点)[从根节点开始搜索，找到key值则替换，未找到则根据比较关系递归子树]</p><pre><code class="Cpp"> // 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法 // 返回插入新节点后的二分搜索树的根 private Node insert(Node node, Key key, Value value)\&amp;#123;     if( node == null )&amp;#123;         count ++;         return new Node(key, value);     &amp;#125;     if( key.compareTo(node.key) == 0 )         node.value = value;     else if( key.compareTo(node.key) &lt; 0 )         node.left = insert( node.left , key, value);     else    // key &gt; node-&gt;key         node.right = insert( node.right, key, value);     return node; &amp;#125;</code></pre></li><li><p>迭代</p><ul><li>当作练习</li></ul></li></ol></li></ul></li><li><p>二分搜索书的查找  </p><ul><li>基本思想: 二分查找</li></ul></li><li><p>二分搜索树的遍历</p><ul><li>（深度优先遍历）  <ul><li>前序遍历，中序遍历，后序遍历</li></ul></li><li>（广度优先遍历）<ul><li>层序遍历</li></ul></li></ul></li><li><p>删除最大值，最小值  </p><ul><li>实现：<ul><li>递归：（不断递归(左/右)子树，直到节点没有（左/右）子树，删除该节点，返回其的（右/左）子树赋值给上一节点的（左/右）子树）</li></ul></li></ul></li><li><p>删除Key对应的节点</p><ul><li>实现： <ul><li>递归<ul><li>从根节点开始递归搜索<ul><li>如果目标值在根节点则删除根节点，选新的中间值上位（左子树最右（大/小）的节点，右子树最左（小/大）的节点）</li><li>否则根据比较次序，选择（左/右）子树递归搜索，根节点的（左/右）子树 = 返回删除最值后的子树的根节点<h2 id="5-3-二分搜索树的特性"><a href="#5-3-二分搜索树的特性" class="headerlink" title="5-3 二分搜索树的特性"></a>5-3 二分搜索树的特性</h2></li><li>顺序性</li><li>minimum/maximum</li><li>successor/predecessor 后继/前继</li><li>floor/ceil （存在键值重复时，索引的范围）</li><li>rank/select 已知key获取排名/已知排名获取key,value</li></ul></li></ul></li></ul></li></ul><ul><li><p>局限性：(不平衡) 依照顺序或逆序插入元素，二分搜索树退化为链表（跟节点为第一个元素，在最左，或最右）。</p></li><li><p>支持重复键值的二分搜索树</p><ul><li>思路一： 让键值重复节点的右子树或左子树包含键值重复的节点。</li><li>思路二： 每个节点增加一个区域（链表或数组），存键值相等的元素</li></ul></li></ul></li></ul><h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><pre><code>- 平衡二叉树：    - 左右子树高度差不超过1的二叉搜索树，即平衡二叉树所有结点的平衡因子绝对值不超过1（平衡因子 = 结点左子树的高度 - 结点右子树的高度）。- 实现方式：    - AVL树    - 红黑树    - 2-3树    - Splay树</code></pre><h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><ul><li>基本思想，每插入一个节点，自底向上维护树的平衡，以及每个节点的平衡因子</li><li>平衡调整的四种类型：<ul><li>LL型 右旋调整 调整后涉及到的节点的平衡因子（bf）均为0</li><li>RR型 左旋调整 调整后涉及到的节点的平衡因子(bf)均为0</li><li>LR型 先左旋调整至LL型， 然后右旋调整 bf的维护如下： </li><li>RL型 先右旋调整至RR型， 然后左旋调整<br><img src="/source/pictures/%E5%B9%B3%E8%A1%A1%E8%B0%83%E6%95%B4%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B.bmp"></li></ul></li></ul><ul><li><p>插入操作思路整理：</p><ul><li>考虑当前节点的子树是否添加了新节点<ul><li>没有 则不用维护，直接返回</li><li>左子树添加了新节点 <strong>&gt;&gt;&gt;</strong> 当前节点的平衡因子要加一($bf= bf+1$)<ul><li>若$bf&gt;1$(需要平衡调整) <strong>&gt;&gt;&gt;</strong> 进行左平衡调整</li></ul></li><li>右子树添加了新节点 <strong>&gt;&gt;&gt;</strong> 当前节点的平衡因子要减一($bf = bf -1$)<ul><li>若$bf&lt;-1$，需要平衡调整 **&gt;&gt;&gt;** 进行右平衡调整</li></ul></li></ul></li></ul></li><li><p>左平衡调整(cur.bf &gt; 1)</p><ul><li>看cur的左子节点L 的平衡因子 L.bf<ul><li>L.bf == 1 <strong>&gt;&gt;&gt;</strong> LL型 <strong>&gt;&gt;&gt;</strong> 右旋操作</li><li>L.bf == -1 <strong>&gt;&gt;&gt;</strong> LR型 <strong>&gt;&gt;&gt;</strong> 先左旋调整至LL型，然后右旋调整</li></ul></li></ul></li><li><p>右平衡调整(cur.bf &lt; -1)</p><ul><li>看cur节点的右孩子节点R 的平衡因子R.bf<ul><li>R.bf == -1 <strong>&gt;&gt;&gt;</strong> RR型 <strong>&gt;&gt;&gt;</strong> 左旋操作</li><li>R.bf == 1 <strong>&gt;&gt;&gt;</strong> RL型 <strong>&gt;&gt;&gt;</strong> 先右旋调整至RR型，然后左旋调整</li></ul></li></ul></li><li><p>插入操作代码</p><pre><code class="Java">  //插入操作  void insert(K key,V value) &amp;#123;      taller = false; //增加了新的一层？？      root = __insert(root,key,value);  &amp;#125;  //返回插入新节点后的根节点  private AVLNode __insert(AVLNode curNode,K key,V value) &amp;#123;      if(curNode==null) &amp;#123;          curNode = new AVLNode(key,value);          taller = true; //增加了新节点          return curNode;//      &amp;#125;      else &amp;#123;          if(key.compareTo(curNode.key)==0) &amp;#123;              return curNode;//节点已经存在，返回（不覆盖旧值）          &amp;#125;          else if(key.compareTo(curNode.key)&lt;0) &amp;#123;              curNode.left = __insert(curNode.left,key,value); //往左子树新增节点              if(taller) &amp;#123;//增加了新节点                  switch(curNode.bf) &amp;#123;                      case 0: //新增节点没有打破平衡，但bf+1                          curNode.bf = 1;//左边新加一个点                          taller = true;//此处很重要，自底 向上传递平衡信息                          break;                      case 1:  //本来左子树多一个结点，然后taller为true,左子树又增加了一个结点                          curNode = leftBalance(curNode); //左平衡时必须保证 curNode具有左孩子                          taller = false; //左平衡后 达到平衡                          break;                      case -1: //新增节点使得curNode左右平衡                          curNode.bf = 0;                          taller = false;                          break;                  &amp;#125;              &amp;#125;              return curNode;          &amp;#125;          else &amp;#123; //往当前节点的右子树增添节点              curNode.right = __insert(curNode.right,key,value);//往右子树增加节点              if(taller) &amp;#123;                  switch(curNode.bf) &amp;#123;                      case 0:                          curNode.bf = -1;                          taller = true;                          break;                      case 1:                           curNode.bf = 0;                           taller = false;                           break;                      case -1:                          curNode = rightBalance(curNode);                          taller = false;                          break;                          &amp;#125;              &amp;#125;              return curNode;          &amp;#125;      &amp;#125;  &amp;#125;</code></pre></li><li><p>左平衡调整代码</p><pre><code class="Java">  /*   * 左平衡操作   */  //[当前curNode的bf&gt;0，又再左子树增加节点时需要左平衡操作]  AVLNode leftBalance(AVLNode curNode) &amp;#123;      AVLNode L = curNode.left;      if(L.bf==1) &amp;#123; //LL型需要左旋          curNode.bf = 0;//右旋平衡          L.bf = 0;//右旋平衡          return rightRotate(curNode);      &amp;#125;      else if(L.bf==-1) &amp;#123;//LR型需要 先左旋  后右旋          AVLNode LR = L.right; //左孩子的右孩子          //以下代码不是很理解,,,画一下实际例子可以明白，，但为啥子LR.bf不会一直被维护为0？（因为LR不一定是新增节点?）          switch(LR.bf) &amp;#123;              case 1:                  curNode.bf = -1;                  L.bf = 0;                  break;              case 0:                  curNode.bf = 0;                  L.bf = 0;                  break;              case -1:                  curNode.bf = 0;                  L.bf = 1;                  break;          &amp;#125;          LR.bf = 0;          curNode.left = leftRotate(curNode.left);          return rightRotate(curNode);      &amp;#125;      else &amp;#123;//不需要左平衡处理          return curNode;      &amp;#125;  &amp;#125;</code></pre></li><li><p>右平衡调整代码</p><pre><code class="Java">  //右平衡操作  /*   * curNode bf本已经-1的基础上，在右方又新增节点   */  AVLNode rightBalance(AVLNode curNode) &amp;#123;      AVLNode R = curNode.right;      if(R.bf==-1) &amp;#123; //RR型           curNode.bf = 0;          R.bf = 0;          return leftRotate(curNode);      &amp;#125;      else if(R.bf==1) &amp;#123;//RL型          AVLNode RL = R.left;          switch(RL.bf) &amp;#123;              case 0:                  curNode.bf = 0;                  R.bf = 0;                  break;              case 1:                  R.bf =-1;                  curNode.bf = 0;                  break;              case -1:                  curNode.bf = 1;                  R.bf = 0;                  break;          &amp;#125;          RL.bf = 0;          curNode.right = rightRotate(R);          return leftRotate(curNode);      &amp;#125;      else &amp;#123;          return curNode;      &amp;#125;  &amp;#125;</code></pre></li><li><p>左旋操作</p><pre><code class="Java">  //左旋操作  AVLNode leftRotate(AVLNode curNode) &amp;#123;      AVLNode subRoot = curNode.right;      curNode.right = subRoot.left;      subRoot.left = curNode;      return subRoot;  &amp;#125;</code></pre></li><li><p>右旋操作</p><pre><code class="Java">  //右旋操作  AVLNode rightRotate(AVLNode curNode) &amp;#123;      AVLNode subRoot = curNode.left;//左孩子上位      curNode.left = subRoot.right;//把你的右孩子给我，作为我的左孩子(保证排序性)      subRoot.right = curNode;//你上位后我成为你的有孩子      return subRoot;  &amp;#125;</code></pre></li><li><p>其他操作实现：</p><ul><li>可参考&lt;&lt;数据结构从应用到时间（Java版）&gt;&gt;<h2 id="5-5-多路查找树"><a href="#5-5-多路查找树" class="headerlink" title="5-5 多路查找树"></a>5-5 多路查找树</h2></li></ul></li><li><p>多路查找树的意义</p><blockquote><p>对于树来说，一个结点只能存储一个元素，那么在元素非常多的时候，就会使得要么树的度非常大（结点拥有子树的个数的最大值），要么树的高度非常大，甚至两者都必须足够大才行，这就使得内存存取外存次数非常多，这显然成了时间效率上的瓶颈，这迫使我们要打破每一个结点只存储一个元素的限制，为此引入了多路查找树的概念</p></blockquote></li><li><p>2-3 树 </p><ul><li>每个结点都具有两个孩子（我们称它为 2 结点）或三个孩子（我们称它为 3 结点）的树</li><li>特性  <pre><code>      一个 2 结点 包含一个元素和两个孩子（或没有孩子），且左子树数据元素小于该元素右子树数据元素大于该元素    一个 3 结点 包含一小一大两个元素和三个孩子（或没有孩子）    如果有 3 个孩子的话    左子树包含小于较小元素的元素    右子树包含大于较大元素的元素    中间子树包含介于两元素之间的元素</code></pre></li></ul></li><li><p>2-3-4 树</p></li><li><p>B 树</p><h2 id="5-6-树形问题和更多树。"><a href="#5-6-树形问题和更多树。" class="headerlink" title="5-6 树形问题和更多树。"></a>5-6 树形问题和更多树。</h2><ul><li>平衡二叉树和堆的结合Treap</li><li>trie ：查找效率与单词长度有关，与单词中的单词数量无关</li><li>其他树形(递归)问题：<ul><li>一条龙游戏</li><li>8 数码问题</li><li>8 皇后问题</li><li>数独</li><li>搬运工</li></ul></li><li>更多树的结构<ul><li>KD树</li><li>区间树</li><li>哈夫曼树</li></ul></li></ul></li></ul><hr><h1 id="第六章-并查集"><a href="#第六章-并查集" class="headerlink" title="第六章:并查集"></a>第六章:并查集</h1><h2 id="6-1-并查集基础"><a href="#6-1-并查集基础" class="headerlink" title="6-1 并查集基础"></a>6-1 并查集基础</h2><ul><li><p>解决的问题： </p><ul><li>连接问题， 数学中集合类的实现，</li><li>路径问题</li></ul></li><li><p>并查集的基本方法</p><ul><li>union(p,q) 将p与q 联合 （同属一个集合（连通分支））</li><li>find(p) 查找p所在集合序号</li><li>isConnect(p,q) </li></ul></li><li><p>并查集的实现</p><ul><li><p>数组实现（QuickFind） （数组索引为元素键值，数组值为对应的集合号）</p><ul><li>union(p,q) 需要遍历更新所有元素的集合号，时间复杂度O(n)</li><li>find(p) 直接数组下标查找，O(1) </li><li>isConnect()  复杂度O(1)</li></ul></li><li><p>树形实现（数组索引为元素键值，数组值为该节点的父节点的索引）</p><ul><li><p>union(p,q) 时间复杂度O(h)，h为树的高度 </p></li><li><p>find(p) 需要回溯到(所在分支的)跟节点，O(h)，h为树的高度 </p></li><li><p>isConnect()  复杂度O(h，h为树的高度 </p></li><li><p>树形实现中 union() 的三种实现方式（不断改进（降低）树的高度h）</p><ul><li>随机合并</li><li>基于size的优化 <ul><li>维护一个size数组，存每个分支的元素多少</li><li>将元素较少的树合并到元素较多的的树 新的分支size = size1 + size2</li></ul></li><li>基于rank的优化 <ul><li>维护一个rank数组，存每个分支对应树的高度</li><li>将高度小的和平到高度大的</li></ul></li></ul></li><li><p>find() 过程中的 路径压缩（降低树的高度）</p><ul><li><p>基本思想： 基于树形实现的并查集，在find()时，需要回溯到分支树的根节点，在回溯的过程，可以将树的高度进行调整。</p></li><li><p>具体实现思路： 回溯过程中，将当前节点的父节点不断向上更新</p></li><li><p>代码</p><pre><code class="cpp">// 查找过程, 查找元素p所对应的集合编号// O(h)复杂度, h为树的高度private int find(int p)&amp;#123;  assert( p &gt;= 0 &amp;&amp; p &lt; count );  // path compression 1  while( p != parent[p] )&amp;#123;      parent[p] = parent[parent[p]]; //指向父节点的父节点      p = parent[p];  &amp;#125;  return p;  // path compression 2, 递归算法//            if( p != parent[p] )//                parent[p] = find( parent[p] );//            return parent[p];&amp;#125;</code></pre></li></ul></li></ul></li></ul></li><li><p>并查集的应用</p><ul><li>题目<ul><li>leetcode130_<a href="https://leetcode-cn.com/problems/surrounded-regions/">被围绕的区域</a></li></ul></li></ul></li></ul><hr><h1 id="第七章-图"><a href="#第七章-图" class="headerlink" title="第七章: 图"></a>第七章: 图</h1><h2 id="7-1-图论基础"><a href="#7-1-图论基础" class="headerlink" title="7-1 图论基础"></a>7-1 图论基础</h2><ul><li>图的应用<ul><li>通信网路</li><li>社交网络</li><li>状态机等</li></ul></li><li>图的分类<ul><li>无权图与有权图</li><li>有向图与无向图</li></ul></li><li>图的表示<ul><li>（n,m） n个顶点，m条边</li><li>邻接矩阵 $n * n$矩阵 适合稠密图</li><li>邻接表  适合稀疏图</li><li>其他<h2 id="7-2-相邻点迭代器"><a href="#7-2-相邻点迭代器" class="headerlink" title="7-2 相邻点迭代器"></a>7-2 相邻点迭代器</h2></li></ul></li><li>图遍历过程中，避不开的便是遍历当前节点的相邻节点</li><li>迭代器的思想： 对外提供访问数据的功能，同时避免内部数据直接暴露在外</li><li>复杂度分析<ul><li>邻接矩阵 O(n) </li><li>邻接表 O(m)<h2 id="7-4-图的算法框架"><a href="#7-4-图的算法框架" class="headerlink" title="7-4 图的算法框架"></a>7-4 图的算法框架</h2></li></ul></li><li>读图方式（仅限本课程）<ul><li>不断添加边（需要知道顶点数）</li></ul></li></ul><h2 id="7-5-深度优先遍历和联通分量"><a href="#7-5-深度优先遍历和联通分量" class="headerlink" title="7-5 深度优先遍历和联通分量"></a>7-5 深度优先遍历和联通分量</h2><ul><li>深度优先遍历（DFS)<ul><li>基本思想 递归</li><li>复杂分析<ul><li>邻接表O（V+E）</li><li>邻接矩阵O(V^2)</li></ul></li></ul></li><li>求连通分支<ul><li>维护一个size为顶点数的vis数组 （可以存每个节点是否被访问，也可以每个节点存属于哪个分支）</li><li>对每一个没有被访问的节点进行深度优先遍历</li></ul></li><li>寻路<ul><li>维护一个from 数组 ，from[i]存第i个节点在dfs(s)过程中的上一个节点</li><li>从$s$ 节点开始 dfs()</li><li>从目的点d 开始，根据from数组回溯，得到s到d的路径<h2 id="7-7-广度优先遍历和最短路径"><a href="#7-7-广度优先遍历和最短路径" class="headerlink" title="7-7 广度优先遍历和最短路径"></a>7-7 广度优先遍历和最短路径</h2></li></ul></li><li>广度优先遍历<ul><li>基本思想 迭代</li><li>实现细节<ul><li><strong>处理环</strong>： 相对于树来说 图存在环的可能，所以遍历的时候是<strong>将加入队列的元素标记为已访问</strong>，而不是访问结点时才标记。</li></ul></li><li>复杂度分析<ul><li>邻接表O（V+E）</li><li>邻接矩阵O(V^2)</li></ul></li><li>求 无权图的 <strong>最短路径</strong><ul><li>维护一个from（回溯）数组，from[i]存第i个节点到dfs(s)过程中的上一个节点</li><li>维护一个order数组， order[i] 存 第i个节点在从s开始的bfs过程中的第几层（最短距离）</li><li>从$s$ 节点开始 bfs()</li><li>从 d 开始，根据from数组回溯<h2 id="7-8-更多无权图的应用"><a href="#7-8-更多无权图的应用" class="headerlink" title="7-8 更多无权图的应用"></a>7-8 更多无权图的应用</h2></li></ul></li></ul></li><li>迷宫生成，ps抠图等 </li></ul><hr><h1 id="第八章：最小生成树"><a href="#第八章：最小生成树" class="headerlink" title="第八章：最小生成树"></a>第八章：最小生成树</h1><h2 id="8-1-最小生成树问题和切分定理"><a href="#8-1-最小生成树问题和切分定理" class="headerlink" title="8-1 最小生成树问题和切分定理"></a>8-1 最小生成树问题和切分定理</h2><ul><li>最小生成树的应用<ul><li>电缆布线设计，网络设计，电路设计等。</li></ul></li><li>最小生成树的适用范围<ul><li>主要针对 带权 无向 连通图</li></ul></li><li>切分定理<ul><li>相关概念<ul><li>切分</li><li>横切边</li></ul></li><li><strong>切分定理</strong>： 给定任意切分，横切边中权值最小的边必然属于最小生成树<h2 id="8-2-Prim算法及其优化"><a href="#8-2-Prim算法及其优化" class="headerlink" title="8-2 Prim算法及其优化"></a>8-2 Prim算法及其优化</h2></li></ul></li><li>Lazy Prim 算法<ul><li>基本思想： 迭代/递归 贪心（每次根据切分定理得到局部最优） 动态规划？</li><li>算法流程<ul><li>递归/迭代遍历节点</li><li>将节点集合 分为  已经<strong>被访问过的节点</strong>和<strong>未被访问过的节点</strong>，并将切分这两个集合的<strong>横切边</strong>存入最小堆中 </li><li>每次选择最小堆中的横切边 出堆<ul><li>若 该横切边的两个端点均 已经被访问 ， 丢弃该边， 不做操作</li><li>否则， 将该边加入最小生成树中，继续<strong>遍历 该边中未被访问的点</strong>。</li></ul></li></ul></li><li>lazy体现在（局限性）: <ul><li>最小堆中，维护的横切边中，有很多不再时横切边的 没有及时丢弃。</li><li>复杂度 O(ElogE)</li></ul></li></ul></li><li>Prim算法的优化<ul><li>用<strong>索引堆</strong> (pq)来维护 <ul><li>每个已经被访问的点对应的最小横切边 的权重。pq.get（i） 表示第i个节点关联的当前最小横切边权重</li><li>上述横切边集合中 的 最小横切边的权重 （最小中的最小） （及堆顶）</li><li>用 edgeTo 辅助维护 边的信息（起始点）</li></ul></li><li>用 vis 数组来维护 节点是否已被访问</li><li>Prim 算法流程<ul><li>初始化： 将起始点的横切边 的权值加入索引堆<strong>pq</strong>中，起始点标记为 已经被访问</li><li>循环：<ul><li>选<strong>pq</strong>中 最小权值的横切边<strong>e</strong> 加入到最小生成树的 边集合</li><li><strong>递归</strong> 选出来边<strong>e</strong>的两个端点中 未被访问的节点v：<ul><li>端点v 标记为 已经被访问</li><li>遍历端点v 的 邻接边<strong>adjEdge</strong>，邻接边的另一个端点<strong>w</strong><ul><li>保证**pq[w]**小（(与w节点关联的当前最小横切边的权重）<ul><li>若<strong>pq[w]</strong>) 为空，则将 <strong>adjEdge</strong> 的权重 更新至 <strong>pq[w]</strong></li><li>或者若<strong>adjEdge</strong>的权重小于 <strong>pq[w]</strong>  则将 <strong>adjEdge</strong> 的权重更新至<strong>pq[w]</strong></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>复杂度分析 O(ElogV)</li></ul></li></ul><h2 id="8-3-Krusk算法"><a href="#8-3-Krusk算法" class="headerlink" title="8-3 Krusk算法"></a>8-3 Krusk算法</h2><ul><li>基本思想： 贪心 不断将<strong>不与已添加的边构成圈的最小边</strong> 加入到生成树边集合种</li><li>数据结构<ul><li>用最小堆，维护边集合，保证每次能取出剩余边中的最小边</li><li>用并查集，维护节点在当前生成树边集合下的连通度，判断新增边是否构成环</li></ul></li><li>算法流程<ul><li>对边进行排序(复杂度O(ElogE))，用最最小堆来维护边集合。</li><li>将最小边出堆，并加入生成树的集合。</li><li>循环开始：<ul><li>将 剩余边集合中 最小边 出堆<ul><li>判断改边与 生成树边集合中的边是否 构成环 （用并查集判断）<ul><li>若成环 抛弃， 继续找下一个边</li><li>将改边加入生成树的边集合</li></ul></li></ul></li></ul></li><li>复杂度分析 O(ElogE)<h2 id="8-6-最小生成树算法的思考"><a href="#8-6-最小生成树算法的思考" class="headerlink" title="8-6 最小生成树算法的思考"></a>8-6 最小生成树算法的思考</h2></li></ul></li><li>其他最小生成树的算法<ul><li>Vyssotsky’s Algorithm 将边逐渐添加到生成树中，一旦形成环，删除环中权值最大的边</li></ul></li></ul><hr><h1 id="第九章：最短路径"><a href="#第九章：最短路径" class="headerlink" title="第九章：最短路径"></a>第九章：最短路径</h1><h2 id="9-1-最短路径问题和松弛操作"><a href="#9-1-最短路径问题和松弛操作" class="headerlink" title="9-1 最短路径问题和松弛操作"></a>9-1 最短路径问题和松弛操作</h2><ul><li>最短路径的应用<ul><li>路径规划</li><li>工作任务计划</li></ul></li><li>广度优先遍历 求 无权图 的最短路径<ul><li>最短路径树 （单源最短路径：一点到所有其他点的最短路径）</li></ul></li><li>松弛操作(Relaxation)<ul><li>考虑经过该节点的 是否有到达其他节点的更短的路径<h2 id="9-2-Dijkstra算法的思想"><a href="#9-2-Dijkstra算法的思想" class="headerlink" title="9-2 Dijkstra算法的思想"></a>9-2 Dijkstra算法的思想</h2></li></ul></li><li>适用条件<ul><li>图中不能有<strong>负权边</strong></li><li>复杂度O(E log V)</li></ul></li><li>实现<ul><li>数据结构：<ul><li>索引堆： 维护每个节点当前被到达的最短路径， 以及 所有最短路径中的最短路径<ul><li>辅助：访问标记数组： 存当前节点是否进行了松弛操作</li></ul></li><li>回溯数组: 存到达该节点的最短路径中的上一个节点</li></ul></li></ul></li><li>算法流程<ul><li>初始化数据结构：<ul><li>索引堆<code>IndexMinHeap(imh)</code> imh[w] 表示第w个节点当前最短路径的权值</li><li>访问数组 <code>boolean[] marked</code>， marked[i] 表示第 i 个节点<strong>是否</strong>进行过松弛操作，初始都为false</li><li>回溯数组<code>int[] from</code>, from[i] 表示目的点为第i个节点的上一个节点，初始均赋值为-1</li></ul></li><li>初始化：将 源节点 $s$ 到自身的路径的权重 加入索引堆</li><li>循环（直至索引堆为空）<ul><li>当前距离源节点$s$ 最近的节点  $v$ ， 出堆<ul><li>如果 $v$ 没有进行过松弛操作（marked[v]==false）, 则对其进行 <strong>松弛操作</strong>：<ul><li>对 $v$ 所有邻节点 $w$ :<ul><li>如果 $w$ 没有进行过松弛操作（$marked[v]==false$）<ul><li>$s$ 经过 $v$ 到达 $w$ 的最短路径为：$dis = dis(s,v) + dis(v,w)$</li><li><code>if from[w]==-1||ids&lt;imh[w]</code> <ul><li><code>imh[w] = dis</code></li><li><code>from[w] = v</code></li></ul></li></ul></li></ul></li><li><code>marked[v] = true</code></li></ul></li></ul></li></ul></li><li>实现代码：<ul><li>初始化及核心代码<pre><code class="java">//初始化  marked = new boolean[graph.V()];from = new int[graph.V()];for(int i=0;i&lt;graph.V();i++) &amp;#123;    from[i] = -1;    marked[i] = false;&amp;#125;//DijkstraIndexMinHeap&lt;Weight&gt; imh = new IndexMinHeap&lt;&gt;(graph.V());imh.insert(s, (Weight)(Number)(0.0));while(!imh.isEmpty()) &amp;#123;    int v = imh.extractMinIndex();    if(!marked[v])         Relaxation(v,imh); //Relaxation松弛操作&amp;#125;</code></pre></li></ul></li></ul></li></ul><pre><code>  - 松弛操作```java        //松弛操作        void Relaxation(int v, IndexMinHeap imh) &amp;#123;        marked[v] = true;        //遍历邻边        for(Edge&lt;Weight&gt; e : (List&lt;Edge&gt;)graph.adj(v)) &amp;#123;            int w = e.getOther(v);            if(!marked[w])            &amp;#123;                Double dis = e.getW().doubleValue()+(((Number) imh.getItem(v)).doubleValue());                if(from[w] == -1||imh.getItem(w).compareTo(dis)&gt;0) &amp;#123;                    if(!imh.contain(w))                        imh.insert(w,dis);                    else                         imh.change(w, dis);                    from[w] = v;                &amp;#125;            &amp;#125;        &amp;#125;</code></pre><h2 id="9-3-负权边和Bellman-Ford算法"><a href="#9-3-负权边和Bellman-Ford算法" class="headerlink" title="9-3 负权边和Bellman-Ford算法"></a>9-3 负权边和Bellman-Ford算法</h2><ul><li><p>负权边带来的问题</p><ul><li>每次选择的并不是</li><li>负权环</li></ul></li><li><p>Bellman-Ford 单源最短路径算法</p><ul><li>前提： 图中不能有<strong>负权环</strong></li><li>Bellman-Ford 可以判断图中是否有负权环<ul><li>如果一个图没有负权环，则：<ul><li>从一个顶点到另一个顶点的最短路径，最多经过所有($V$)的顶点，即有$V-1$条边</li></ul></li><li>否则， 存在 顶点 经过了两次， 即 存在<strong>负</strong>权环</li></ul></li><li>复杂度 $O(EV)$</li></ul></li><li><p>Bellman-Ford 基本思想</p><ul><li>对所有点进行 $v-1$ 次 松弛操作，如果还可以继续松弛，则存在负权环</li><li>对所有点(V)进行松弛操作， 遍历所有的边(E),复杂度为O(VE)??</li></ul></li><li><p>算法流程</p><ul><li>Initial: from[s] = s; distTo[s] = 0;//初始化源节点 信息 </li><li>for pass = 1:G.V()-1 : //遍历 G.V()-1 遍<ul><li>for(int v=0; v &lt; G.V();v++) : //每一遍对每个节点进行一次松弛操作<ul><li>Relaxation(v)：<ul><li>如果$v$可达，遍历 $v$ 的所有邻接点 $wi$：<ul><li>$dis = dis(s,v) + dis(v,wi)$</li><li>if from[w]==-1||dis &lt; dis(s,w) :<ul><li>dis(s,w) = dis;</li><li>from[w] = v;</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>//对每个节点再进行一次松弛操作，如果路径还能再减，则存在<strong>负权环</strong></li></ul></li><li><p>实现代码</p><pre><code class="java">      // Bellman-Ford的过程      // 进行V-1次循环, 每一次循环求出从起点到其余所有点, 最多使用pass步可到达的最短距离      for( int pass = 1 ; pass &lt; G.V() ; pass ++ )&amp;#123;          // 每次循环中对所有的边进行一遍松弛操作          // 遍历所有边的方式是先遍历所有的顶点, 然后遍历和所有顶点相邻的所有边          for( int i = 0 ; i &lt; G.V() ; i ++ )&amp;#123;              // 使用我们实现的邻边迭代器遍历和所有顶点相邻的所有边              for( Object item : G.adj(i) )&amp;#123;                  Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;)item;                  // 对于每一个边首先判断e-&gt;v()可达                  // 之后看如果e-&gt;w()以前没有到达过， 显然我们可以更新distTo[e-&gt;w()]                  // 或者e-&gt;w()以前虽然到达过, 但是通过这个e我们可以获得一个更短的距离, 即可以进行一次松弛操作, 我们也可以更新distTo[e-&gt;w()]                  if( from[e.v()] != null &amp;&amp; (from[e.w()] == null || distTo[e.v()].doubleValue() + e.wt().doubleValue() &lt; distTo[e.w()].doubleValue()) )&amp;#123;                      distTo[e.w()] = distTo[e.v()].doubleValue() + e.wt().doubleValue();                      from[e.w()] = e;                  &amp;#125;              &amp;#125;          &amp;#125;      &amp;#125;</code></pre></li><li><p>检测是否有负权环</p><pre><code class="java"> // 判断图中是否有负权环  boolean detectNegativeCycle()&amp;#123;      for( int i = 0 ; i &lt; G.V() ; i ++ )&amp;#123;          for( Object item : G.adj(i) )&amp;#123;              Edge&lt;Weight&gt; e = (Edge&lt;Weight&gt;)item;              if( from[e.v()] != null &amp;&amp; distTo[e.v()].doubleValue() + e.wt().doubleValue() &lt; distTo[e.w()].doubleValue() )                  return true;          &amp;#125;      &amp;#125;      return false;  &amp;#125;</code></pre></li></ul><pre><code>- queue-based Bellman-Ford  - 对Bellman-Ford的优化- 其他  - 处理负权边通常是针对 **有向图**， 因为无向图的负权边 本身就是一个**负权环**##    9-4 更多和最短路径相关的思考  - 单源最短路径算法总结算法|边的权重|图的有向性|复杂度  :---|:---|:---|:---dijkstra|无负权边|有向，无向图均可|$O(ElogV)$Bellman-Ford|无负权环|有向图,或无负权边的无向图|$O(ElogV)$利用拓扑排序|有向无环图（DAG）|有向图|$O(V+E)$- 所有对最短路径算法  - Floyed算法， 处理无负权环的图，复杂度$O(V^3)$- 最长路径算法  - 不能有正权环  - 无权图的最长路径问题是指数难度的  - 对于有权图，不能使用Dijkstra求最长路径问题  - 可以使用Bellman-Ford (把所有路径都取负)---  # 第十章：结束语线性问题 &gt;&gt; 树形问题 &gt;&gt; 图形问题- 线性问题  - 排序问题    - $O(n^2)$ 选择排序 插入排序    - $O(nlog(n))$ 归并排序 快速排序 - 更多的算法问题  - 数据结构相关    - 双向队列    - 斐波那契堆    - 红黑树    - 区间树    - KD树    - ...  - 具体领域相关    - 数学： 数论 计算几何    - 图论： 网络流- 算法设计相关  - 分治算法    - 归并排序，快速算法， 树结构  - 贪心    - 选择排序； 堆 ； Kruskal ; Prim; Dijkstra ;...  - 递归回溯    - 树的遍历    - 图的遍历  - 动态规划    - 思想： **最优子结构**    - Prim ; Dijkstra - 大家加油！！</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LearnNotes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用hexo搭建博客笔记</title>
      <link href="/2020/08/12/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/12/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>nodejs</li><li>git</li><li>淘宝镜像源</li><li>hexo 安装</li></ol><h2 id="hexo-使用"><a href="#hexo-使用" class="headerlink" title="hexo 使用"></a>hexo 使用</h2><p>hexo s</p><p>hexo new “filename”</p><p>hexo init</p><p>hexo clean</p><p>hexo generate</p><p>配置git 仓库</p><p>hexo d</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/08/12/hello-world/"/>
      <url>/2020/08/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
