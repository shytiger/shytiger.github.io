<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>慕课网-算法与数据结构—学习总结</title>
      <link href="/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/12/%E6%85%95%E8%AF%BE%E7%BD%91-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>慕课网-算法与数据结构-学习总结</strong>  </p></blockquote><hr><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p><a href="https://github.com/liuyubobobo/Play-with-Algorithms">课程源码play-with-Algorithms</a></p><h1 id="第二章-排序基础"><a href="#第二章-排序基础" class="headerlink" title="第二章 排序基础"></a>第二章 排序基础</h1><ul><li><strong>排序的稳定性</strong><br>  排序后是否改变原序列键值相同的序列的先后关系</li><li><strong>内排序与外排序</strong><br>  外排序： 由于排序记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行 。外部排序最常用的算法是多路归并排序</li><li><strong>影响排序的三个方面</strong>  <ul><li>时间性能<ul><li>比较</li><li>移动</li></ul></li><li>辅助空间</li><li>算法复杂度  <h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2></li></ul></li></ul><ul><li><p>冒泡排序</p><ul><li>基本思想：两两交换，将最大（或最小）的交换至队列前  <h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2></li></ul></li><li><p>简单选择排序  </p><ul><li>基本思想：在未排序的序列种找到最小（或最大）的元素放到前面  </li><li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9TZWxlY3Rpb24tU29ydC1BbmltYXRpb24uZ2lm" alt="动画演示">  </li></ul></li><li><p>参考实现代码（cpp）</p><pre><code>    template&lt;typename T&gt;    void selectionSort(T arr[], int n)&amp;#123;        for(int i = 0 ; i &lt; n ; i ++)&amp;#123;            int minIndex = i;            for( int j = i + 1 ; j &lt; n ; j ++ )                if( arr[j] &lt; arr[minIndex] )                    minIndex = j;            swap( arr[i] , arr[minIndex] );        &amp;#125;    &amp;#125;</code></pre></li><li><p>直接选择排序  </p></li><li><p>树型选择排序</p></li></ul><h2 id="插入排序及其改进"><a href="#插入排序及其改进" class="headerlink" title="插入排序及其改进"></a>插入排序及其改进</h2><ul><li><p>直接插入排序  </p><ul><li><p>基本思想: 将未排序的元素插入到已经排好序的队列种对应的位置</p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTAxNjU5NC0xNTBiNmM0NjJlM2VkODA5LnBuZw?x-oss-process=image/format,png" alt="示意图">  </p></li><li><p>代码</p><pre><code>template&lt;typename T&gt;void insertionSort(T arr[], int n)&amp;#123;    for( int i = 1 ; i &lt; n ; i ++ ) &amp;#123;    // 寻找元素arr[i]合适的插入位置    // 写法1    //        for( int j = i ; j &gt; 0 ; j-- )    //            if( arr[j] &lt; arr[j-1] )    //                swap( arr[j] , arr[j-1] );    //            else    //                break;    // 写法2    //        for( int j = i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )    //            swap( arr[j] , arr[j-1] );    // 写法3                T e = arr[i];                int j; // j保存元素e应该插入的位置                for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; e; j--)                    arr[j] = arr[j-1];                arr[j] = e;    &amp;#125;    return;&amp;#125;</code></pre></li><li><p>改进：   </p><ul><li><p><strong>折半插入排序：</strong> 找到已排好序种对应位置时 用 折半查找   </p></li><li><p><strong>希尔排序</strong>:</p><ul><li><p>基本思想：交换不相邻的元素以对数组的<strong>局部</strong>进行排序</p></li><li><p><img src="https://upload-images.jianshu.io/upload_images/7779232-d19c19b7153b27b2.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/665/format/webp"></p></li><li><p>第一个O(n log n)的排序算法</p></li><li><p>参考代码</p><pre><code>template&lt;typename T&gt;void shellSort(T arr[], int n)&amp;#123;    // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...    int h = 1;    while( h &lt; n/3 )        h = 3 * h + 1;    while( h &gt;= 1 )&amp;#123;        // h-sort the array        for( int i = h ; i &lt; n ; i ++ )&amp;#123;            // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序            T e = arr[i];            int j;            for( j = i ; j &gt;= h &amp;&amp; e &lt; arr[j-h] ; j -= h )                arr[j] = arr[j-h];            arr[j] = e;        &amp;#125;        h /= 3;    &amp;#125;&amp;#125;</code></pre></li><li><p><a href="https://www.jianshu.com/p/642b19f8a69c">希尔排序及其优化</a>  </p></li></ul></li><li><p>其他： 路插入排序,表插入排序等。</p></li></ul></li></ul></li></ul><hr><h1 id="第三章-高级排序问题"><a href="#第三章-高级排序问题" class="headerlink" title="第三章 高级排序问题"></a>第三章 高级排序问题</h1><h2 id="归并排序及其优化"><a href="#归并排序及其优化" class="headerlink" title="归并排序及其优化"></a>归并排序及其优化</h2><ul><li><p>基本思想： (分治)将排序序列差分成 两个等长的子序列，对子序列进行排序后再归并</p></li><li><p>参考核心代码(cpp)</p><pre><code>    // 使用优化的归并排序算法, 对arr[l...r]的范围进行排序    template&lt;typename T&gt;    void __mergeSort2(T arr[], int l, int r)&amp;#123;        // 优化2: 对于小规模数组, 使用插入排序        if( r - l &lt;= 15 )&amp;#123;            insertionSort(arr, l, r);            return;        &amp;#125;        int mid = (l+r)/2;        __mergeSort2(arr, l, mid);        __mergeSort2(arr, mid+1, r);        // 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge        // 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失        if( arr[mid] &gt; arr[mid+1] )            __merge(arr, l, mid, r);    &amp;#125;</code></pre></li><li><p>优化点：    </p><pre><code>- 当排序的元素少于一定（16）时，直接调用 插入排序  - 如果第一个序列的最大值小于第二个序列的最小值，则不用比较，直接合并  </code></pre><ul><li><p>归并排序的自底向上写法（迭代）  </p></li><li><p><strong>核心代码参考</strong>    </p><pre><code>  ```          // 使用自底向上的归并排序算法  template &lt;typename T&gt;  void mergeSortBU(T arr[], int n)&amp;#123;      // Merge Sort Bottom Up 优化      // 对于小数组, 使用插入排序优化      for( int i = 0 ; i &lt; n ; i += 16 )          insertionSort(arr,i,min(i+15,n-1));      for( int sz = 16; sz &lt; n ; sz += sz )          for( int i = 0 ; i &lt; n - sz ; i += sz+sz )              // 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge              if( arr[i+sz-1] &gt; arr[i+sz] )                  __merge(arr, i, i+sz-1, min(i+sz+sz-1,n-1) );      // Merge Sort BU 也是一个O(nlogn)复杂度的算法，虽然只使用两重for循环      // 所以，Merge Sort BU也可以在1秒之内轻松处理100万数量级的数据      // 注意：不要轻易根据循环层数来判断算法的复杂度，Merge Sort BU就是一个反例      // 关于这部分陷阱，推荐看（liubobo老师）的《玩转算法面试》课程，第二章：《面试中的复杂度分析》：）  &amp;#125;  ```</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></li></ul></li><li><p>基本思想： （分治） 将选定的元素放到合适的位置，然后 递归 排序 被该元素分开的 前 后 两个子序列。(分出来的两个子序列可能不等长，相差很大，会影响性能)</p></li><li><p>核心代码参考  </p><pre><code>```// 对arr[l...r]部分进行partition操作// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]template &lt;typename T&gt;int _partition(T arr[], int l, int r)&amp;#123;    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr[l] , arr[rand()%(r-l+1)+l] );    T v = arr[l];    int j = l;    for( int i = l + 1 ; i &lt;= r ; i ++ )        if( arr[i] &lt; v )&amp;#123;            j ++;            swap( arr[j] , arr[i] );        &amp;#125;    swap( arr[l] , arr[j]);    return j;&amp;#125;// 对arr[l...r]部分进行快速排序template &lt;typename T&gt;void _quickSort(T arr[], int l, int r)&amp;#123;    // 对于小规模数组, 使用插入排序进行优化    if( r - l &lt;= 15 )&amp;#123;        insertionSort(arr,l,r);        return;    &amp;#125;    int p = _partition(arr, l, r);    _quickSort(arr, l, p-1 );    _quickSort(arr, p+1, r);&amp;#125;```</code></pre></li><li><p>优化：  </p><pre><code>1. 标定点 随机选（针对基本有序的序列，如果固定选最前面的元素，则分治的两个子问题不平衡，退化为O(n^2)的复杂度）  2. 小规模排序，使用插入排序</code></pre></li><li><p>双路快排  </p><ul><li><p>基本思想：针对键值重复过多时，分治的两个子序列不等长，导致分治不平衡</p></li><li><p>核心代码参考</p><pre><code>// 双路快速排序的partition// 返回p, 使得arr[l...p-1] &lt;= arr[p] ; arr[p+1...r] &gt;= arr[p]// 双路快排处理的元素正好等于arr[p]的时候要注意，详见下面的注释：）template &lt;typename T&gt;int _partition2(T arr[], int l, int r)&amp;#123;    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr[l] , arr[rand()%(r-l+1)+l] );    T v = arr[l];    // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v    int i = l+1, j = r;    while( true )&amp;#123;        // 注意这里的边界, arr[i] &lt; v, 不能是arr[i] &lt;= v        // 思考一下为什么?        while( i &lt;= r &amp;&amp; arr[i] &lt; v )            i ++;        // 注意这里的边界, arr[j] &gt; v, 不能是arr[j] &gt;= v        // 思考一下为什么?        while( j &gt;= l+1 &amp;&amp; arr[j] &gt; v )            j --;        // 对于上面的两个边界的设定, 有的同学在课程的问答区有很好的回答:)        // 大家可以参考: http://coding.imooc.com/learn/questiondetail/4920.html        if( i &gt; j )            break;        swap( arr[i] , arr[j] );        i ++;        j --;    &amp;#125;    swap( arr[l] , arr[j]);    return j;&amp;#125;// 对arr[l...r]部分进行快速排序template &lt;typename T&gt;void _quickSort(T arr[], int l, int r)&amp;#123;    // 对于小规模数组, 使用插入排序进行优化    if( r - l &lt;= 15 )&amp;#123;        insertionSort(arr,l,r);        return;    &amp;#125;    // 调用双路快速排序的partition    int p = _partition2(arr, l, r);    _quickSort(arr, l, p-1 );    _quickSort(arr, p+1, r);&amp;#125;</code></pre></li></ul></li><li><p>三路快排 </p><ul><li><p>基本思想： 针对2路快排的加强，进一步解决键值重复过多的问题（增加一个等值区域）</p></li><li><p>核心代码参考</p><pre><code>// 递归的三路快速排序算法template &lt;typename T&gt;void __quickSort3Ways(T arr[], int l, int r)&amp;#123;    // 对于小规模数组, 使用插入排序进行优化    if( r - l &lt;= 15 )&amp;#123;        insertionSort(arr,l,r);        return;    &amp;#125;    // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot    swap( arr[l], arr[rand()%(r-l+1)+l ] );    T v = arr[l];    int lt = l;     // arr[l+1...lt] &lt; v    int gt = r + 1; // arr[gt...r] &gt; v    int i = l+1;    // arr[lt+1...i) == v    while( i &lt; gt )&amp;#123;        if( arr[i] &lt; v )&amp;#123;            swap( arr[i], arr[lt+1]);            i ++;            lt ++;        &amp;#125;        else if( arr[i] &gt; v )&amp;#123;            swap( arr[i], arr[gt-1]);            gt --;        &amp;#125;        else&amp;#123; // arr[i] == v            i ++;        &amp;#125;    &amp;#125;    swap( arr[l] , arr[lt] );    __quickSort3Ways(arr, l, lt-1);    __quickSort3Ways(arr, gt, r);&amp;#125;template &lt;typename T&gt;void quickSort3Ways(T arr[], int n)&amp;#123;    srand(time(NULL));    __quickSort3Ways( arr, 0, n-1);&amp;#125;// 比较Merge Sort和双路快速排序和三路快排三种排序算法的性能效率// 对于包含有大量重复数据的数组, 三路快排有巨大的优势// 对于一般性的随机数组和近乎有序的数组, 三路快排的效率虽然不是最优的, 但是是在非常可以接受的范围里// 因此, 在一些语言中, 三路快排是默认的语言库函数中使用的排序算法。比如Java:)</code></pre><h2 id="归并排序和快速排序衍生的问题"><a href="#归并排序和快速排序衍生的问题" class="headerlink" title="归并排序和快速排序衍生的问题"></a>归并排序和快速排序衍生的问题</h2></li></ul><ul><li>求逆序对（归并排序）</li><li>求数组中的第N大元素</li></ul></li></ul><hr><h1 id="第四章-堆和堆排序"><a href="#第四章-堆和堆排序" class="headerlink" title="第四章 堆和堆排序"></a>第四章 堆和堆排序</h1><h2 id="基本概念认识"><a href="#基本概念认识" class="headerlink" title="基本概念认识"></a>基本概念认识</h2><ul><li>队列<ul><li>普通队列：先进先出</li><li>优先队列：根据优先级出队  </li></ul></li><li><strong>优先队列应用</strong>  对动态的数据排序  </li><li>优先队列的三种实现方式  <table><thead><tr><th align="left">实现方式</th><th align="left">入队</th><th align="left">出队</th></tr></thead><tbody><tr><td align="left">普通数组</td><td align="left">O(1)</td><td align="left">O(n)</td></tr><tr><td align="left">顺序数组(元素有序)</td><td align="left">O(n)</td><td align="left">O(1)</td></tr><tr><td align="left">堆</td><td align="left">O(log n)</td><td align="left">O(log n)</td></tr></tbody></table></li></ul><h2 id="堆的基本存储"><a href="#堆的基本存储" class="headerlink" title="堆的基本存储"></a>堆的基本存储</h2><pre><code>* 用数组存储二叉堆* 数组的索引次序 对应 二叉堆中 层序遍历次序* 对于完全二叉树,对第i个元素，其与其父，其子的关系（第一个元素根的索引为0）    * parent(i) = （i-1）/2    * left child (i) = 2*i +1    * right child (i) = 2*i + 2</code></pre><h3 id="heapfy过程（堆的建立）"><a href="#heapfy过程（堆的建立）" class="headerlink" title="heapfy过程（堆的建立）"></a>heapfy过程（堆的建立）</h3><pre><code>将n个元素逐个插入空堆中，算法复杂度为O(n log n),而heapfy过程算法复杂度O(n)  - 代码```    // 构造函数, 通过一个给定数组创建一个最大堆    // 该构造堆的过程, 时间复杂度为O(n)    MaxHeap(Item arr[], int n)&amp;#123;        data = new Item[n+1];        capacity = n;        for( int i = 0 ; i &lt; n ; i ++ )            data[i+1] = arr[i];        count = n;        for( int i = count/2 ; i &gt;= 1 ; i -- )            shiftDown(i);    &amp;#125;```</code></pre><h2 id="ShiftUp"><a href="#ShiftUp" class="headerlink" title="ShiftUp"></a>ShiftUp</h2><pre><code>- 代码    ```        void shiftUp(int k)&amp;#123;        while( k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] )&amp;#123;            swap( data[k/2], data[k] );            k /= 2;        &amp;#125;        &amp;#125;    ``` </code></pre><h2 id="ShiftDown"><a href="#ShiftDown" class="headerlink" title="ShiftDown"></a>ShiftDown</h2><pre><code>- 代码```    void shiftDown(int k)&#123;    while( 2*k &lt;= count )&#123;        int j = 2*k; // 在此轮循环中,data[k]和data[j]交换位置        if( j+1 &lt;= count &amp;&amp; data[j+1] &gt; data[j] )            j ++;        // data[j] 是 data[2*k]和data[2*k+1]中的最大值        if( data[k] &gt;= data[j] ) break;        swap( data[k] , data[j] );        k = j;    &#125;    &#125;```</code></pre><h2 id="堆排序及其优化"><a href="#堆排序及其优化" class="headerlink" title="堆排序及其优化"></a>堆排序及其优化</h2><pre><code>* 堆排序算法：    * 创建堆      * 堆顶出堆： 将堆顶与堆尾互换，堆的size-1,并将新的堆顶（原堆尾）shiftDown()    * 重复第二步  * 堆排序的代码    ```            // heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序            // 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)            // 整个堆排序的整体时间复杂度为O(nlogn)            template&lt;typename T&gt;            void heapSort1(T arr[], int n)&#123;                MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);                for( int i = 0 ; i &lt; n ; i ++ )                    maxheap.insert(arr[i]);                for( int i = n-1 ; i &gt;= 0 ; i-- )                    arr[i] = maxheap.extractMax();            &#125;            // heapSort2, 借助我们的heapify过程创建堆            // 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 实践复杂度为O(nlogn)            // 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优    ```* 堆的实现细节    *ShiftUp和ShiftDown种使用复制操作替换swap操作*  </code></pre><h2 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h2><ul><li>基本思想： 交换索引（存储地址），而不交换实际的元素</li><li>应用： 最小生成树Prim算法中，用来维护 每个节点对应的最小横切面的权重【同时能输出当前所有节点最小横切面中的最小横切面】<h2 id="涉及堆-的相关问题"><a href="#涉及堆-的相关问题" class="headerlink" title="涉及堆 的相关问题"></a>涉及堆 的相关问题</h2><ul><li>多路归并排序 多个元素同时比较的时候用，最小（大）堆</li><li>d叉堆 d-ary heap  </li><li>最大最小队列 （最大堆和最小堆同时维护？？）</li><li>二项堆</li><li>斐波那契堆</li></ul></li></ul><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><pre><code>基本思想： 分配 + 收集 （先排序低位再排序高位）</code></pre><h2 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h2><table><thead><tr><th align="left">排序</th><th align="left">平均时间复杂度</th><th align="left">原地排序</th><th align="left">额外空间</th><th align="left">稳定排序</th></tr></thead><tbody><tr><td align="left">插入排序（Insertion Sort）</td><td align="left">O(n^2)</td><td align="left">是</td><td align="left">O(1)</td><td align="left">是</td></tr><tr><td align="left">归并排序(Merge Sort)</td><td align="left">O（nlogn）</td><td align="left">否</td><td align="left">O(n)</td><td align="left">是</td></tr><tr><td align="left">快速排序（Quick Sort）</td><td align="left">O(nlogn)</td><td align="left">是</td><td align="left"><strong>O（logn）</strong></td><td align="left">否</td></tr><tr><td align="left">堆排序（Heap Sort)</td><td align="left">O(nlogn)</td><td align="left">是</td><td align="left">O(1)</td><td align="left">否</td></tr></tbody></table><ul><li><strong>不同排序算法的选择</strong>  <ul><li>n较小：直接插入排序或直接选择排序</li><li>基本有序序列，直接插入，冒泡，随机的快速排序</li><li>n较大，应选复杂度好的：快速排序，归并排序， 堆排序。<ul><li>快速排序性能平均最好，堆排序更少的辅助空间，归并排序是稳定的排序。（当排序数少于一定时如16，<strong>调用直接插入排序</strong>）</li></ul></li><li></li></ul></li></ul><p><strong>其他参考</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjIyOTk3LWIxYmIwNDg4NDlhMjI3YmUucG5n?x-oss-process=image/format,png" alt="排序算法总结"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOS8wMy9zb3J0LnBuZw?x-oss-process=image/format,png" alt="排序对比"><br><img src="https://img-blog.csdn.net/2018101109461342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pocTExODY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br> <a href="https://blog.csdn.net/liu17234050/article/details/104217658">C语言中的14种排序</a><br>[14中排序动画演示](<a href="https://v.qq.com/x/page/e0523qakza6.html%EF%BC%89">https://v.qq.com/x/page/e0523qakza6.html）</a>  </p><hr><h1 id="第五章-二分搜索树"><a href="#第五章-二分搜索树" class="headerlink" title="第五章 二分搜索树"></a>第五章 二分搜索树</h1><h2 id="5-1-二分查找法"><a href="#5-1-二分查找法" class="headerlink" title="5-1 二分查找法"></a>5-1 二分查找法</h2><h2 id="5-2-二分搜索树基础"><a href="#5-2-二分搜索树基础" class="headerlink" title="5-2 二分搜索树基础"></a>5-2 二分搜索树基础</h2><h2 id="5-3-二分搜索树的节点插入"><a href="#5-3-二分搜索树的节点插入" class="headerlink" title="5-3 二分搜索树的节点插入"></a>5-3 二分搜索树的节点插入</h2><h2 id="5-4-二分搜索书的查找"><a href="#5-4-二分搜索书的查找" class="headerlink" title="5-4 二分搜索书的查找"></a>5-4 二分搜索书的查找</h2><h2 id="5-5-二分搜索树的遍历（深度优先遍历）"><a href="#5-5-二分搜索树的遍历（深度优先遍历）" class="headerlink" title="5-5 二分搜索树的遍历（深度优先遍历）"></a>5-5 二分搜索树的遍历（深度优先遍历）</h2><h2 id="5-6-层序遍历（广度优先遍历）"><a href="#5-6-层序遍历（广度优先遍历）" class="headerlink" title="5-6 层序遍历（广度优先遍历）"></a>5-6 层序遍历（广度优先遍历）</h2><h2 id="5-7-删除最大值，最小值"><a href="#5-7-删除最大值，最小值" class="headerlink" title="5-7 删除最大值，最小值"></a>5-7 删除最大值，最小值</h2><h2 id="5-8-二分搜索树的删除"><a href="#5-8-二分搜索树的删除" class="headerlink" title="5-8 二分搜索树的删除"></a>5-8 二分搜索树的删除</h2><h2 id="5-9-二分搜索树的顺序性"><a href="#5-9-二分搜索树的顺序性" class="headerlink" title="5-9 二分搜索树的顺序性"></a>5-9 二分搜索树的顺序性</h2><h2 id="5-10-二分搜索树的局限性"><a href="#5-10-二分搜索树的局限性" class="headerlink" title="5-10 二分搜索树的局限性"></a>5-10 二分搜索树的局限性</h2><h2 id="5-11-树形问题和更多树。"><a href="#5-11-树形问题和更多树。" class="headerlink" title="5-11 树形问题和更多树。"></a>5-11 树形问题和更多树。</h2><hr><h1 id="第六章-并查集"><a href="#第六章-并查集" class="headerlink" title="第六章:并查集"></a>第六章:并查集</h1><h2 id="6-1-并查集基础"><a href="#6-1-并查集基础" class="headerlink" title="6-1 并查集基础"></a>6-1 并查集基础</h2><h2 id="6-2-Qucik-Find"><a href="#6-2-Qucik-Find" class="headerlink" title="6-2 Qucik Find"></a>6-2 Qucik Find</h2><h2 id="6-3-Quick-Union"><a href="#6-3-Quick-Union" class="headerlink" title="6-3 Quick Union"></a>6-3 Quick Union</h2><h2 id="6-4-基于size的优化"><a href="#6-4-基于size的优化" class="headerlink" title="6-4 基于size的优化"></a>6-4 基于size的优化</h2><h2 id="6-5-基于rank的优化"><a href="#6-5-基于rank的优化" class="headerlink" title="6-5 基于rank的优化"></a>6-5 基于rank的优化</h2><h2 id="6-6-路径压缩"><a href="#6-6-路径压缩" class="headerlink" title="6-6 路径压缩"></a>6-6 路径压缩</h2><hr><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章:"></a>第七章:</h1><h2 id="7-1-图论基础"><a href="#7-1-图论基础" class="headerlink" title="7-1 图论基础"></a>7-1 图论基础</h2><h2 id="7-2-图的表示"><a href="#7-2-图的表示" class="headerlink" title="7-2 图的表示"></a>7-2 图的表示</h2><h2 id="7-3-相邻点迭代器"><a href="#7-3-相邻点迭代器" class="headerlink" title="7-3 相邻点迭代器"></a>7-3 相邻点迭代器</h2><h2 id="7-4-图的算法框架"><a href="#7-4-图的算法框架" class="headerlink" title="7-4 图的算法框架"></a>7-4 图的算法框架</h2><h2 id="7-5-深度优先遍历和联通分量"><a href="#7-5-深度优先遍历和联通分量" class="headerlink" title="7-5 深度优先遍历和联通分量"></a>7-5 深度优先遍历和联通分量</h2><h2 id="7-6-寻路"><a href="#7-6-寻路" class="headerlink" title="7-6 寻路"></a>7-6 寻路</h2><h2 id="7-7-广度优先遍历和最短路径"><a href="#7-7-广度优先遍历和最短路径" class="headerlink" title="7-7 广度优先遍历和最短路径"></a>7-7 广度优先遍历和最短路径</h2><h2 id="7-8-迷宫生成，ps抠图–更多无权图的应用"><a href="#7-8-迷宫生成，ps抠图–更多无权图的应用" class="headerlink" title="7-8 迷宫生成，ps抠图–更多无权图的应用"></a>7-8 迷宫生成，ps抠图–更多无权图的应用</h2><hr><h1 id="第八章：最小生成树"><a href="#第八章：最小生成树" class="headerlink" title="第八章：最小生成树"></a>第八章：最小生成树</h1><h2 id="8-1-有权图"><a href="#8-1-有权图" class="headerlink" title="8-1 有权图"></a>8-1 有权图</h2><h2 id="8-2-最小生成树问题和切分定理"><a href="#8-2-最小生成树问题和切分定理" class="headerlink" title="8-2 最小生成树问题和切分定理"></a>8-2 最小生成树问题和切分定理</h2><h2 id="8-3-Prim算法的第一个实现"><a href="#8-3-Prim算法的第一个实现" class="headerlink" title="8-3 Prim算法的第一个实现"></a>8-3 Prim算法的第一个实现</h2><h2 id="8-4-Prim算法的优化"><a href="#8-4-Prim算法的优化" class="headerlink" title="8-4 Prim算法的优化"></a>8-4 Prim算法的优化</h2><h2 id="8-5-优化后的Prim算法的实现"><a href="#8-5-优化后的Prim算法的实现" class="headerlink" title="8-5 优化后的Prim算法的实现"></a>8-5 优化后的Prim算法的实现</h2><h2 id="8-6-Krusk算法"><a href="#8-6-Krusk算法" class="headerlink" title="8-6 Krusk算法"></a>8-6 Krusk算法</h2><h2 id="8-7-最小生成树算法的思考"><a href="#8-7-最小生成树算法的思考" class="headerlink" title="8-7 最小生成树算法的思考"></a>8-7 最小生成树算法的思考</h2><hr><h1 id="第九章：最短路径"><a href="#第九章：最短路径" class="headerlink" title="第九章：最短路径"></a>第九章：最短路径</h1><h2 id="9-1-最短路径问题和松弛操作"><a href="#9-1-最短路径问题和松弛操作" class="headerlink" title="9-1 最短路径问题和松弛操作"></a>9-1 最短路径问题和松弛操作</h2><h2 id="9-2-Dijkstra算法的思想"><a href="#9-2-Dijkstra算法的思想" class="headerlink" title="9-2 Dijkstra算法的思想"></a>9-2 Dijkstra算法的思想</h2><h2 id="9-3-实现Dijkstra算法"><a href="#9-3-实现Dijkstra算法" class="headerlink" title="9-3 实现Dijkstra算法"></a>9-3 实现Dijkstra算法</h2><h2 id="9-4-负权边和Bellman-Ford算法"><a href="#9-4-负权边和Bellman-Ford算法" class="headerlink" title="9-4 负权边和Bellman-Ford算法"></a>9-4 负权边和Bellman-Ford算法</h2><h2 id="9-5-实现Bellman-Ford算法"><a href="#9-5-实现Bellman-Ford算法" class="headerlink" title="9-5 实现Bellman-Ford算法"></a>9-5 实现Bellman-Ford算法</h2><h2 id="9-6-更多和最短路径相关的思考"><a href="#9-6-更多和最短路径相关的思考" class="headerlink" title="9-6 更多和最短路径相关的思考"></a>9-6 更多和最短路径相关的思考</h2><hr><h1 id="第十章：结束语"><a href="#第十章：结束语" class="headerlink" title="第十章：结束语"></a>第十章：结束语</h1>]]></content>
      
      
      
        <tags>
            
            <tag> LearnNotes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基础</title>
      <link href="/2020/08/12/markdown%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/08/12/markdown%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown-基础入门"><a href="#markdown-基础入门" class="headerlink" title="markdown 基础入门"></a>markdown 基础入门</h1><h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><pre><code>换行：两次空格回车  </code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://ns-strategy.cdn.bcebos.com/ns-strategy/upload/fc_big_pic/part-00782-3232.jpg" alt="风景">  </p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://github.com/">github</a>  </p><hr><blockquote><p>高亮显示</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表用-或-或-表示"><a href="#无序列表用-或-或-表示" class="headerlink" title="无序列表用 * 或 + 或 - 表示"></a>无序列表用 * 或 + 或 - 表示</h3><ul><li>A  </li><li>B</li></ul><ul><li>C  </li><li>C</li></ul><ul><li>D  </li><li>E<h3 id="有序列表-数字加-标识-如-1"><a href="#有序列表-数字加-标识-如-1" class="headerlink" title="有序列表 数字加. 标识 如 1."></a>有序列表 数字加. 标识 如 1.</h3></li></ul><ol><li>I</li><li>love</li></ol><h3 id="使用列表的注意事项"><a href="#使用列表的注意事项" class="headerlink" title="使用列表的注意事项"></a>使用列表的注意事项</h3><h5 id="如果在单一列表项中包含了多个段落，为了保证渲染正常，-与段落首字母之间必须保留四个空格"><a href="#如果在单一列表项中包含了多个段落，为了保证渲染正常，-与段落首字母之间必须保留四个空格" class="headerlink" title="如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格"></a>如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格</h5><ul><li>段落一<br>小段一</li><li>段落二<br>小段二<h5 id="另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格"><a href="#另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格" class="headerlink" title="另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格"></a>另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格</h5></li><li>段落一  <blockquote><p>区块标记1  </p></blockquote></li><li>段落二<blockquote><p>区块标记2  </p></blockquote></li></ul><p>注：记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。  </p><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p><em>斜体</em><br><em>斜体</em></p><p><strong>加粗</strong><br><strong>加粗</strong></p><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><p>使用反引号`(esc下那个键)进行包裹，如果是行内代码引用，使用单个反引号包裹。  </p><p>java 的 <code>toString()</code> 与 <code>hashcode</code>  </p><pre><code>     String toString()&amp;#123;     &amp;#125;</code></pre><pre><code>     cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</code></pre><p>插入表格  </p><table><thead><tr><th align="left">表头</th><th align="left">条目1</th><th align="left">条目2</th></tr></thead><tbody><tr><td align="left">项目</td><td align="left">项目1</td><td align="left">项目2</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="特殊符号处理"><a href="#特殊符号处理" class="headerlink" title="特殊符号处理"></a>特殊符号处理</h3><pre><code>     \   反斜线     `   反引号     *   星号     _   底线     &amp;#123;&amp;#125;  花括号     []  方括号     ()  括弧     #   井字号     +   加号     -   减号     .   英文句点     !   惊叹号</code></pre><blockquote><p>Markdown使用反斜杠\插入语法中用到的特殊符号。例如，如果你需要插入反斜杠，就连续输入两个反斜杠即可：<code>\\</code> =&gt; \ 。在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。</p></blockquote><h3 id="给文字上色"><a href="#给文字上色" class="headerlink" title="给文字上色"></a>给文字上色</h3><pre><code>先用Markdown编辑完成导出为html，在需要上色的部分手动添加标签&lt;font color=&#39;#ff0000&#39;&gt;&lt;/font&gt;保存即可。</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/335db5716248">最完整的Markdown基础教程</a><br><a href="https://www.jianshu.com/c/65c0f5f216cc">Markdown 语法快速上手</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tagTest1</title>
      <link href="/2020/08/12/tagTest1/"/>
      <url>/2020/08/12/tagTest1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用hexo搭建博客笔记</title>
      <link href="/2020/08/12/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/12/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>nodejs</li><li>git</li><li>淘宝镜像源</li><li>hexo 安装</li></ol><h2 id="hexo-使用"><a href="#hexo-使用" class="headerlink" title="hexo 使用"></a>hexo 使用</h2><p>hexo s</p><p>hexo new “filename”</p><p>hexo init</p><p>hexo clean</p><p>hexo generate</p><p>配置git 仓库</p><p>hexo d</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyFirstBlog</title>
      <link href="/2020/08/12/MyFirstBlog/"/>
      <url>/2020/08/12/MyFirstBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p> 开始你的表演</p><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>你的表演满分</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.woyaobaofu.com/">www.woyaobaofu.com</a></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/08/12/hello-world/"/>
      <url>/2020/08/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
